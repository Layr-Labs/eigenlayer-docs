---
sidebar_position: 5
title: AVS Contracts
---

The AVS contracts are the contracts that call the [EigenLayer contacts](eigenlayer-contracts/core-contracts.md). An AVS can split onchain components across
multiple contracts to enable a modular design.

:::note
Before the Slashing release introduced [User Access Management (UAM)](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-003.md), AVS contract calls to EigenLayer were routed through a
single ServiceManager contract. With UAM, a modular approach to AVS contracts is possible. 

The [Hello World](https://github.com/Layr-Labs/hello-world-avs) and [Incredible Squaring](https://github.com/Layr-Labs/incredible-squaring-avs) examples are in the process of being updated to use UAM.
:::


---

---
sidebar_position: 1
title: AVS Overview
---


## What is an Autonomous Verifiable Service (AVS)?

An Autonomous Verifiable Service (AVS) on EigenLayer is a decentralized service built on Ethereum that provides custom verification mechanisms of off-chain operations. Please see the [Intro to EigenLayer](https://docs.eigenlayer.xyz/eigenlayer/overview/) for background context on the broader EigenLayer ecosystem.

An AVS is composed of on-chain contracts for verification and an off-chain network of Operators. Operators execute the service on behalf of the AVS and then post evidence of their execution on-chain to the AVS contracts. Tasks can be initiated via on-chain contracts, off-chain via direct communication with the Operators, or via a task aggregator entity.

The design of the off-chain execution and on-chain verification is entirely flexible based on the needs of the AVS developer. 
- If the Operators perform tasks properly, the AVS can autonomously distribute rewards.
- If the Operators perform tasks maliciously, their delegate stake can be slashed autonomously by the AVS, and the Operator can be removed from the Operator set. 

 Please see the original EigenLayer whitepaper [EigenLayer: The Restaking Collective](/docs/eigenlayer/overview/whitepaper.md) for further background on AVS design.

![AVS Architecture](/img/avs/avs-architecture-v2.png)


## Why Build an AVS?

Launching new Web3 projects requires substantial time and effort to bootstrap capital and operators. Builders should focus on their core product differentiators rather than bootstrapping economic security. Building an Autonomous Verifiable Service (AVS) on EigenLayer offers enhanced security, decentralization, and cost efficiency by utilizing Ethereum’s staking mechanism through restaking. This allows developers to focus more on their product’s core value and innovation without the significant overhead of setting up a new consensus mechanism or validator networks from scratch.

The key benefits of building an AVS on EigenLayer include:
- Security via Restaking: leverage Ethereum’s staking mechanism to secure your service.
- Focus on your project's unique value: spend less time and resources accumulating economic security from scratch.
- Bootstrap your Operator network: quickly access a large network of experienced Operators.
- Decentralization and Trust: build on trust-minimized, decentralized infrastructure.
- Composability: seamlessly integrate with the broader Ethereum ecosystem.


## What Can You Build as an AVS?

The scope of AVS design is broad. It includes **any off-chain service** that can be verified on-chain. This flexibility allows AVS developers to design custom verification mechanisms suited to the unique requirements of their service. The only requirement is that some evidence for the off-chain service’s execution is posted on-chain to enable verification of the service.

Examples of these services include rollup services, co-processors, cryptography services, zk Proof services, and more.

![AVS Categories](/img/avs/avs-categories.png)


## Get in Touch

If you would like to discuss your ideas to build an AVS on EigenLayer, submit your contact information via [this form](https://share.hsforms.com/1BksFoaPjSk2l3pQ5J4EVCAein6l) and we'll be in touch shortly.


---

---
sidebar_position: 6
title: AVS Keys
---

For information on AVS key types, refer to [Keys](../../eigenlayer/concepts/keys-and-signatures).

---

---
sidebar_position: 5
title: AVS Security Models
---

The security model of an AVS defines who or what is trusted in an AVS, and under what conditions that trust holds. AVSs may 
have different levels of decentralization, slashing risks, and trust assumptions.

Security models available to AVSs in order of decentralization include:
* Proof of Authority. An AVS maintains a whitelist of trusted Operators.
* Permissionless Trusted Operation. An AVS trusts the top N Operators by delegated stake to run the service.
  The Permissionless Operator set can be managed by Operator ejection if SLAs are not met.
* Unique Stake allocation. An AVS requires Operators to have a certain amount of Unique Stake (that is, Slashable Stake) allocated.
  Slashing conditions can be: 
  * Objective. Attributable onchain faults. For example, rollup execution validity. 
  * Subjective. Governance based. For example, token holders in a DAO vote to slash, or vote to veto slashing.
  * Intersubjective Slashing Conditions. Broad-based agreement among all reasonable active observers. For example, data
    withholding.

:::note 
The list of security models is not exhaustive. The EigenLayer protocol provides a slashing function that is maximally flexible.
AVSs have flexibility to design their protocols to slash for any reason. AVSs are encouraged to:
* Create robust legibility and process around how their slashing is designed and individual slashing events. 
* Clearly communicate slashing design and individual slashing events to their Operator and Staker communities. 
:::

---

---
sidebar_position: 1
title: EigenLayer Core Contracts
---

The EigenLayer core contracts are the set of contracts that implement the EigenLayer protocol. The EigenLayer protocol includes
Staking, Operations, and AVS registration and allocation. The contracts for an AVS interact with the EigenLayer contracts. 

The [EigenLayer middleware contracts](middleware-contracts.md) are the higher level interface to the core contracts for new AVS developers. 

The EigenLayer core contracts are documented in the [eigenlayer-contracts](https://github.com/Layr-Labs/eigenlayer-contracts) repository. The core contracts include: 

| Core contract                                                                                                            | Description                                                                                                                                                                                                                                  | 
|--------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [StrategyManager](https://github.com/Layr-Labs/eigenlayer-contracts/tree/testnet-sepolia/docs#strategymanager)           | Responsible for handling the accounting for Restakers as they deposit and withdraw ERC20 tokens from their corresponding strategies. The StrategyManager tracks the amount of restaked assets each Restaker has within Eigenlayer.           |
| [DelegationManager](https://github.com/Layr-Labs/eigenlayer-contracts/tree/testnet-sepolia/docs#delegationmanager)       | Responsible for enabling Restakers to delegate assets to Operators, and withdraw assets. The DelegationManager tracks the amount of assets from each Strategy that have been delegated to each Operator, and tracks accounting for slashing. | 
| [EigenPodManager](https://github.com/Layr-Labs/eigenlayer-contracts/tree/testnet-sepolia/docs#eigenpodmanager)           | Enables native ETH restaking                                                                                                                                                                                                                 | 
| [AllocationManager](https://github.com/Layr-Labs/eigenlayer-contracts/tree/testnet-sepolia/docs#allocationmanager)       | Responsible for creating Operator Sets, and Operator registrations to Operator Sets. The Allocation Manager also tracks allocation of stake to a Operator Set, and enables AVSs to slash that stake.                                         
| [RewardsCoordinator](https://github.com/Layr-Labs/eigenlayer-contracts/tree/testnet-sepolia/docs#allocationmanager)      | Enables AVSs to distribute ERC20 tokens to Operators and Restakers who delegated assets to Operators. The RewardsCoordinator tracks the rewards and enables Operators and Restakers to claim them.                                           
| [PermissionController](https://github.com/Layr-Labs/eigenlayer-contracts/tree/testnet-sepolia/docs#permissioncontroller) | Enables AVSs and operators to delegate the ability to call certain core contract functions to other addresses. For more information, refer to [User Access Management](../../../eigenlayer/concepts/uam/user-access-management.md).          |
| [AVSDirectory](https://github.com/Layr-Labs/eigenlayer-contracts/tree/testnet-sepolia/docs#avsdirectory)                 | Has been replaced by AllocationManager and will be deprecated in a future release.                                                                                                                                                           | 

AVSDirectory will be deprecated in a future release. We strongly recommend existing AVSs [migrate to using Operator Sets](../../HowTo/build/slashing/migrate-to-operatorsets.md)
on Testnet.

This documentation matches the functionality available on the [Sepolia testnet](https://www.blog.eigenlayer.xyz/the-future-of-eigenlayer-testing-new-and-improved-testnets-tooling-coming-soon/). For mainnet
specific documentation, refer to the `/docs` repository on the `mainnet` branch in the [eigenlayer-contracts](https://github.com/Layr-Labs/eigenlayer-contracts)
repository.

---

---
sidebar_position: 1
title: EigenLayer Middleware Contracts
---

The EigenLayer middleware contracts are higher level interfaces to the [EigenLayer core contracts](core-contracts.md).
The middleware contracts can be: 
* Deployed as is. The exception is the ServiceManager contract used to register and deregister an AVS with EigenLayer.
* Modified to implement logic specific to the AVS before deploying 
* Not used. In this case, the interfaces present in the middleware contracts must be implemented in the AVS contracts.

We recommend new AVS developers use the middleware contracts as the higher level interface
to the core contracts. 

The middleware contracts are documented in the [eigenlayer-middleware](https://github.com/Layr-Labs/eigenlayer-middleware) repository.
The ServiceManagerBase contract is the reference implementation for the onchain registration and deregistration that each AVS must have.

---

---
sidebar_position: 1
title: Slashing
---

For information on how slashing works, refer to concept content on [Slashing](../../../eigenlayer/concepts/slashing/slashing-concept.md) and
[Operator Sets](../../../eigenlayer/concepts/operator-sets/operator-sets-concept).

For information on how to implement slashing, refer to: 
* [Implement Slashing](../../HowTo/build/slashing/implement-slashing)
* [Design Operator Sets](../../HowTo/build/slashing/design-operator-set.md)
* [Migrate to Operator Sets](../../HowTo/build/slashing/migrate-to-operatorsets.md)
* [Veto Committee Design](../../HowTo/build/slashing/slashing-veto-committee-design.md)

---

---
sidebar_position: 8
title: Tasks
---

Tasks are a common design model used for AVS operations. The task design model is not required by the EigenLayer protocol but
is a common mechanism used by AVSs. Use tasks to organize discrete units of work performed by Operators offchain that
are later validated onchain. A Task can be any unit of work written in any language as needed by the AVS.

Tasks can be submitted either:
1) Onchain by the Consumer (end user) to the AVS contracts.
2) Offchain by the Consumer directly to the Operators.

---

---
sidebar_position: 4
title: User Access Management
---

:::note
There is no support for setting appointees for AVSDirectory functions. The AVSDirectory method will be deprecated in a future upgrade.
[All AVSs will need to migrate to Operator Sets before the upcoming deprecation of AVSDirectory](../HowTo/build/slashing/migrate-to-operatorsets.md).
:::

For concept material on User Access Management (UAM) and roles, refer to:
* [User Access Management](../../eigenlayer/concepts/uam/user-access-management.md)
* [Accounts](../../eigenlayer/concepts/uam/uam-accounts.md)
* [Admins](../../eigenlayer/concepts/uam/uam-admins.md)
* [Appointees](../../eigenlayer/concepts/uam/uam-appointees.md)

UAM enables an AVS to split onchain components across multiple contracts to enable a modular design. 
The protocol functions that an AVS can set appointees for are:
* [`AllocationManager.slashOperator`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#slashoperator)
* [`AllocationManager.deregisterFromOperatorSets`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#deregisterfromoperatorsets)
* [`AllocationManager.setAVSRegistrar`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#setavsregistrar)
* [`AllocationManager.updateAVSMetadataURI`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#updateavsmetadatauri)
* [`AllocationManager.createOperatorSets`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#createoperatorsets)
* [`AllocationManager.addStrategiesToOperatorSet`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#addstrategiestooperatorset)
* [`AllocationManager.removeStrategiesFromOperatorSet`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#removestrategiesfromoperatorset)
* [`RewardsCoordinator.createOperatorDirectedAVSRewardsSubmission`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#createoperatordirectedavsrewardssubmission)
* [`RewardsCoordinator.createOperatorDirectedOperatorSetRewardsSubmission`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#createoperatordirectedoperatorsetrewardssubmission)
* [`RewardsCoordinator.setClaimerFor`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#setclaimerfor)

For information on how to set admins and appointees for an AVS, refer to:
* [Add and Remove Admins](../HowTo/build/uam/dev-add-remove-admins.md)
* [Add and Remove Appointees](../HowTo/build/uam/dev-add-remove-appointees.md)


---

---
sidebar_position: 7
title: Add ERC-20 Tokens as Restakable Asset
---

# Permissionless Token Strategies

Permissionless token support enables any ERC-20 token to be permissionlessly added as a restakable asset, significantly broadening
the scope of assets that can contribute to the security of decentralized networks, and unlocking the cryptoeconomic security of 
ERC-20 tokens on EigenLayer.

With permissionless token support, AVSs can choose to accept any ERC-20 token as a restaked asset to provide cryptoeconomic security for 
their AVS. This allows AVSs to evaluate the supply and utility of all available tokens to create cross-ecosystem partnerships 
while ensuring the safety and security of their services. This increases alignment and connectivity across the ecosystem.

# Adding a New Strategy

To add a new Strategy to the EigenLayer protocol:

* Invoke `StrategyFactory.deployNewStrategy()`.
* Your Strategy is now available to associate with your AVS.

Please see the contract documentation [here](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/StrategyManager.md#strategyfactorydeploynewstrategy) for further detail.

:::note
Custom Strategies are strategies that are not deployed via `StrategyFactory.deployNewStrategy()` and require whitelisting via 
`StrategyFactory.whitelistStrategies` (see [here](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/StrategyManager.md#strategyfactorywhiteliststrategies)). Custom Strategies have custom bytecode and do not implement `StrategyBase`. 

Custom Strategies are not yet supported because the Strategies specification is still evolving alongside the EigenLayer
protocol. AVS developers should build their AVS using the `StrategyBase` interface and functionality, which provides a
stable and supported foundation for integration.
:::

---

---
sidebar_position: 5
title: Manage Operator Sets
---

To manage [Operator Sets](../../../eigenlayer/concepts/operator-sets/operator-sets-concept.md) for an AVS:
1. [Create Operator Sets](#create-operator-sets)
2. [Modify Strategy composition](#modify-strategy-composition) 
3. [Update AVS Metadata](#update-avs-metadata)

## Create Operator Sets

Creating Operator Sets for an AVS is managed by the [AllocationManager core contract](../../Concepts/eigenlayer-contracts/core-contracts.md). 
[Strategies](../../../eigenlayer/concepts/operator-sets/strategies-and-magnitudes) can be added to Operator Sets when the Operator is created, or Strategies can be added to an existing Operator Set.

To create an Operator Set, call the [`createOperatorSets`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#createoperatorsets) function. 
To add strategies when creating an Operator Set, specify a `params` array containing the strategies.

On creation, an `id` is assigned to the Operator Set. Together the AVS `address` and `id` are a unique identifier for the Operator Set. 

## Modify Strategy Composition

An Operator Set requires at least one [Strategy](../../../eigenlayer/concepts/operator-sets/strategies-and-magnitudes).

To add Strategies to an existing Operator Set, call the [`addStrategiesToOperatorSet`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#addstrategiestooperatorset) function.

To remove Strategies from an Operator Set, call the [`removeStrategiesFromOperatorSet`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#removestrategiesfromoperatorset) function.

## Update AVS Metadata

:::tip
The AVS metadata is used to provide information on the [EigenLayer App](https://app.eigenlayer.xyz/) for Stakers and Operators.
:::

Once Operator Sets have been created, the AVS metadata can be updated to include the Operator Sets. 

To update metadata, call the [`updateAVSMetadataURI`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#avs-metadata) function. Use the following format. 

```
{
    "name": "AVS",
    "website": "https.avs.xyz/",
    "description": "Some description about",
    "logo": "http://github.com/logo.png",
    "twitter": "https://twitter.com/avs",
    "operatorSets": [
        {
            "name": "ETH Set",
            "id": "1", 
            "description": "The ETH operatorSet for AVS",
            "software": [
                {
                    "name": "NetworkMonitor",
                    "description": "",
                    "url": "https://link-to-binary-or-github.com"
                },
                {
                    "name": "ValidatorClient",
                    "description": "",
                    "url": "https://link-to-binary-or-github.com"
                }
            ],
            "slashingConditions": ["Condition A", "Condition B"]
        },
        {
            "name": "EIGEN Set",
            "id": "2", 
            "description": "The EIGEN operatorSet for AVS",
            "software": [
                {
                    "name": "NetworkMonitor",
                    "description": "",
                    "url": "https://link-to-binary-or-github.com"
                },
                {
                    "name": "ValidatorClient",
                    "description": "",
                    "url": "https://link-to-binary-or-github.com"
                }
            ],
            "slashingConditions": ["Condition A", "Condition B"]
        }
    ]
}
```

---

---
sidebar_position: 6
title: Manage Registered Operators
---

## AVSRegistrar

The [AVSRegistrar](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/src/contracts/interfaces/IAVSRegistrar.sol) is called when operators register for and deregister from [Operator Sets](../../../eigenlayer/concepts/operator-sets/operator-sets-concept.md). By default (if the stored address
is 0), the call is made to the ServiceManager contract for the AVS. If the AVS has set a different contract as the AVSRegistrar, the specified contract is called.

### Setting AVSRegistrar

To set a contract as the AVSRegistrar, call the [`setAVSRegistrar`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#setavsregistrar) function. The target contract must also implement 
[`supportsAVS(AVS)`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/src/contracts/interfaces/IAVSRegistrar.sol) returning TRUE or setting the contract as the AVSRegistrar fails.

## Respond to Operator Registrations to Operator Sets

Operators use the [`registerForOperatorSets`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#registerforoperatorsets) function to register for AVS's operator sets. AVSs can reject ineligible 
Operators based on their own custom logic specified in the [AVSRegistrar](#avsregistrar).

For an AVS to reject an Operator attempting to join an Operator Set, the call from [AllocationManager](../../Concepts/eigenlayer-contracts/core-contracts.md) to the 
[`IAVSRegistrar.registerOperator`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/src/contracts/interfaces/IAVSRegistrar.sol) function must revert. 

## Deregister Operators from, or respond to Operator deregistrations, from Operator Sets

Deregistration from an Operator Set can be triggered by either the Operator, or the AVS for the Operator Set, using the
[`deregisterFromOperatorSets`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#deregisterfromoperatorsets) function.

Similar to when an Operator registers for an Operator Set, if the call to [IAVSRegistrar.deregisterOperator](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/src/contracts/interfaces/IAVSRegistrar.sol) reverts, the
deregistration also reverts and does not occur. 


---

---
sidebar_position: 4
title: Register AVS Metadata
---

Metadata must be registered:
* Before an AVS can create [Operator Sets](../../../eigenlayer/concepts/operator-sets/operator-sets-concept.md) or register Operators to Operator Sets.
* To [onboard to the AVS Dashboard](../publish/onboard-avs-dashboard.md).

Registering metadata for an AVS is managed by the [AllocationManager core contract](../../Concepts/eigenlayer-contracts/core-contracts.md).  

To register metadata, call the [`updateAVSMetadataURI`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#avs-metadata) function on the AllocationManager. Invoking [`updateAVSMetadataURI`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#avs-metadata)
on the AllocationManager establishes the AVS address in the core EigenLayer protocol. 

## Format

To register metadata, the AVS must provide a URL to the JSON data in the following format. The format is not validated onchain. 

The metadata must be consistently available, and the URL provided to [`updateAVSMetadataURI`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/9a19503e2a4467f0be938f72e80b11768b2e47f9/docs/core/AllocationManager.md#avs-metadata) must not cause redirects.

```
{
    "name": "AVS",
    "website": "https.avs.xyz/",
    "description": "Some description about",
    "logo": "http://github.com/logo.png",
    "twitter": "https://twitter.com/avs",
}
```

## Logo

The logo linked to in the metadata must: 
* Be consistently available.
* Be hosted somewhere retrievable publicly.
* Not cause redirects.
* Be under 1MB.
* Return a png image, and not html with an image embedded or any other format.

If you need a repository for your logo to be hosted publicly, make a PR to the [`eigendata`](https://github.com/Layr-Labs/eigendata)
repository to add your logo.

---

---
sidebar_position: 3
title: Design Operator Sets
---

An [Operator Set](../../../../eigenlayer/concepts/operator-sets/operator-sets-concept.md) is a grouping of different types of work within a single AVS. Each AVS has at least one Operator Set. The 
EigenLayer protocol does not enforce criteria for Operator Sets.

Best practices for Operator Set design are to logically group AVS tasks (and verification) into separate Operator Sets. 
Organize your Operator Sets according to conditions for which you wish to distribute Rewards. Potential conditions include:
* Unique business logic.
* Unique Stake (cryptoeconomic security) amount and types of token required to be allocated from Operators.
* Slashing conditions.
* Ejection criteria.
* Quantity of Operators and criteria for operators allowed.
* Hardware profiles.
* Liveness guarantees.

For more information on Operator Sets, refer to [Operator Sets](../../../../eigenlayer/concepts/operator-sets/operator-sets-concept).

---

---
sidebar_position: 1
title: Implement Slashing
---

:::important
Before proceeding, review the [Slashing Concept](../../../../eigenlayer/concepts/slashing/slashing-concept.md) content and [Unique Stake Allocation & Deallocation ELIP-002](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md)
for detailed information on slashing.
:::

The `AllocationManager` provides the interface for the slashing function.

```solidity
    /**
     * @notice Called by an AVS to slash an operator in a given operator set
     */

    function slashOperator(
        address avs,
        SlashingParams calldata params
    ) external;

    /**
     * @notice Struct containing parameters to slashing
     * @param operator the address to slash
     * @param operatorSetId the ID of the operatorSet the operator is being slashed on behalf of
     * @param strategies the set of strategies to slash
     * @param wadsToSlash the parts in 1e18 to slash, this will be proportional to the operator's
     * slashable stake allocation for the operatorSet
     * @param description the description of the slashing provided by the AVS for legibility
     */
    struct SlashingParams {
        address operator;
        uint32 operatorSetId;
        IStrategy[] strategies;
        uint256[] wadsToSlash;
        string description;
    }
```

To implement slashing, AVSs specify:
* Individual Operator
* [Operator Set](../../../../eigenlayer/concepts/operator-sets/operator-sets-concept.md)
* [List of Strategies](../../../../eigenlayer/concepts/operator-sets/strategies-and-magnitudes)
* [List of proportions (as `wads` or “parts per `1e18`”)](../../../../eigenlayer/concepts/operator-sets/strategies-and-magnitudes)
* Description. 

For example, in the `wadsToSlash` parameter: 
* 8% slash is represented as `8e16`, or `80000000000000000`. 
* 25% slash is represented as `2.5e17` or `250000000000000000`. 

The indexes in the two arrays must match across `strategies` and `wadsToSlash`. 

All Strategies supplied must be configured as part of the Operator Set. For all Strategies specified, the Operator’s allocations
to that Operator Set are slashed by the corresponding proportion while maintaining their nominal allocations to all other Operator Sets.
Maintaining nominal allocations is achieved by subtracting the allocated magnitude from both the specified Operator Set, 
and the Operator’s Total Magnitude.

Slashing proportionally reduces funds of all Stakers of the given Strategies that are delegated to the Operator, including funds
in queued deallocations and withdrawals (that haven’t passed `WITHDRAWAL_DELAY`). Operator delegation is decreased directly 
in the `DelegationManager` in each Strategy. Changes are propagated to Staker withdrawals and view functions by referring to their
delegated Operator’s Total Magnitude.

When a slashing occurs, one event is emitted onchain for each slashing. Emitted details identify the Operator
slashed, in what Operator Set, and across which Strategies, with fields for the proportion slashed and meta-data.
```
/// @notice Emitted when an operator is slashed by an operator set for a strategy
/// `wadSlashed` is the proportion of the operator's total delegated stake that was slashed
event OperatorSlashed(
    address operator, OperatorSet operatorSet, IStrategy[] strategies, uint256[] wadSlashed, string description
);
```

## Example

The allocated magnitudes are: 

|  | Magnitude | Proportion | EIGEN |
| :---- | :---- | :---- | :---- |
| `AVS_1_EIGEN` | 2,000 | 20% | 40 |
| `AVS_2_EIGEN` | 2,500 | 25% | 50 |
| `EigenDA_EIGEN` | 2,000 | 20% | 40 |
| `Non-slashable` | 3,500 | 35% | 70 |
| `Total`  | 10,000 | 100% | 200 |

`AVS_1` slashes the Operator for a 50% reduction (`5e17` in `wads`) in the Operator Set `AVS_1_EIGEN`:

|  | Magnitude | Proportion | EIGEN |
| :---- | :---- | :---- | :---- |
| `AVS_1_EIGEN` | 1,000 | 11% | 20 |
| `AVS_2_EIGEN` | 2,500 | 28% | 50 |
| `EigenDA_EIGEN` | 2,000 | 22% | 40 |
| `Non-slashable` | 3,500 | 39% | 70 |
| `Total` | 9000 | 100% | 180 |

Slashing by one Operator Set does not affect the magnitudes of EIGEN allocated to other Operator Sets. The interactions between
Staker, Operator, AVS, and core contracts are represented in the sequence diagram.

![Sequence Representation of a Slashing](/img/operator-guides/operator-sets-figure-5.png)  
***Figure: Sequence Representation of a Slashing***

---

---
sidebar_position: 2
title: Migrate to Operator Sets
---

**The AVSDirectory method will be deprecated in a future upgrade. All AVSs will need to migrate to [Operator Sets](../../../../eigenlayer/concepts/operator-sets/operator-sets-concept) before the
upcoming deprecation of AVSDirectory.**

Operator Sets are required to [slash](../../../../eigenlayer/concepts/slashing/slashing-concept.md). To migrate to, and start using, Operator Sets: 
1. [Upgrade middleware contracts](#upgrade-middleware-contracts) 
2. [Integrate the AllocationManager](#upgrade-middleware-contracts)
3. [Communicate to Operators](#communicate-to-operators)

Migrating now gives time to switch existing quorums over to Operator Sets. After the migration has occurred,
integrations with slashing can go live on Testnet, followed by Mainnet. M2 registration and Operator Set registration can operate in parallel.

## Upgrade middleware contracts

To migrate to Operator Sets:

1. Upgrade middleware contracts to handle the callback from the AllocationManager. The upgrade provides the RegistryCoordinator
the hooks to handle the callback from the AllocationManager. 
2. From the ServiceManager call, add an account to update the AVSRegistrar:
      * With setAppointee where the target is the AllocationManager.
      * The selector is the setAVSRegistrar selector.
3. Call setAVSRegistrar on the AllocationManager from the appointee account and set the RegistryCoordinator as your AVSRegistrar
so that it becomes the destination for registration and deregistration hooks

See example [RegistryCoordinator implementation with the new hooks](https://github.com/Layr-Labs/eigenlayer-middleware/blob/dev/src/SlashingRegistryCoordinator.sol).

## Integrate the AllocationManager

Integrate the AllocationManager by:

1. Creating Operator Sets through the AllocationManager.
2. Adding (or later removing) specific Strategies to that Operator Set to enable Operators to secure the AVS.
3. Specifying an additional AVSRegistrar contract that applies business logic to gate Operator registration to an Operator Set.

## Communicate to Operators

1. Communicate to Operators how to:
   1. Register for Operator Sets using the new registration pathway. 
   2. Allocate slashable stake for slashable Operator Sets.
2. Migrate to distribution of tasks based on the delegated and slashable stake of Operators registered to the AVS’s Operator Sets.

To ensure community and incentive alignment, AVSs need to conduct offchain outreach to communicate
the purpose and task/security makeup of their Operator Sets with their Operators and Stakers before beginning registration.
Include any potential hardware, software, or stake requirements in the communication. The AVS decides task distribution
within an Operator Set.


---

---
sidebar_position: 4
title: Design Slashing Conditions
---

## Slashing Vetoes

EigenLayer provides a maximally flexible slashing function. AVSs may slash any Operator in any of their Operator Sets for
any reason. Slashing does not have to be objectively attributable (that is, provable on-chain). We encourage AVSs to create
robust legibility and process around individual slashings. Governance, fraud proofs, and decentralization
must be considered in AVS slashing designs. Include delays and veto periods in AVS designs to avoid or cancel slashing
in cases of AVS implementation bugs, improper slashing, or fraud.

**No vetoes are provided by the EigenLayer protocol.**

## Veto Committee Design

One popular AVS design is to utilize a governance mechanism with slashing such that a committee can review a proposed (or queued) 
slashing request. That slashing request can then be either fulfilled or vetoed by a committee of domain experts, governance 
council or multisig address for the AVS. Please see the [vetoable slasher example implementation](https://github.com/Layr-Labs/eigenlayer-middleware/blob/dev/src/slashers/VetoableSlasher.sol) for reference.

Ensure that your slashing process can be resolved within the `DEALLOCATION_DELAY` time window. This is the amount of blocks
between an Operator queuing a deallocation of stake from an Operator Set for a strategy and the deallocation taking effect. 
This will ensure that the slashing event is carried out for the Operator before their stake is deallocated.


---

---
sidebar_position: 5
title: Submit Rewards Submissions
---

:::important
`RewardsCoordinator.createAVSRewardsSubmission` and `RewardsCoordinator.createOperatorDirectedAVSRewardsSubmission` use AVSDirectory. 
The AVSDirectory method will be deprecated in a future upgrade. [All AVSs will need to migrate to Operator Sets before the upcoming deprecation of AVSDirectory](slashing/migrate-to-operatorsets.md).

If you are currently using AVSDirectory, `RewardsCoordinator.createAVSRewardsSubmission` and `RewardsCoordinator.createOperatorDirectedAVSRewardsSubmission` can continue to be used while AVSDirectory is being used.
:::

For information on Rewards concepts, refer to [Rewards Overview](../../../eigenlayer/concepts/rewards/rewards-concept.md).

Submitting rewards for an AVS is handled by the [RewardsCoorinator core contract](../../Concepts/eigenlayer-contracts/core-contracts.md).

To submit rewards submissions, use [`RewardsCoordinator.createOperatorDirectedOperatorSetRewardsSubmission`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#createoperatordirectedoperatorsetrewardssubmission).

An AVS can use onchain or offchain data in rewards logic to determine the reward amount per Operator. The rewards can be calculated 
based on the work performed by Operators during a certain period of time, can be a flat reward rate, or another structure based on 
the AVS’s economic model. An AVS can distribute rewards in any ERC20 token.

For more flexibility, an AVS can submit multiple performance-based Operator rewards denominated in different tokens.

:::note
The reward rate for Stakers is based on the amount of stake delegated to an Operator and does not change based on the 
rewards calculation per Operator by the AVS.
:::

## Implementation Notes 

Each rewards submission specifies:

* Time range for which the rewards submission is valid. Rewards submissions can be retroactive from the [M2 upgrade](https://github.com/Layr-Labs/eigenlayer-contracts/releases/tag/v0.2.3-mainnet-m2)
  and last up to 30 days in the future.
* List of strategies and multipliers that enables the AVS to weigh the relative payout to each strategy within a single rewards submission.
* ERC20 token in which rewards should be denominated.

Additional considerations: 

* Reward roots are posted weekly on Mainnet and daily on Testnet.
* Reward roots are on a 7-day activation delay (that is, when it is claimable against) on Mainnet and 2-hour activation delay on Testnet.
* Reward amounts are calculated based on activity across a 24 hour window. Each window's amounts are cumulative and include day + (day - 1). 
  Reward roots are posted weekly on Mainnet based on that day's snapshot date which correlates to a 24 hour window. Mainnet and Testnet are 
  functionally equivalent in their calculations. The reward roots are only posted weekly for Mainnet.
* Once a rewards submission is made by an AVS, the AVS is unable to retract those rewards. If the AVS does not have any Operators opted 
  into the AVS on a day of an active reward, those tokens are not distributed pro-rata to future days, and are refunded to the AVS. 
  There are two cases where this occurs:
    * An operator is not registered for the entire duration of the submission. The entire operator amount is refunded to the AVS.
    * If an operator is only registered for m days out of n days duration. The operator is only paid amount/m on each of those m days.
* Operators are only distributed rewards on days that they have opted into the AVS for the full day.
* Due to the rounding in the off-chain process, we recommend not making range submission token amounts with more than 15 significant digits of precision. 
  If more than 15 significant digits are provided, the extra precision is truncated.
* Rewards can be made in multiple ERC-20 tokens by submitting rewards submissions for each ERC-20 token to reward in.

## When Rewards are Included
An AVSs reward submission is included in the calculation 2 days after it is submitted. For example, if the AVS submits a 
rewards submission on August 2nd, it is included in the August 4th rewards calculation.

## When Rewards can be Claimed
At most, Restakers and Operators of an AVS will have to wait 16 days to claim a reward (2 day calculation delay + 7 day root 
submission cadence + 7 day activation delay).

At minimum, Restakers and Operators have to wait 9 days to claim a reward.



---

---
sidebar_position: 1
title: Add and Remove Admins
---

:::caution
Security of admin keys is critical. UAM enables appointees with lessened permissions, and use of keys that can be rotated or 
destroyed. For more information on key management best practices, refer to [AVS Developer Security Best Practices](../../../Reference/avs-developer-best-practices.md).

After an account has added an admin and the pending admin has accepted, the account address no 
longer has default admin privileges. That is, the original account key of the Operator or AVS cannot be
used for write operations to the protocol, unless previously added as an admin, or is added back as admin in the future.
There is no superadmin role.

The removal of default admin privileges upon adding additional admins enables accounts 
to perform a key rotation to remove permissions from a potentially compromised original key. 

For an account to retain admin 
privileges for its own address, add the account first as an admin. After the account is added as an admin, add other admins as needed.
:::

## Add an Admin Using the Core Contracts

Admins are added via a 2-step handshake. To add an admin:
1. As the account or admin adding the admin, call the [`PermissionController.addPendingAdmin`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/permissions/PermissionController.md#addpendingadmin) function to set the pending admin.
2. As the pending admin, call the [`PermissionController.acceptAdmin`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/permissions/PermissionController.md#acceptadmin) function. Once accepted, the added admin has full admin authority.

## Remove an Admin Using the Core Contracts

The caller must be an admin. Once an account has added an admin, there must always be at least one admin for the account. 

To remove a pending admin before they have called acceptAdmin, call the [`PermissionController.removePendingAdmin`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/permissions/PermissionController.md#removependingadmin) function.

To remove an admin, call the [`PermissionController.removeAdmin`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/permissions/PermissionController.md#removeadmin) function.


---

---
sidebar_position: 2
title: Add and Remove Appointees
---

Only admins (or the account if no admin has been set) can add appointees. Unlike adding an admin, there is no requirement
for an appointee to accept the appointment.

For the list of contracts and functions that can have appointees set, refer to:
* [User Account Management](../../../Concepts/uam-for-avs.md) for AVS
* [User Account Management](../../../../operators/concepts/uam-for-operators.md) for Operators

## Add an Admin using Core Contracts 

To add an appointee, call the [PermissionController.setAppointee](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/permissions/PermissionController.md#setappointee) function.

To remove an appointee, call the [PermissionController.removeAppointee](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/permissions/PermissionController.md#removeappointee) function.

---

---
sidebar_position: 6
title: Prepare for and Deploy to Testnet and Mainnet
---


## Preparing and Deploying to Testnet

1. Package the Operator’s long running executable in a way that is easy for Operators to launch  (via binary, docker container, or similar).

2. Author Testnet user and Operator documentation, including:
   - Trust Modeling: clarify any trust assumptions in your architecture to your users. Identify the components that are trusted (centralized) and untrusted (decentralized, trustless).
   - Operator instructions to install, register, deregister.
   - End user (aka “Consumer”) instructions to utilize your AVS service.
   - Communication channels that will be utilized for AVS upgrades.
   - Describe Operator monitoring tooling available, such as GraFana dashboards, log files or similar.

3. Follow the [AVS Developer Security Best Practices](../../Reference/avs-developer-best-practices.md) and [Key Manage Considerations for Developers](../../Reference/avs-developer-best-practices.md#key-management-recommendation-for-developers).

4.  Follow the [Testnet Dashboard Onboarding instructions](https://docs.eigenlayer.xyz/eigenlayer/avs-guides/avs-dashboard-onboarding).

5. Implement Rewards distributions per the instructions [here](../build/submit-rewards-submissions.md).


## Preparing and Deploying to Mainnet

1. Smart Contract Auditing: have your codebase audited with at least 2-3 reputable audit firms.
2. Finalize User and Operator documentation.
3. Follow the [Mainnet Dashboard Onboarding instructions](https://docs.eigenlayer.xyz/eigenlayer/avs-guides/avs-dashboard-onboarding).

---

---
sidebar_position: 2
title: Implement onchain components
---

To build an AVS, the minimum set of functionality to be defined in the [AVS contracts](../../Concepts/avs-contracts.md) is:
* [Registering AVS metadata](../build/register-avs-metadata.md)
* [Managing Operator Sets](../build/manage-operator-sets.md)
    * [Creating and modifying Strategy composition](../build/manage-operator-sets.md#modify-strategy-composition)
* [Managing registered Operators](../build/manage-registered-operators.md)
    * [Responding to Operator registrations](../build/manage-registered-operators.md#respond-to-operator-registrations-to-operator-sets)
    * [Deregistering Operators](../build/manage-registered-operators.md#deregister-operators-from-or-respond-to-operator-deregistrations-from-operator-sets)
* [Distributing Rewards](../build/submit-rewards-submissions) 


---

---
sidebar_position: 1
title: Get started
---

:::note

We are in the process of updating our samples to include Rewards and Slashing capabilities. The Hello World AVS example will be
updated as soon as possible. Use Hello World AVS now to get familiar with EigenLayer. 

For more information on Rewards and Slashing, refer to the [Rewards](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-001.md) and [Slashing](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md) ELIPs,
and [Rewards](../../../eigenlayer/concepts/rewards/rewards-concept.md) and [Slashing](../../Concepts/slashing/slashing-concept-developers) documentation. 

For questions or support, reach out to us using the Intercom button on the bottom right side of this page or <a href="javascript:void(0)"  id="intercom_trigger_eldocs" >here</a>. 
We will promptly follow up with support!

:::

## Hello World AVS: Local Deployment
The [Hello World AVS](https://github.com/Layr-Labs/hello-world-avs) is a simple implementation designed to demonstrate the core mechanics of how AVSs work within the EigenLayer framework. This example walks you through the process of:
- Spinning up a local chain with EigenLayer contracts and AVS contracts preconfigured.
- Registering an Operator with both EigenLayer and the AVS.
- Consumer client requesting work to be done by the AVS.
- Operator listening picking up this request, performing it, and signing off on it.
- The AVS contract verifying the operator's work.

![Hello World Diagram](/img/avs/hello-world-diagram-v2.png)

## Key Components of Hello World AVS
- AVS Consumer: Requests a "Hello, ___" message to be generated and signed.
- AVS: Takes the request and emits an event for operators to handle.
- Operators: Picks up the request, generates the message, signs it, and submits it back to the AVS.
- Validation: Ensures the operator is registered and has the necessary stake, then accepts the submission.


## Code Walkthrough

The following sections highlight a few crucial components of the Hello World example that implement core AVS functionality. 

### AVS Contract

**[HelloWorldServiceManager.sol](https://github.com/Layr-Labs/hello-world-avs/blob/master/contracts/src/HelloWorldServiceManager.sol)**

The contract definition declares that it implements `ECDSAServiceManagerBase`, which allows it to inherit the core required functionality of `IServiceManager`. These contracts are included from the [eigenlayer-middleware repo](https://github.com/Layr-Labs/eigenlayer-middleware/tree/dev/docs#eigenlayer-middleware-docs) and are [required components](https://github.com/Layr-Labs/eigenlayer-middleware/tree/dev/docs#system-components) for any AVS.

```sol
contract HelloWorldServiceManager is ECDSAServiceManagerBase, IHelloWorldServiceManager {
    using ECDSAUpgradeable for bytes32;
```

The following functions are responsible for the "business logic" of the AVS. In the case of hello world the business logic includes managing the lifecycle of a "task" (creation and response) with a simple `name` string value.
```sol
function createNewTask(
    string memory name
) external returns (Task memory) {
    // create a new task struct
    Task memory newTask;
    newTask.name = name;
    newTask.taskCreatedBlock = uint32(block.number);

    // store hash of task on-chain, emit event, and increase taskNum
    allTaskHashes[latestTaskNum] = keccak256(abi.encode(newTask));
    emit NewTaskCreated(latestTaskNum, newTask);
    latestTaskNum = latestTaskNum + 1;

    return newTask;
}

function respondToTask(
    Task calldata task,
    uint32 referenceTaskIndex,
    bytes memory signature
) external {
    // check that the task is valid, hasn't been responded to yet, and is being responded in time
    require(
        keccak256(abi.encode(task)) == allTaskHashes[referenceTaskIndex],
        "supplied task does not match the one recorded in the contract"
    );
    require(
        allTaskResponses[msg.sender][referenceTaskIndex].length == 0,
        "Operator has already responded to the task"
    );

    // The message that was signed
    bytes32 messageHash = keccak256(abi.encodePacked("Hello, ", task.name));
    bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();
    bytes4 magicValue = IERC1271Upgradeable.isValidSignature.selector;
    if (!(magicValue == ECDSAStakeRegistry(stakeRegistry).isValidSignature(ethSignedMessageHash,signature))){
        revert();
    }

    // updating the storage with task responses
    allTaskResponses[msg.sender][referenceTaskIndex] = signature;

    // emitting event
    emit TaskResponded(referenceTaskIndex, task, msg.sender);
}
```

### Contract Deployment Scripts

**[HelloWorldDeployer.s.sol](https://github.com/Layr-Labs/hello-world-avs/blob/master/contracts/script/HelloWorldDeployer.s.sol)**

The deployment of the HelloWorld contracts associates the quorums and their asset strategies to the AVS.

```sol
token = new ERC20Mock();
helloWorldStrategy = IStrategy(StrategyFactory(coreDeployment.strategyFactory).deployNewStrategy(token));

quorum.strategies.push(
    StrategyParams({strategy: helloWorldStrategy, multiplier: 10_000})
);
```

### Off-chain Operator Code


**[index.ts](https://github.com/Layr-Labs/hello-world-avs/blob/master/operator/index.ts)**

The following snippets of Operator code manage Operator registration to core EigenLayer protocol, registration to the Hello World AVS, listening and responding to tasks.

```sol
// Register Operator to EigenLayer core contracts and Hello World AVS
const registerOperator = async () => {
    
    // Registers as an Operator in EigenLayer.
    try {
        const tx1 = await delegationManager.registerAsOperator({
            __deprecated_earningsReceiver: await wallet.address,
            delegationApprover: "0x0000000000000000000000000000000000000000",
            stakerOptOutWindowBlocks: 0
        }, "");
        await tx1.wait();
        console.log("Operator registered to Core EigenLayer contracts");
    }
    
    ...
    
    
    const tx2 = await ecdsaRegistryContract.registerOperatorWithSignature(
        operatorSignatureWithSaltAndExpiry,
        wallet.address
    );
    await tx2.wait();
    console.log("Operator registered on AVS successfully");
};

// Listen for new task events on-chain
const monitorNewTasks = async () => {

    helloWorldServiceManager.on("NewTaskCreated", async (taskIndex: number, task: any) => {
        console.log(`New task detected: Hello, ${task.name}`);
        await signAndRespondToTask(taskIndex, task.taskCreatedBlock, task.name);
    });
    console.log("Monitoring for new tasks...");
};



// Generate Hello, Name message string
const signAndRespondToTask = async (taskIndex: number, taskCreatedBlock: number, taskName: string) => {
    const message = `Hello, ${taskName}`;
    const messageHash = ethers.solidityPackedKeccak256(["string"], [message]);
    const messageBytes = ethers.getBytes(messageHash);
    const signature = await wallet.signMessage(messageBytes);

    console.log(`Signing and responding to task ${taskIndex}`);

    const operators = [await wallet.getAddress()];
    const signatures = [signature];
    const signedTask = ethers.AbiCoder.defaultAbiCoder().encode(
        ["address[]", "bytes[]", "uint32"],
        [operators, signatures, ethers.toBigInt(await provider.getBlockNumber()-1)]
    );

    const tx = await helloWorldServiceManager.respondToTask(
        { name: taskName, taskCreatedBlock: taskCreatedBlock },
        taskIndex,
        signedTask
    );
    await tx.wait();
    console.log(`Responded to task.`);
};


```


### Off-chain Task Generator

**[createNewTasks.ts](https://github.com/Layr-Labs/hello-world-avs/blob/master/operator/createNewTasks.ts)**

The following Typescript code generates new tasks at a random interval. This entity that generates tasks for the AVS is also referred to as the "AVS Consumer".

```sol

// Create a New Task (a new name to be signed as "hello, name")
async function createNewTask(taskName: string) {
  try {
    // Send a transaction to the createNewTask function
    const tx = await helloWorldServiceManager.createNewTask(taskName);
    
    // Wait for the transaction to be mined
    const receipt = await tx.wait();
    
    console.log(`Transaction successful with hash: ${receipt.hash}`);
  } catch (error) {
    console.error('Error sending transaction:', error);
  }
}

```



## Local Deployment Test

Please follow the steps under [Local Devnet Deployment](https://github.com/Layr-Labs/hello-world-avs?tab=readme-ov-file#local-devnet-deployment) to deploy an instance of Hello World locally on your machine.



---

---
sidebar_position: 8
title: Get Support
---

If you have any questions or comments throughout the AVS development process, you can get support by reaching out to us using the Intercom button on the bottom right side of this page or <a href="javascript:void(0)"  id="intercom_trigger_eldocs" >clicking here</a>. We will promptly follow up with support!

---

---
sidebar_position: 1
title: Onboard to AVS Dashboard
---

The AVS Dashboard (also known as AVS Marketplace) lists registered AVSs. 

<img src="/img/avs-marketplace.png" width="75%" style={{ margin: '50px'}}>
</img>

:::important
While the Holesky network instability continues, AVS developers can use Sepolia for development and testing.

Initially, the AVS Marketplace will not be available on Sepolia. For more information, refer to the 
[EigenLayer blog](https://www.blog.eigenlayer.xyz/eigenlayer-update-holesky-network-instability-and-upcoming-sepolia-support/).
:::

## Adding a listing

To display an AVS on the [AVS Marketplace](https://app.eigenlayer.xyz/avs), invoke `updateAVSMetadataURI` on the [AllocationManager core contract](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md).

For information on the expected format and metadata requirements, refer to [Register AVS Metadata](../build/register-avs-metadata.md).

Once invoked, the data is indexed within about 20 minutes, and the metadata is displayed on the AVS Dashboard for Holesky.
[The EigenLayer Mainnet Dashboard Onboarding Form is required to display on the AVS Dashboard for mainnet](#mainnet-dashboard-onboarding). 

## Updating a listing 

If you deploy a new contract for your AVS, remove the previous listing by invoking `updateAVSMetadataURI` on the [AllocationManager core contract](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md)
value of null. For example, `updateAVSMetadataURI("")`.

The listing will be removed from the AVS Marketplace cache within one hour.

### getOperatorRestakedStrategies

To provide the list of Strategies that an Operator has restaked with a AVS, the [`getOperatorRestakedStrategies`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/testnet-sepolia/docs/core/RewardsCoordinator.md#createavsrewardssubmission) function must
be implemented. Implementing `getOperatorRestakedStrategies` enables the AVS to have its total restaked value displayed on the UI.
Given an operator, the function:
- Retrieve the Operator's quorum bitmap from the `RegistryCoordinator.sol` contract.
- Retrieve the addresses of the strategies for each quorum in the quorum bitmap

`getOperatorRestakedStrategies` makes no guarantee on whether the Operator has shares for a strategy in an Operator Set
or the uniqueness of each element in the returned array. The offchain service is responsible for that validation. 

```solidity
function getOperatorRestakedStrategies(address operator) external view returns (address[] memory) {
        bytes32 operatorId = registryCoordinator.getOperatorId(operator);
        uint192 operatorBitmap = registryCoordinator.getCurrentQuorumBitmap(operatorId);

        if (operatorBitmap == 0 || registryCoordinator.quorumCount() == 0) {
            return new address[](0);
        }

        // Get number of strategies for each quorum in operator bitmap
        bytes memory operatorRestakedQuorums = BitmapUtils.bitmapToBytesArray(operatorBitmap);
        uint256 strategyCount;
        for(uint256 i = 0; i < operatorRestakedQuorums.length; i++) {
            strategyCount += stakeRegistry.strategyParamsLength(uint8(operatorRestakedQuorums[i]));
        }

        // Get strategies for each quorum in operator bitmap
        address[] memory restakedStrategies = new address[](strategyCount);
        uint256 index = 0;
        for(uint256 i = 0; i < operatorRestakedQuorums.length; i++) {
            uint8 quorum = uint8(operatorRestakedQuorums[i]);
            uint256 strategyParamsLength = stakeRegistry.strategyParamsLength(quorum);
            for (uint256 j = 0; j < strategyParamsLength; j++) {
                restakedStrategies[index] = address(stakeRegistry.strategyParamsByIndex(quorum, j).strategy);
                index++;
            }
        }
        return restakedStrategies;        
    }
```
### getRestakeableStrategies

To list all supported restakeable Strategies for the AVS on the UI, the [`getRestakeableStrategies`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/testnet-sepolia/docs/core/RewardsCoordinator.md#createavsrewardssubmission) function must be implemented.

```solidity
function getRestakeableStrategies() external view returns (address[] memory) {
        uint256 quorumCount = registryCoordinator.quorumCount();

        if (quorumCount == 0) {
            return new address[](0);
        }
        
        uint256 strategyCount;
        for(uint256 i = 0; i < quorumCount; i++) {
            strategyCount += stakeRegistry.strategyParamsLength(uint8(i));
        }

        address[] memory restakedStrategies = new address[](strategyCount);
        uint256 index = 0;
        for(uint256 i = 0; i < _registryCoordinator.quorumCount(); i++) {
            uint256 strategyParamsLength = _stakeRegistry.strategyParamsLength(uint8(i));
            for (uint256 j = 0; j < strategyParamsLength; j++) {
                restakedStrategies[index] = address(_stakeRegistry.strategyParamsByIndex(uint8(i), j).strategy);
                index++;
            }
        }
        return restakedStrategies;
    }

```

For a reference implemetation, refer to [ServiceManagerBase.sol](https://github.com/Layr-Labs/eigenlayer-middleware/blob/mainnet/src/ServiceManagerBase.sol).

## Mainnet Dashboard onboarding
To complete the process of onboarding your AVS to mainnet AVS Marketplace Dashboard, submit the [EigenLayer Mainnet Dashboard Onboarding Form](https://forms.gle/8BJSntA3eYUnZZgs8).

---

---
sidebar_position: 4
title: Test AVS
---
:::note 
AVS Devnet is currently in Public Alpha and is rapidly being upgraded. Features may be added, removed or otherwise improved or modified,
and interfaces will have breaking changes. To report any issues, raise a [GitHub issue](https://github.com/Layr-Labs/avs-devnet/issues).
:::

Use AVS Devnet to test AVSs locally. AVS Devnet includes: 
* A CLI tool for easy configuration, deployment, and management of local devnets.
* Kurtosis integration to provide a standardized way to spin up local Ethereum environments with core EigenLayer contracts.
* Consensus and Execution clients to simulate production-like environments.
* Block Explorer integration for visualizing blockchain activity using a preconfigured [Blockscout explorer](https://github.com/blockscout/blockscout).
* Funded Operators with keys to enable creation of operator accounts with preloaded funds and private keys for testing staking, delegation, and other interactions.
* Tailored configurations for deployment, testing, and debugging.

To install and use, refer to the [avs-devnet README](https://github.com/Layr-Labs/avs-devnet).

---

---
sidebar_position: 3
title: AI Resources
---

import CopyButton from '@site/src/components/CopyToClipboard';


These text and markdown files contain documentation and code optimized for use with LLMs and AI tools.

<div style={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-start' }}>
<CopyButton
  title="llms.txt"
  filePath="../../llms.txt"
  description="Navigation index of all EigenLayer documentation pages."
/>

<CopyButton
  title="llms-full.txt"
  filePath="../../llms-full.txt"
  description="Complete EigenLayer documentation."
/>

<CopyButton
  title="avs-developer-docs.txt"
  filePath="../../avs-developer-docs.txt"
  description="AVS Developers documentation."
/>

<CopyButton
  title="operators-developer-docs.tx"
  filePath="../../operators-developer-docs.txt"
  description="Operators documentation."
/>

<CopyButton
  title="eigenlayer-contracts.md"
  filePath="../../eigenlayer-contracts.md"
  description="Complete EigenLayer contracts."
/>

<CopyButton
  title="hello-world-avs.md"
  filePath="../../hello-world-avs.md"
  description="Complete Hello World AVS."
/>

<CopyButton
  title="hello-world-avs.md"
  filePath="../../hello-world-avs.md"
  description="Complete Hello World AVS."
/>

<CopyButton
  title="eigenlayer-go-sdk.md.md"
  filePath="../../eigenlayer-go-sdk.md"
  description="EigenLayer Go SDK."
/>
</div>


---

---
sidebar_position: 4
title: AVS Developer Security Best Practices
---

## AVS Developer Security Best Practices


- Containers should be able to run with least privilege. Least privilege is AVS-dependent. AVS team should outline these 
privileges as part of the operator onboarding docs. If privileges are not specified, operators need to ask the AVS team directly.
- Emit runtime (logs) including security events
- Use Minimal Base Images
    - Use [ko Go containers](https://ko.build/) or similar to build distro-less minimal images. This reduces the attack surface significantly!
- Release updated images with security patches  (for base OS etc ).
- Do not store key material on the container (refer to key management docs).
- Your default user id should start with AVS-NAME-randomness to ensure there are no conflicts with the host.
- Ensure ECDSA keys utilized by AVS are solely for updates, such as modifying IP and port details within a smart contract. These keys should not hold funds. A role-based approach in smart contract design can address this issue effectively.
- AVS team should [sign their images](https://docs.docker.com/engine/security/trust/) for any releases, including upgrades
    - If they publish to Docker, Docker will show the verified badge next to the image.
    - Tag new releases via updated images.
- Establish communication channels (Discord, TG)  with operators. This ensures coordinating upgrades occurs with minimal friction.
- Operators should be in control of upgrades to their AVS software. Avoid software upgrade patterns where an agent checks for updated software and automatically upgrades the software. 
- Release Notes should explain new features including breaking changes / new hardware requirements etc.




# Key Security Considerations for Developers

When working with keys for nodes in an AVS, it is essential to consider the security aspects associated with key access and decryption. Keys should be encrypted either using a password or passphrase, understanding the unique security concerns posed by different access layers is crucial. By proactively addressing these concerns, you can enhance the overall security and integrity of the keys within your system:

- **Prompt for the passphrase and store it in memory:**
    
    In this scenario, the input must remain hidden to prevent the secret phrase from being stored in the terminal session or used buffer. Attackers might search for this secret in the buffer history. The key should not be stored locally or remotely unless encrypted via the AVS's proprietary methods.
    
- **Request the path to a file containing the passphrase:**
    
    Here, buffer vulnerability issues are absent unless the secret is printed or logged. However, an attacker with access to the machine running the AVS could potentially access this file.
    
- **Retrieve the key remotely:**
    
    Encrypting the validator key offers markedly improved protection when the decryption passphrase is stored remotely. Since the passphrase is not located within the validator client's storage, obtaining an unencrypted key from on-disk data becomes impossible. Instead, an attacker would need to execute considerably more advanced attacks, such as extracting the decrypted key from memory or impersonating the validator client process to receive the decryption key.
    
    Nonetheless, despite the increased difficulty, a sophisticated attack could still potentially acquire the validator key. Moreover, the user may inadvertently sign undesirable messages.
    
- **Utilize remote signers:**
    
    Employing remote signers involves delegating the signing process to an external service or device, which can offer additional security layers. The users are responsible for the availability and security of the remote signers, however, it is crucial to establish secure communication channels and verify the trustworthiness of the remote signer to prevent unauthorized access or tampering.

Supporting both local and remote signer methods is a good practice. 

[Web3signer](https://docs.web3signer.consensys.net/) is a remote signer that includes the following features:

- Open-source signing service developed under the Apache 2.0 license, developed by Consensys, and written in Java. 
- Capable of signing on multiple platforms using private keys stored in an external vault, or encrypted on a disk.
- Can sign payloads using secp256k1 and BLS12-381 signing keys (AWS HSM can't at the moment, spring 2023).
- Web3Signer uses REST APIs, and all the major Ethereum Consensus clients support it.

## Key Management Recommendation for Developers

The AVS can implement a feasible and sufficient method of loading the keys. This is asking for a path to a keystore folder. This keystore needs to follow some structure that AVS knows how to read. Currently [eigenlayer-cli](https://github.com/Layr-Labs/eigenlayer-cli) supports creation of encrypted ecdsa and bn254 keys in the [web3 secret storage](https://ethereum.org/en/developers/docs/data-structures-and-encoding/web3-secret-storage/) format. 


:::note

By keys, we refer to any kind of secret, either in plain text or encrypted.

:::

The path to this keystore folder can be provided via an environment variable or argument. 

---

---
sidebar_position: 1
title: EigenLayer SDKs
---

The EigenLayer SDKs wrap common EigenLayer AVS operations and are designed for AVS developers. 
* [EigenLayer Go SDK](https://github.com/Layr-Labs/eigensdk-go)
* [EigenLayer Rust SDK](https://github.com/Layr-Labs/eigensdk-rs)

---

---
sidebar_position: 2
title: Developer Resources
---

:::note

We are in the process of updating our samples, SDKs, and the EigenLayer CLI to include Rewards and Slashing capabilities. The samples, SDKs, and CLI will be
updated as soon as possible. Use the samples now to get familiar with EigenLayer.
For more information on Rewards and Slashing, refer to the [Rewards](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-001.md) and [Slashing](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md) ELIPs,
and [Rewards](../../eigenlayer/concepts/rewards/rewards-concept.md) and [Slashing](../Concepts/slashing/slashing-concept-developers) documentation.
For questions or support, reach out to us using the Intercom button on the bottom right side of this page or <a href="javascript:void(0)"  id="intercom_trigger_eldocs" >here</a>.
We will promptly follow up with support!

:::

### Developer Samples
* [Awesome AVS](https://github.com/Layr-Labs/awesome-avs)
* [Hello World AVS](https://github.com/Layr-Labs/hello-world-avs)
* [Incredible Squaring AVS](https://github.com/Layr-Labs/incredible-squaring-avs)
* [devQuickstart](https://github.com/Layr-Labs/devQuickstart)

### SDKs
These SDKs are wrappers on top of common EigenLayer AVS operations designed to save you time as an AVS builder:
* [EigenLayer Go SDK](https://github.com/Layr-Labs/eigensdk-go)
* [EigenLayer Rust SDK](https://github.com/Layr-Labs/eigensdk-rs)

### EigenLayer Core Repos
* [EigenLayer Contracts](https://github.com/Layr-Labs/eigenlayer-contracts)
* [EigenLayer Middleware](https://github.com/Layr-Labs/eigenlayer-middleware)
* [EigenLayer CLI](https://github.com/Layr-Labs/eigenlayer-cli)
* [EigenDA](https://github.com/Layr-Labs/eigenda)

### Developer Tooling
- [Othentic](https://www.othentic.xyz) - Library of components for AVS builders.
- [Layer](https://www.layer.xyz/) - Containerized Autonomous Verifiable Services (CAVS) via Web Assembly.
- [AltLayer Wizard](https://wizard.altlayer.io/) - AVS-as-a-Service platform.
- [Gadget](https://github.com/webb-tools/gadget) - A framework for building modular AVS and Tangle Blueprints.

---

---
sidebar_position: 1
title: Onboard to AVS Dashboard
---

:::important
This topic describes how to onboard to the AVS Marketplace prior to the Slashing release. If you are looking for the
latest documentation, refer to [Onboard to AVS Marketplace](../HowTo/publish/onboard-avs-dashboard.md).
:::

This document defines interfaces that AVSs must implement for us to be able to index their data for the V1 [AVS Marketplace](https://app.eigenlayer.xyz/avs).

New AVS Listings: in order for an AVS to have its name, information, and logo indexed, it must invoke `updateAVSMetadataURI()` on the [AVSDirectory contract](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/src/contracts/core/AVSDirectory.sol).
It currently takes about 10 minutes for it to be indexed and the metadata to be updated on the dashboard.

Updating AVS Listings:  if you deploy a new contract for a new version of your AVS, please be sure to remove the previous listing. Invoke the update metadata function with value of null, such as `updateAVSMetadataURI("")` to remove the previous listing. Your listing will then be removed from the application cache within one hour.

## Interface

```javascript
interface IServiceManager {
// Below 3 functions are just proxies to the same-named functions in the AVSDirectory
function registerOperatorToAVS(address operator, Signature memory signature);

function deregisterOperatorFromAVS(address operator);

function updateAVSMetadataURI(string calldata metadataURI);
	
// Below 2 functions are needed for your AVS to appear correctly on the UI
function getOperatorRestakedStrategies(address operator) returns (address[] memory)

function getRestakeableStrategies() returns (address[] memory);
}
```

### registerOperatorToAVS and deregisterOperatorFromAVS
In order to have its list of operators displayed on the UI, an AVS MUST handle operator registration/deregistration by calling `registerOperatorToAVS()` and `deregisterOperatorFromAVS()` on EigenLayer’s AVSDirectory.  Primarily, these functions serve to forward calls to the `AVSDirectory.sol` contract to confirm an operator's registration with the AVS.
```solidity
function registerOperatorToAVS(
        address operator,
        ISignatureUtils.SignatureWithSaltAndExpiry memory operatorSignature
    ) public virtual onlyRegistryCoordinator {
        avsDirectory.registerOperatorToAVS(operator, operatorSignature);
    }

function deregisterOperatorFromAVS(address operator) public virtual onlyRegistryCoordinator {
        avsDirectory.deregisterOperatorFromAVS(operator);
    }
```

### getOperatorRestakedStrategies
This function must be implemented in order to provide the list of strategies that an operator has restaked with the AVS. This allows the AVS to have its total restaked value displayed on the UI.  Given an operator, this function should:
- Retrieve the operator's quorum bitmap from the `RegistryCoordinator.sol` contract.
- Retrieve the addresses of the strategies for each quorum in the quorum bitmap

Note that there is no guarantee is made on whether the operator has shares for a strategy in a quorum or uniqueness of each element in the returned array. The off-chain service should do that validation separately

```solidity
function getOperatorRestakedStrategies(address operator) external view returns (address[] memory) {
        bytes32 operatorId = registryCoordinator.getOperatorId(operator);
        uint192 operatorBitmap = registryCoordinator.getCurrentQuorumBitmap(operatorId);

        if (operatorBitmap == 0 || registryCoordinator.quorumCount() == 0) {
            return new address[](0);
        }

        // Get number of strategies for each quorum in operator bitmap
        bytes memory operatorRestakedQuorums = BitmapUtils.bitmapToBytesArray(operatorBitmap);
        uint256 strategyCount;
        for(uint256 i = 0; i < operatorRestakedQuorums.length; i++) {
            strategyCount += stakeRegistry.strategyParamsLength(uint8(operatorRestakedQuorums[i]));
        }

        // Get strategies for each quorum in operator bitmap
        address[] memory restakedStrategies = new address[](strategyCount);
        uint256 index = 0;
        for(uint256 i = 0; i < operatorRestakedQuorums.length; i++) {
            uint8 quorum = uint8(operatorRestakedQuorums[i]);
            uint256 strategyParamsLength = stakeRegistry.strategyParamsLength(quorum);
            for (uint256 j = 0; j < strategyParamsLength; j++) {
                restakedStrategies[index] = address(stakeRegistry.strategyParamsByIndex(quorum, j).strategy);
                index++;
            }
        }
        return restakedStrategies;        
    }
```
### getRestakeableStrategies
This function must be implemented in order to have all possible restakeable strategies for that AVS displayed on the UI correctly.  These are the strategies that the AVS supports for restaking.  

```solidity
function getRestakeableStrategies() external view returns (address[] memory) {
        uint256 quorumCount = registryCoordinator.quorumCount();

        if (quorumCount == 0) {
            return new address[](0);
        }
        
        uint256 strategyCount;
        for(uint256 i = 0; i < quorumCount; i++) {
            strategyCount += stakeRegistry.strategyParamsLength(uint8(i));
        }

        address[] memory restakedStrategies = new address[](strategyCount);
        uint256 index = 0;
        for(uint256 i = 0; i < _registryCoordinator.quorumCount(); i++) {
            uint256 strategyParamsLength = _stakeRegistry.strategyParamsLength(uint8(i));
            for (uint256 j = 0; j < strategyParamsLength; j++) {
                restakedStrategies[index] = address(_stakeRegistry.strategyParamsByIndex(uint8(i), j).strategy);
                index++;
            }
        }
        return restakedStrategies;
    }

```


Refer to [ServiceManagerBase.sol](https://github.com/Layr-Labs/eigenlayer-middleware/blob/mainnet/src/ServiceManagerBase.sol) for a reference implementation of the interface.

Proxy and Implementation addresses for AVSDirectory contract are available at EigenLayer Contracts -> [Deployments](https://github.com/Layr-Labs/eigenlayer-contracts/?tab=readme-ov-file#deployments).

To look at EigenDA's AVS-specific deployment -> [Deployments](https://github.com/Layr-Labs/eigenlayer-middleware/tree/dev?tab=readme-ov-file#deployments)

## MetadataURI Format

The metadataURI should follow the format outlined in this [example](https://holesky-operator-metadata.s3.amazonaws.com/avs_1.json). The logo MUST be in PNG format. 

```json
{
    "name": "EigenLabs AVS 1",
    "website": "https://www.eigenlayer.xyz/",
    "description": "This is my 1st AVS",
    "logo": "https://raw.githubusercontent.com/layr-labs/eigendata/master/avs/eigenlabs/logo.png",
    "twitter": "https://twitter.com/eigenlayer"
}
```

Note that for proper rendering of your logo on the UI, the logo _must_ be hosted on GitHub and its reference must point to the raw file as the example above shows. If you need a repo for your logo to be hosted publicly, you can make a PR to the `eigendata` repo and have your logo added: https://github.com/Layr-Labs/eigendata.

## Holesky Dashboard onboarding
Once you've gone through the above steps and you've called the `updateAVSMetadataURI` function, your AVS will be reflected on the Holesky dashboard in about 10 minutes.

## Mainnet Dashboard onboarding
To complete the process of onboarding your AVS on to the mainnet marketplace dashboard, please submit this form: [EigenLayer Mainnet Dashboard Onboarding Form](https://forms.gle/8BJSntA3eYUnZZgs8).



---

---
sidebar_position: 4
title: Keys and Signatures
--- 

In the EigenLayer ecosystem, signatures play a crucial role in ensuring the integrity and authenticity of operations. 
Signatures cryptographically confirm that a specific address has signed a given message (for example, a string value)
with its private key. 

:::warning
Poor key management can lead to compromized operators, network disruptions, or financial losses. Key Management Best 
Practices are outlined for [Institutional Operators](../../operators/howto/managekeys/institutional-operators.md) and
[Solo Stakers](../../operators/howto/managekeys/solo-operators.md).
:::

## Operator Keys

An Operator has two types of keys:
* A single Operator key used to authenticate to the EigenLayer core contracts.
* Multiple AVS keys used to sign messages for AVSs.

:::warning
As security best practice, Operators should:
* Not reuse their Operator key as an AVS signing key.
* Not reuse their Ethereum key for EigenLayer operations if they are also Ethereum stakers.
* Use a different key for every AVS.
:::

The Operator key must be an ECDSA key and is used for actions including registering to EigenLayer, changing Operator parameters,
and force undelagating a staker. 

Always interact with with the EigenLayer core contracts using the [eigenlayer-cli](https://github.com/Layr-Labs/eigenlayer-cli) or other operator-built tools. 

Do not load a Operator key into any AVS software. If authorizing any action programmatically triggered on the AVS contracts 
use an AVS key, not the Operator key.

For information on key management best practices, refer to [Key Management Best Practices for Node Operators](../../operators/howto/managekeys/institutional-operators.md).

## AVS Signing Keys

AVS keys are used by AVS software run by Operators to sign messages for AVSs. The required AVS key type is specified by the AVS, and is most
commonly BN254. 

## BLS and ECDSA Signature Types

The primary signatures types used in EigenLayer are BLS12-381 (Boneh-Lynn-Shacham), BN254 (Barreto-Naehrig), and ECDSA (Elliptic Curve Digital Signature Algorithm).

| Feature                   | BLS12-381                                                              | BN254                                                                 | ECDSA                                                                 |
|:--------------------------|:-----------------------------------------------------------------------|:----------------------------------------------------------------------|:----------------------------------------------------------------------|
| **Signature Size**        | 48 bytes (BLS12-381 curve)                                             | 32 bytes (BN254 curve)                                                | ~64 bytes (secp256k1)                                                 |
| **Key Size**              | 32 bytes                                                               | 32 bytes                                                              | 32 bytes                                                              |
| **Signature Aggregation** | Supports native aggregation.  Single operation for multiple signatures | Supports native aggregation. Single operation for multiple signatures | Not natively aggregatable. Each signature must be verified separately |
| **Gas Cost in Ethereum**  | Higher for single signatures, lower for aggregated                     | Lower than BLS12-381                                                  | Lower initially but increases with more signatures                    |

Until the Pectra upgrade, BN254 remains the cheaper option. After the upgrade, the cost of verifying the more secure BLS12-381
signature will decrease, making migration to this cheaper and more secure signature type viable for developers.

The native aggregation offered by BLS, combining multiple operator signatures into one, reduces onchain storage needs, 
verification time, and gas costs. BLS signatures require a slightly more complex implementation that includes an aggregator entity.
Given the reduction in storage, verification time, and gas costs, we recommend the of BLS signatures for production systems.

**Note:** As of [eigenlayer-middleware v0.2.1](https://github.com/Layr-Labs/eigenlayer-middleware/releases/tag/v0.2.1-mainnet-rewards), the [ECDSAServiceManagerBase contract](https://github.com/Layr-Labs/eigenlayer-middleware/blob/v0.2.1-mainnet-rewards/src/unaudited/ECDSAServiceManagerBase.sol) was not yet fully audited. Please check the most recent release as this is expected to change.

---

---
sidebar_position: 4
title: Allocation and Deallocation
---

## Allocations

Allocations are made by magnitude and can only be made:
* To valid [Operator Sets](operator-sets-concept).
* From non-slashable [magnitude](strategies-and-magnitudes).

Allocations are not made until the Operator [`ALLOCATION_DELAY`](../../reference/safety-delays-reference.md) has passed (that is, the allocation is not pending). Allocations
cannot be made from an of:
* Existing queued allocations
* Magnitude already allocated to an Operator Set
* Pending deallocations.

## Deallocations

Deallocations are similar to allocations and are not made until the Operator [`DEALLOCATION_DELAY`](../../reference/safety-delays-reference.md) has passed (that is, the 
deallocation is not pending). After the delay, the stake is non-slashable. The delay:
* Enables AVSs to update their view of [Unique Stake](../slashing/unique-stake.md) to reflect the Operator’s reduced allocation.
* Guarantees appropriate delays for tasks to remain slashable.

Queued deallocations cannot be canceled. Deallocations happen immediately (that is, the `DELLOCATION_DELAY` does not apply) 
if the Operator is not registered to the AVS, or the strategy being deallocated is not part of the Operator Set.

If an Operator deregisters, the Operator remains slashable for the `DEALLOCATION_DELAY` period following the deregistration. 
After the deregistration, the allocations to that Operator Set still exist, and if the Operator re-registers, those Operator 
Set allocations immediately become slashable again. That is, a deregistration does not queue a deallocation.

Each Operator/ Strategy pair can have only one pending allocation or deallocation transaction per Operator Set at a time. 
A single transaction can modify multiple allocations.


---

---
sidebar_position: 1
title: Operator Sets Overview
---

:::note

[ELIP-002 Slashing via Unique Stake & Operator Sets](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md) introduced Operator Sets.


Currently, Operators register to an AVS to earn rewards in the AVSDirectory. We recommend existing AVSs [migrate to Operator Sets on testnet](../../../developers/HowTo/build/slashing/migrate-to-operatorsets.md). 
:::

Operator Sets determine which Operators secure an AVS and earn rewards. Each AVS defines one or more Operator Sets that
Operators may opt into. The opted in Operators are the set of Operators that are responsible for securing that service.
By opting into the Operator Set for an AVS, Operators gain access to the AVS rewards, and the AVS slashing risks.

AVSs group Operators into Operator Sets based on unique business logic, hardware profiles, liveness guarantees, or composition 
of stake. Operators use Operator Sets to allocate and deallocate [Unique Stake](../slashing/unique-stake.md). AVSs use Operator Sets to assign tasks to Operator 
Sets to perform the service provided by the AVS.

Operators are responsible for ensuring that they fully understand the slashing conditions and slashing risks of AVSs before 
opting into an Operator Set and allocating  stake to the Operator Set, as once allocated, those funds may be slashable 
according to any conditions set by that AVS. 

## For AVS Developers

For information on designing Operator Sets, refer to [Design Operator Sets](../../../developers/HowTo/build/slashing/design-operator-set.md).

## For Operators

For information on allocating to Operator Sets, refer to [Allocate and Register to Operator Set](../../../operators/howto/operator-sets.md).


---

---
sidebar_position: 4
title: Strategies and Magnitudes
---

:::note

[ELIP-002 Slashing via Unique Stake & Operator Sets](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md) introduced Operator Sets.

:::

Magnitudes are the accounting tool used to track Operator allocations to [Operator Sets](operator-sets-concept). Magnitudes represent proportions 
of an Operator’s delegations for a specific Strategy.

Strategies are the accounting tool used to track Stakers deposited assets. Strategies are expressions of security on EigenLayer. 
For example, a strategy may represent a specific token.

For each Strategy:
* An Operator starts with a protocol-defined Total Magnitude of 1x10^18 (`INITIAL_TOTAL_MAGNITUDE`).
* The sum of all of an Operator’s Magnitudes cannot exceed the `INITIAL_TOTAL_MAGNITUDE`.
* The protocol consistently decreases the Strategy’s total magnitude for the slashed Operator to account for slashing events originated by an AVS.

The proportion of an Operator’s delegation assigned as Unique Stake to an Operator Set is equal to the magnitude allocated 
to that Operator Set divided by the Operator’s Total Magnitude. The sum of all magnitude allocations never being greater 
than the Total Magnitude ensures the property of Unique Stake. That is, ensures that no two Operator Sets can slash the same stake.

## Example

The table displays an example of an Operator Magnitude allocation for the EIGEN Strategy. The table represents slashable 
and non-slashable stake by Operator Set.

For legibility, the example uses a total magnitude of 10,000 instead of 1x1018.

|  | Magnitude | Proportion | EIGEN |
| :---- | :---- | :---- | :---- |
| `AVS_1_EIGEN` | 3,000 | 30% | 30 |
| `AVS_2_EIGEN` | 2,500 | 25% | 25 |
| `EigenDA_EIGEN` | 2,000 | 20% | 20 |
| `Non-slashable` | 2,500 | 25% | 25 |
| `Total` | 10,000 | 100% | 100 |

The Operator deallocates 10 EIGEN to AVS_1_EIGEN. The following is the result and the non-slashable stake increases. 

|  | Magnitude | Proportion | EIGEN |
| :---- | :---- | :---- | :---- |
| `AVS_1_EIGEN` | 2,000 | 20% | 20 |
| `AVS_2_EIGEN` | 2,500 | 25% | 25 |
| `EigenDA_EIGEN` | 2,000 | 20% | 20 |
| `Non-slashable` | 3,500 | 35% | 35 |
| `Total`  | 10,000 | 100% | 100 |

A Staker who has delegated to the Operator deposits 100 EIGEN. The following is the results and Magnitudes and proportions 
stay the same and the EIGEN for each Operator Set increases. 

|  | Magnitude | Proportion | EIGEN |
| :---- | :---- | :---- | :---- |
| `AVS_1_EIGEN` | 2,000 | 20% | 40 |
| `AVS_2_EIGEN` | 2,500 | 25% | 50 |
| `EigenDA_EIGEN` | 2,000 | 20% | 40 |
| `Non-slashable` | 3,500 | 35% | 70 |
| `Total`  | 10,000 | 100% | 200 |


---

---
sidebar_position: 2
title: Earners, Claimers, and Reward Recipients
---

Earners are addresses that accrue Rewards within the EigenLayer ecosystem and are Stakers, Operators, or in the case of refunds,
AVS addresses. Earners accrue rewards but claiming rewards is a separate step and can be assigned to a Claimer.

Claimers are addresses that are authorized to claim rewards on behalf of Earners. By default, an Earner is their own Claimer. 
Earners can assign a Claimer address to manage Rewards claims on their behalf. If an Earner sets a Claimer, the new Claimer 
gains the ability to claim all unclaimed past Rewards. Claimers can set a reward recipient address to receive the rewards. If 
using the EigenLayer CLI or app, the default reward recipient is the Earner.

In summary:

* Earners accrue rewards but do not necessarily claim them.
* Claimers claim rewards but do not necessarily receive them.
* Reward recipients receive the rewards (that is, the final destination for ERC20 token distributions).

---

---
sidebar_position: 4
title: Programmatic Incentives Split
---

[Programmatic Incentives](https://docs.eigenfoundation.org/programmatic-incentives/programmatic-incentives-faq) are EIGEN tokens minted by the EigenLayer protocol to Stakers and Operators.
Programmatic Incentives are claimed, and Operators can set a variable split of Programmatic Incentives, in the same way as Rewards.

To receive Programmatic Incentives:

* Operators must be opted into at least one Operator Set for at least one AVS.
* Stakers must be delegated to an Operator that is opted into at least one Operator Set for at least one AVS.

By default, Operators earn a 10% split on Programmatic Incentives. The rest of the Programmatic Incentives are claimable 
by the Operator’s delegated Stakers. Programmatic Incentive distributions are proportional to delegated stake.

For information on how to change the default Programmatic Incentives split, refer to [Set Programmatic Incentives Split](../../../operators/howto/confirgurerewards/set-pi-split).


---

---
sidebar_position: 7
title: Rewards Claiming FAQ
---



### When can I claim my rewards?

After a root is posted, rewards are claimable after an activation delay. On mainnet this delay is 1 week and on testnet it is 2 hours.

### What portion of rewards goes to my operator?

Operators get a fixed 10% portion rewards, though this is subject to change in a future release to be variable.

### How can I test reward distributions and claiming on testnet?

#### 1. Programmatic incentives.
To accumulate programmatic incentives, you must be delegated to an operator that is registered to at least one AVS of any type. Programmatic incentives are payed in Testnet EIGEN. Assets that earn programmatic incentives are limited to: EIGEN, LsETH, ETHx, rETH, osETH, cbETH, ankrETH, stETH, WETH, sfrxETH, mETH.

#### 2. Rewards from AVSs
To accumulate testnet rewards from AVSs, you must be delegated to an Operator that is registered to at least one AVS with active rewards.

**Faucet AVS:**
FaucetAVS is designed purely to distribute WETH to staked WETH with no requirements beyond operator registration.

**EigenDA:**
EigenDA distributes rewards to [operators actively participating in EigenDA](https://docs.eigenda.xyz/operator-guides/requirements/). Operators may be ejected if they fail to sign batches or fall below the threshold requirements. Rewards are earned for:
- EIGEN Quorum participation
- ETH Quorum participation including LsETH, ETHx, rETH, osETH, cbETH, ankrETH, stETH, WETH, sfrxETH, mETH and Beacon Chain ETH in EigenPods.


### Are reward distributions based on the amount of work performed by an operator, the Operator's total delegated stake or both?

The current rewards calculation assumes that work done is directly proportional to stake; therefore, rewards are distributed proportional to stake. If an operator does not perform the tasks expected of it, the AVS should eject or "churn" the operator (which we have examples for in our middleware contracts).

### Will the AVS Rewards be distributed using the same ERC20 token used to Stake / Operate (opt-in to) the AVS?

An AVS can distribute any ERC-20 token it chooses in a [RewardSubmission](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#createavsrewardssubmission). These reward token(s) can be different from the list of Strategies (assets) that were originally staked, delegated and opted into by the Restaker, Operator, and AVS.

For example, Restakers could delegate stETH (lido eth) to an Operator. The Operator could opt in to an AVS with the stETH strategy. Then a week later the AVS could pay rewards in USDC. The decision of which ERC20 token to reward to a Strategy is entirely up to the AVS to determine.

### How is the APR calculated?

The UI shows up to a 7-day averaged APR for a given strategy. Due to the 2 day calculation delay, neither APR nor accrual of rewards can be observed until 2 days after a user has restaked and delegated qualifying assets to an Operator that is earning rewards. The APR is given by the following equation:

$$
\frac{E_{\text{earned}, s}}{\sum_{7 \ \text{days}}E_{\text staked, s}}*365\ \text{days}
$$

That is, $$ E_{\text{earned}, s} $$ is the ETH value of all reward tokens earned over the past 7 days from restaking strategy $$ s $$. 
$$ E_{\text staked, s} $$ is the ETH value of tokens staked in restaked strategy $$ s $$ on a given day, excluding any days in which no reward is earned.

ETH values are calculated using the latest price feeds sourced from Coingecko. Reward tokens that do not have a public price available from Coingecko are not included in the calculation. APR is not calculated for staked tokens that do not have a public price available from Coingecko.


---

---
sidebar_position: 3
title: Rewards Claiming
---

The process to claim rewards is the same for AVS Rewards and Programmatic Incentives. That is, both AVS Rewards and Programmatic
Incentives are displayed as claimable rewards in the EigenLayer app and by the EigenLayer CLI.

The posted distribution roots contain cumulative earnings. That is, Stakers and Operators do not have to claim against every
root and claiming against the most recent root will claim anything not yet claimed.

For information on configuring and claiming rewards, refer to:
* [Set Rewards Claimer](../../../operators/howto/confirgurerewards/set-rewards-claimer.md) 
* [Set Rewards Split](../../../operators/howto/confirgurerewards/set-rewards-split.md)
* [Set PI Split](../../../operators/howto/confirgurerewards/set-pi-split.md)
* [Claim Rewards using the CLI](../../../operators/howto/claimrewards/claim-rewards-cli.mdx)
* [Claim Rewards using the App](../../../restakers/restaking-guides/claim-rewards-app.md)
* [Batch Claim Rewards](../../../operators/howto/claimrewards/batch-claim-rewards.md)


---

---
sidebar_position: 1
title: Overview
---

Rewards are tokens distributed to Stakers and Operators by an AVS to reward Stakers and Operators for participation in securing AVSs.
Rewards implements the [EigenLayer Improvement Proposal-001: Rewards v2](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-001.md).

EigenLayer has a flexible rewards mechanism that enables:

* [Operator directed Rewards](rewards-submission.md)

    AVSs can [direct performance-based rewards](../../../developers/HowTo/build/submit-rewards-submissions.md) to specific Operators using custom logic. Operator directed Rewards enable 
    rewards to be distributed based on work completion, quality or other parameters determined by the AVS, allowing flexible and tailored incentives.

* [Variable Operator Fee Splits for AVS Rewards](rewards-split.md)

    Operators can [set their per-AVS fee rate](../../../operators/howto/confirgurerewards/set-rewards-split.md) on AVS Rewards to any amount from 0% to 100%. The default split is 10%. Setting
    a variable split per-AVS enables Operators to align their fee structures with their economic needs and the complexity and diversity of AVS demands. 
    Operator fees can be varied by Operator Set for more granular reward fee structures.

* [Variable Operator Splits for Programmatic Incentives](rewards-split.md)

    Operators can [set their split of Programmatic Incentives](../../../operators/howto/confirgurerewards/set-pi-split) to any amount from 0% to 100%. The default split is 10%. Setting 
    a split enables Operators to have flexibility in determining the appropriate take rate. The Programmatic Incentive splits 
    integrate with the Rewards distribution process which ensures that Stakers delegating to Operators benefit proportionately.

Rewards are submitted, calculated, and distributed as follows:

1. [AVSs submit rewards submissions to Operators and Stakers](../../../developers/HowTo/build/submit-rewards-submissions.md).
2. The Rewards updater calculates Rewards offchain and consolidates these into a merkle root posted onchain.
3. [Operators and Stakers claim their allocated Rewards](rewards-claiming).

## Rewards Calculation 

Rewards are calculated via an offchain process. A Merkle root (known as the distribution root) is posted which represents
the cumulative rewards across all earners weekly on mainnet and daily on testnet. There is an additional 2 hour delay on
testnet and 1 week delay on mainnet after posting for the root to be claimable against with a valid Merkle proof. For more
information on the deterministic calculation of the distribution of rewards, refer to the [Rewards Calculation technical documentation](https://github.com/Layr-Labs/sidecar/blob/master/docs/docs/sidecar/rewards/calculation.md).

The posted distribution roots contain cumulative earnings. That is, Stakers and Operators do not have to claim against every
root and claiming against the most recent root claims anything not yet claimed.


---

---
sidebar_position: 3
title: Rewards Split
---

Operators earn rewards by opting into the Operator Sets of AVSs that implement Rewards. By default, Operators earn a 10% split
on Rewards. The rest of the reward is claimable by the Operator’s delegated Stakers. Rewards are proportional to:

* The amount of stake.
* The AVS's relative weighting of strategies in a rewards submission.
* The number of days during the eligible timeframe of the reward submission that the Staker was delegated to the Operator.

For information on how to change the default rewards split, refer to [Set Rewards Split](../../../operators/howto/confirgurerewards/set-rewards-split.md).

---

---
sidebar_position: 5
title: Rewards Submission
---

AVSs make rewards submissions specifying:

* Operator Set for which the rewards are being submitted.
* Time range for which the reward is distributed.
* List of weights for each Strategy for the reward.
* ERC20 token in which to make rewards.

For information on how to create a rewards submission, refer to [Submit Rewards Submission](../../../developers/HowTo/build/submit-rewards-submissions.md).


---

---
sidebar_position: 4
title: Safety Delays
---

:::important
When the Slashing and Operator Set upgrade is live on mainnet, stake can become slashable for a Staker that has previously 
delegated stake to an Operator. Stakers are responsible for ensuring that they fully understand and confirm their risk tolerances 
for existing and future delegations to Operators and the Operator’s slashable allocations. Additionally, stakers are responsible 
for continuing to monitor the allocations of their chosen Operators as they update allocations across various Operator Sets.
:::

Safety delays are applied when allocating or deallocating to prevent rapid stake movements. Safety delays:
* Ensure stability. Delays ensure gradual transitions when stake is being allocated or dellocated enabling AVSs to adjust to changes in Operator security.
* Reduce risks from slashing. Delays ensure that staked assets remain at risk for a period after deallocation preventing the withdrawal of stake immediately before a slashing event to avoid slashing penalties.
* Preventing stake cycling to collect rewards. Delays ensure commitment periods to securing an AVS.

For more information on provided safety delays, refer to the [Safety Delays reference](../../reference/safety-delays-reference).


---

---
sidebar_position: 4
title: Slashable Stake Risks
---

:::important
With Slashing, stake can become slashable for a Staker that has previously 
delegated stake to an Operator. Stakers are responsible for ensuring that they fully understand and confirm their risk tolerances 
for existing and future delegations to Operators and the Operator’s slashable allocations. Additionally, stakers are responsible 
for continuing to monitor the allocations of their chosen Operators as they update allocations across various Operator Sets.
:::

AVSs can create [Operator Sets](../operator-sets/operator-sets-concept) that may include slashable 
[Unique Stake](unique-stake.md), and Operators can allocate their delegated stake to Operator Sets. If a Staker has previously delegated stake 
to an Operator, the delegated stake becomes slashable when the Operator opts into an Operator Set and allocates Unique Stake.

Stakers are responsible for understanding the increased risk posed by allocation of their delegated stake as slashable 
Unique Stake to an AVS. While the allocation of delegated stake to an Operator Set may be subject to the [Allocation Config 
Delay and Allocation Delay](../../reference/safety-delays-reference.md), it is important to understand the increased risk.

For more information on the safety delays for Stakers, refer to the :
* [Safety Delays reference](../../reference/safety-delays-reference.md)
* [Allocating and Deallocating to Operator Sets section of ELIP-002](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md#unique-stake-allocation--deallocation).


---

---
sidebar_position: 1
title: Slashing Overview
---

:::note

Slashing implements [ELIP-002: Slashing via Unique Stake & Operator Sets](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md).

:::

Slashing is a type of penalty determined by an AVS as a deterrent for broken commitments by Operators. Broken commitments
may include improperly or inaccurately completing tasks assigned in [Operator Sets](../operator-sets/operator-sets-concept) by an AVS. 
Slashing results in a burning/loss of funds. AVSs can only slash an Operator’s [Unique Stake](unique-stake.md) allocated to a single Operator Set.

An AVS may slash an Operator up to the total allocated amount of Unique Stake per [Strategy](../operator-sets/strategies-and-magnitudes) under the following conditions:
* The Operator is registered to the Operator Set the AVS wishes to slash.
* The Operator Set is configured to include the allocated strategy.
* All applicable safety and time delays have passed.

:::important
The EigenLayer protocol provides a slashing function that is maximally flexible. That is, AVSs may slash any Operator that
has delegated stake to that AVS within any of their Operator Sets. AVSs have flexibility to design their protocols to slash
for any reason. Slashing does not have to be objectively attributable (that is, provable onchain), but AVSs are encouraged to
create robust legibility and process around how their slashing is designed and individual slashing events. Operators are responsible
for ensuring that they fully understand the slashing conditions and slashing risks of AVSs before delegating stake to them, as once
delegated, those funds may be slashable according to the conditions set by that AVS.
:::

## Slashing sequence

The interactions between Staker, Operator, AVS, and core contracts during a slashing are represented in the sequence diagram.

![Sequence Representation of a Slashing](/img/operator-guides/operator-sets-figure-5.png)

## Burning slashed funds

When funds are slashed by an AVS, the EigenLayer core contracts make slashed funds permanently inaccessible (burned).
ERC-20s have this done by sending them to the dead 0x00...00e16e4 address. The dead address is used to ensure proper
accounting with various LRT protocols.

Natively Restaked ETH will be locked in EigenPod contracts, permanently inaccessible. The Ethereum Pectra upgrade is anticipated
to unblock development of an EigenLayer upgrade which would burn Natively Restaked ETH by sending it to a dead address, instead
of permanently locking it within EigenPod contracts as planned in this release.

## For AVS Developers 

For information on:
* AVS security models and slashing, refer to [AVS Security Models](../../../developers/Concepts/avs-security-models.md). 
* Design considerations for slashing, refer to [Design Operator Sets](../../../developers/HowTo/build/slashing/design-operator-set.md) and [Design Slashing Conditions](../../../developers/HowTo/build/slashing/slashing-veto-committee-design.md).
* Implementing slashing, refer to [Implement Slashing](../../../developers/HowTo/build/slashing/implement-slashing.md).

## For Operators

For information on allocating to Operator Sets, refer to [Allocate and Register to Operator Set](../../../operators/howto/operator-sets.md). 

---

---
sidebar_position: 3
title: Unique Stake
---

:::note

[ELIP-002 Slashing via Unique Stake & Operator Sets](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md) introduced Operator Sets and Slashing.

:::

Unique Stake ensures AVSs and Operators maintain key safety properties when handling staked security and slashing on EigenLayer. 
Unique Stake is allocated to different [Operator Sets](../operator-sets/operator-sets-concept) on an opt-in basis by Operators. Only Unique Stake is slashable by AVSs, 
and the Unique Stake represents proportions of the Operator’s delegated stake from Stakers. Unique Stake allocations are 
exclusive to one Operator Set and solely slashable by the AVS that created that Operator Set.

Benefits of Unique Stake to Operators and AVSs include:
* Greater control over slashing risk. The risk of slashing is isolated to the individual AVS and Operator Set, and Operators 
control how much of their stake any AVS can slash. AVSs are not exposed to risk from other AVSs or their slashings.
* Guaranteed slashable stake. AVSs can understand the amount of Unique Stake that can be slashed at a given time across their Operator Sets.
* Permissionless onboarding of AVSs. There is no need for a common veto committee because slashing is localized to individual AVSs. 
No need for a common veto committee means launching an AVS on EigenLayer is permissionless.

## Example 1

Operator 1 has a delegation of 100 staked ETH. Operator 1 allocates proportions of that ETH as Unique Stake in Operator Sets 
across several AVSs. The 85 allocated ETH is slashable exclusively by the AVS for each Operator Set. That is, AVS 2, 3, and 4 
can slash their associated Operator Sets 3, 4, 5, and 6 respectively.

<img src="/img/operator-guides/operator-sets-figure-3.png" width="75%" style={{ margin: '50px'}}>
</img>

## Example 2

AVS 1 has two Operator Sets for different tasks. AVS 1 uses Operator Set 1 for assigning generation of ZK proofs to Operators, 
an expensive computation, and Operator Set 2 for verification of those proofs, a cheaper computation.

Operator 1 is registered to Operator Set 1 but has not allocated any Unique Stake. Operator 2 has allocated 10% of its ETH
delegation to Operator Set 1 (10 ETH). The 10% allocation by Operator 2  is exclusively slashable by AVS 1 in Operator Set 1. 
Operator 2 has also allocated 5% (5 ETH) to Operator Set 2, which is exclusively slashable by AVS 1 in Operator Set 2.

Including the 20% allocation from Operate 3 (20 ETH), Operator Set 1 has a total Unique Stake of 30 ETH available to slash. 
The Unique Stake of 30 ETH cannot be slashed elsewhere. Operator Set 2 has allocations totalling 15 ETH of Unique Stake. 
The Unique Stake of 15 ETH cannot be slashed elsewhere. AVS 1 may distribute more valuable tasks against which to reward and 
slash to Operator Set 1 to take advantage of the greater amount of Unique Stake.

<img src="/img/operator-guides/operator-sets-figure-4.png" width="75%" style={{ margin: '50px'}}>
</img>

---

---
sidebar_position: 2
title: Accounts
---

The account is the Ethereum address that interacts with the EigenLayer core contracts if no appointees are set.

For an Operator, the account address is initialized by the [`registerAsOperator`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md#registerasoperator)
function in the [DelegationManager](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md) core contract. For Operators, this is the operator that holds shares in the `operatorShares` mapping in the [DelegationManager](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md) core contract.

For an AVS, the account address is initialized by the [`updateAVSMetadataURI`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#updateavsmetadatauri) function in the [AllocationManager](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md) core contract. For AVSs, this 
is the address under which Operator Sets are created in the [AllocationManager](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md) core contact.

As admin keys are added and rotated, the original account address remains the associated Operator ID or AVS ID.

:::caution
Before any admins are added, an account is its own admin. Once an admin is added, the account is no longer an admin by default. 
If an account wants to both add admins and continue acting as its own admin, the account must be added to the admins list before
adding additional admins.
:::


---

---
sidebar_position: 3
title: Admins
---

Admins can take any action on behalf of the original account that appointed them including adding or removing admins. Creating 
additional admins enables key rotation for Operators, or creating a backup admin which is stored on a cold key. The drawing
below shows how admin addresses can be rotated while retaining appointee access permissions.

<img src="/img/uam/admin-key-rotation.svg" width="100%"
style={{ margin: '50px'}}>
</img>

There must always be at least one admin for the account. If no admins have ever been set, the initial account address acts as the admin.
There is no superadmin role.

Admins cannot be given access to a subset of functions or contracts. Admins always have full access unless removed as an admin.
Specific function or contract access cannot be removed for a given admin.

For information on how to add and remove admins, refer to:
* [Add and Remove Admins](../../../operators/howto/uam/op-add-remove-admins.md) for Operators
* [Add and Remove Admins](../../../developers/HowTo/build/uam/dev-add-remove-admins.md) for Developers


---

---
sidebar_position: 3
title: Appointees
---

Appointees act as another account for a specific function for a specific contract, granting accounts granular access control.

Admins (or an account if no admins have been set) can grant an appointee access to specific functions on specified contracts. 
Appointees can be granted access to multiple functions or contracts. 

To perform key rotation, an admin creates a new appointee address with the same set of permissions and revokes access to the old appointee address.
The drawing below shows how appointee addresses can be rotated.

<img src="/img/uam/uam-rotate-appointees.svg" width="100%"
style={{ margin: '50px'}}>
</img>

Permissions for an appointee must be added and removed individually. There is no function to batch add permissions for a
given appointee, remove all permissions for a given appointee, batch add appointees to a given function, or remove all
appointees for a given function.

For information on how to add and remove appointees, refer to:
* [Add and Remove Appointees](../../../developers/HowTo/build/uam/dev-add-remove-appointees.md) for Developers 
* [Add and Remove Appointees](../../../operators/howto/uam/op-add-remove-appointees.md) for Operators




---

---
sidebar_position: 1
title: User Access Management
---

:::note
UAM implements [ELIP-003: User Access Management (UAM)](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-003.md).
:::

User Access Management (UAM) is an EigenLayer protocol feature for Operators and AVS Developers that enables secure key rotation,
revocation, and recovery. UAM enables admin keys to:
* Delegate specific functions to new addresses (EOAs or smart contracts).
* Be assigned or rotated as needed.

The [PermissionController core contract](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/permissions/PermissionController.md) implements UAM and defines three roles:
* [Accounts](uam-accounts.md)
* [Admins](uam-admins.md)
* [Appointees](uam-appointees.md)

:::note
UAM cannot be used by Stakers.
:::

---

---
sidebar_position: 1
title: Contract Addresses and Docs
---

## EigenLayer Core Restaking Contracts

The EigenLayer core contracts are located in this repo: [`Layr-Labs/eigenlayer-contracts`](https://github.com/Layr-Labs/eigenlayer-contracts). They enable restaking of liquid staking tokens (LSTs) and beacon chain ETH to secure new services, called AVSs (Autonomous Verifiable Services).

### Deployment Addresses

An up-to-date reference of our current mainnet and testnet contract deployments can be found in the core repository README: [`eigenlayer-contracts/README.md#deployments`](https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments).

### Technical Documentation

Our most up-to-date contract-level documentation can be found in the core repository's docs folder: [`eigenlayer-contracts/docs`](https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/docs).

---

---
sidebar_position: 1
title: Economy Calculation and Formulas
---

## Overview

EigenLayer strives to do its best and provide legibility and transparency to users.

Therefore, we built a website to show the critical metrics of the network, metrics that we deem
important for users to understand the protocol and its performance. Please see the Eigen Economy site at **[economy.eigenlayer.xyz](https://economy.eigenlayer.xyz/)**.


## Data Quality and Reconciliation

As a foundation to showcase EigenLayer's economy, we provide the best data quality possible by indexing data from Ethereum directly and reconciling each data point with other independent sources to guarantee the most accurate and up-to-date information.


## Data Freshness

Please refer to each metric below for their data freshness.


## Economy Metrics


### ETH TVL / EIGEN TVL / Total TVL in USD

Definition: Dollar value of total assets staked/restaked in EigenLayer, including all ETH (LSTs and native ETH), EIGEN tokens, and all other permissionless assets restaked.

Formula:

1. For all strategies' TVL in EigenLayer, except the beacon strategy (aka, native-ETH strategy) and EIGEN strategy:

- Index strategies in EigenLayer from all `StrategyAddedToDepositWhitelist` events minus `StrategyRemovedFromDepositWhitelist` events from the `StrategyManager` contract, which will include all strategies except the beacon strategy.
- For each strategy in EigenLayer, get their underlying tokens.
- Convert underlying tokens to token amounts via token decimals, `token amount = underlying token / power(10, token decimals)`.
- Multiply token amounts by the corresponding token's pricing from Coingecko, and sum them up.
    - Note that some tokens may lack pricing data on Coingecko; these will be excluded from the TVL in USD calculation.


2. For the beacon strategy:

- Index all `PodDeployed` events from the `EigenPodManager` contract.
- For each EigenPod, query the beacon chain to check which validators have pointed their withdrawal credentials to the pod.
    - Withdrawal credentials will be of the format: `0x010000000000000000000000 + <eigen_pod_address>`
    - Note: Multiple validator withdrawal credentials can point to a single EigenPod.
- For each EigenPod, get all its validators' ETH balance
- Sum up all validators balance, multiply by ETH pricing from Coingecko

- Note:
    - This approach is also [adopted by defillama](https://github.com/DefiLlama/DefiLlama-Adapters/blob/1e921c7ab6684500cfd73b6890713f495ba28f2a/projects/eigenlayer/index.js#L13)     
    - We will consider in the future to switch to use [EigenPod Upgrade](https://www.blog.eigenlayer.xyz/introducing-the-eigenpod-upgrade/) native data, to remove dependency on beacon chain data and be more close to rest strategies


3. For EIGEN strategy:

Follow the same steps in 1, with exception that EIGEN strategy is backed by bEIGEN (Backing EIGEN) token instead of
EIGEN token.
Coingecko only provides EIGEN token pricing, so we need to use EIGEN token pricing multiply by bEIGEN token amounts
to calculate TVL in USD for EIGEN strategy.


4. Sum up above 3 values to get the total TVL in USD for EigenLayer, or use them separately for ETH TVL and EIGEN TVL


Data Sources: Ethereum events, ERC20 contracts, Beacon Chain data, Coingecko
Data Fresh Frequency: Every 1 hour



### # of Restakers¹

Definition: Number of addresses staked/restaked in EigenLayer

Formula:

- Index `OperatorSharesIncreased` and `OperatorSharesDecreased` events from `DelegationManager` contract.
- Calculate delegation balance for each staker.
- Count # of unique stakers who has non-zero balance on at least 1 strategy.

Data Sources: Ethereum events
Data Fresh Frequency: Every 1 hour


### # of EIGEN Holders

Definition: Number of unique addresses that hold EIGEN tokens.

Formula:

- Index all `Transfer` events from EIGEN token contract.
- Calculate EIGEN token balance for each wallet address.
- Count # of unique addresses that have non-zero EIGEN token balance.

Data Sources: Ethereum events
Data Fresh Frequency: Every 1 hour



### % of ETH Restaked

Definition: Percentage of total ETH that is restaked, out of ETH circulating supply.

Formula:

- Index `OperatorSharesIncreased` and `OperatorSharesDecreased` events from `DelegationManager` contract.
- Calculate total delegated ETH amount for all ETH strategies, by convert shares to underlying tokens by strategy's ratio of shares to underlying token, then convert underlying tokens amount to tokens amount with token decimals `token amount = underlying token / 1e18`.
- Divide total delegated ETH amount by ETH circulating supply from Coingecko.

Data Sources: Ethereum events, Coingecko
Data Fresh Frequency: Every 1 hour



### % of circulating EIGEN staked

Definition: Percentage of circulating supply of EIGEN that is staked. This excludes locked tokens that are staked.

Formula:

 Index `OperatorSharesIncreased` and `OperatorSharesDecreased` events from `DelegationManager` contract.
- Calculate total delegated EIGEN amount for EIGEN strategy, by converting shares amount to underlying tokens amount as 1:1, then convert underlying tokens amount to tokens amount with token decimals `token amount = underlying token / 1e18`.
- Subtract the amount of locked tokens that are staked from the total delegated EIGEN amount.
- Divide the adjusted EIGEN amount by EIGEN circulating supply from Coingecko.

Data Sources: Ethereum events, Coingecko
Data Fresh Frequency: Every 1 hour



### Total Rewards Earned

Definition: Dollar value of total rewards earned in EigenLayer.

Formula:

- Index all `AVSRewardsSubmissionCreated` and `RewardsSubmissionForAllEarnersCreated` events from the `RewardsCoordinator` contract.
- For each rewards submission, get the token amount by converting `amount` with the reward token decimals.
- Multiply the token amount by the corresponding token's pricing from Coingecko, and sum them up.

Data Sources: Ethereum events, ERC20 contracts, Coingecko
Data Fresh Frequency: Every 1 hour



### Total AVS FDV

Definition: US Dollar value of all AVS Token FDVs

Note: EIGEN is not counted in the AVS FDV calculation.

Formula: 

- Retrieve tokens from all Mainnet AVSs that have an associated token.
- For each token, obtain its FDV (Fully Diluted Valuation) from Coingecko.
- Sum up the FDVs of all tokens to get the total AVS FDV.

Data Sources: Coingecko
Data Fresh Frequency: Every 1 hour



### Restakers Funnel

Definition: The funnel of restakers in EigenLayer, which includes the number of restakers who restaked (delegated) more than \$1M, \$50M, and \$100M cumulatively.

Formula:

- Index `OperatorSharesIncreased` and `OperatorSharesDecreased` events from the `DelegationManager` contract.
- For each restaker, get their delegated shares amount to date, convert shares to underlying tokens by strategy's ratio of shares to underlying token, then convert to tokens amount via token decimals, then convert to USD amount by multiplying with the corresponding token pricing from Coingecko.
- Sum up all USD value of delegated tokens for each restaker, count them by \$1M, \$50M, and \$100M thresholds.
- Cumulate thresholds, meaning the number of restakers who delegated more than \$1M includes that of who delegated more than \$50M and \$100M, the number of restakers who delegated more than \$50M includes that of who delegated more than \$100M.

Data Sources: Ethereum events, ERC20 contracts, Coingecko.
Data Fresh Frequency: Every 1 hour.



### Operators Funnel

Definition: The funnel of operators in EigenLayer, which includes the number of operators who:
 1. Registers on EigenLayer.
 2. Are active (registers to at least one AVS on EigenLayer with delegated shares larger than 0 in ETH or EIGEN strategies) on EigenLayer.
 3. Have earned rewards.


Formula:

- `Registered Operators`: Index `OperatorMetadataURIUpdated` event from the `AVSDirectory` contract, count the number of unique operator addresses registered
- `Active Operators`:
    - Index `OperatorAVSRegistrationStatus` event from the `AVSDirectory` contract, count the number of unique operator addresses who are registered to at least 1 AVS.
    - Index `OperatorSharesIncreased` and `OperatorSharesDecreased` events from `DelegationManager` contract, count the number of operators who have shares larger than 0 in any of ETH and EIGEN strategies, and also registered to at least 1 AVS, as "number of active operators".
- `Operators that have earned rewards`: Count number of operators above who have earned rewards, by querying rewards data published (see `rewards` section for details).

Data Sources: Ethereum events, EigenLayer rewards data
Data Fresh Frequency: Every 1 hour.



### AVSs Funnel


Definition: The funnel of AVSs in EigenLayer, which includes AVSs who:
1. Are in development on EigenLayer testnet and mainnet.
2. Are active by having at least 1 active operator registered to it on EigenLayer mainnet.
3. Have distributed rewards to operators and stakers on EigenLayer mainnet.

Note this is the only metric that contains data from testnet, all other metrics are for mainnet only.

Formula:
- `AVSs in Development`: Use data across mainnet, testnet and private channels.
- `Active AVSs`: Count number of AVSs who have at least 1 "active operator" registered to it on EigenLayer mainnet.
- `AVSs that have distributed rewards`: Index `avs_reward_submission_created` event from the `RewardCoordinator` contract, count number of AVSs who have also have distributed rewards to operators and stakers, and also in above "active AVSs" list.

Data Sources: Ethereum events from testnet and mainnet, private data.
Data Fresh Frequency: Every 1 hour.


 ¹ _The number of restakers reflects the various ways LRT holders create EigenPods. As a result, many users of LRT platforms may appear as one or a few wallets in the data. This metric aims to provide insight into the LRT-holders' participation._


---

---
sidebar_position: 2
title: Sidecar
---

## Overview

The EigenLayer Sidecar is an open source, permissionless, verified indexer enabling anyone (AVS, operator, etc) to access EigenLayer's protocol in real-time.

Sidecar provides the following benefits to users:
- Access to EigenLayer protocol data through easy-to-use APIs.
- Running your own Sidecar allows you to validate rewards roots posted on chain by being able to re-create them.
- Direct database access gives power-users the ability to explore protocol data directly and natively.

## How to Use Sidecar

Please see the [README.md documentation here](https://github.com/Layr-Labs/sidecar?tab=readme-ov-file#eigenlayer-sidecar).

---

---
sidebar_position: 2
title: Disclosures Related to Employee and Investor Staking
---

# Disclosures Related to Employee and Investor Staking

***Last Revised on September 30, 2024***

### EMPLOYEE AND INVESTOR LOCKUP ON EIGEN

EIGEN provided by Eigen Labs to its employees and [Investors](https://www.eigenlabs.org/#investors) is subject to the following lockup schedule: 4% of each recipient’s EIGEN will unlock each month starting September 2025 and an additional 4% will unlock each month thereafter, such that all EIGEN will be unlocked in September 2027 (the “**Lockup Schedule**”).

### EMPLOYEE AND INVESTOR STAKING ON EIGENLAYER

It was [previously communicated](https://blog.eigenfoundation.org/announcement/) that Investors and Early Contributors would be on the above Lockup Schedule. We want to clarify Eigen Labs company policies with respect to staking EIGEN and other assets and any EIGEN rewards:

#### Employees:
- **EIGEN staking**: Eigen Labs prohibits its current and former employees from staking any EIGEN received from Eigen Labs on EigenLayer until at least September 30th, 2025. 
- **Other assets staking**: Eigen Labs does not restrict its employees from staking other assets on EigenLayer (including ETH and LSTs), and any rewards received (including EIGEN) from such staking will not be subject to the Lockup Schedule.  
- **Stakedrops**: Eigen Labs employees were not permitted to claim stakedrops.

#### Investors:
- ***EIGEN staking**: Eigen Labs [Investors](https://www.eigenlabs.org/#investors) are not restricted from staking EIGEN on EigenLayer. As such, investors may choose to stake their EIGEN and receive staking rewards the same as any other user. EIGEN provided by Eigen Labs to investors is subject to the Lockup Schedule, but EIGEN investors receive from staking will not be subject to the Lockup Schedule. 
  - Note, as previously communicated, Investors did not receive rewards or airdrop allocation for any staking of EIGEN prior to September 30, 2024. 
- **Other assets staking**: Eigen Labs does not restrict [Investors](https://www.eigenlabs.org/#investors) from staking other assets on EigenLayer (including ETH and LSTs), and any rewards received (including EIGEN) from such staking will not be subject to the Lockup Schedule.
- **Stakedrops**: Investors were not restricted from claiming stakedrops.

*25% programmatic incentives go to EIGEN staking while the remaining 75% go to ETH and ETH-equivalent staking assets.

In addition to the above disclosures, we also encourage you to review our [Privacy Policy](../legal/privacy-policy.md) and our [Terms of Service](../legal/terms-of-service.md).  The above policies and disclosures are subject to change at any time for any reason and without notice. 


---

---
sidebar_position: 3
title: Disclaimers
---

# Disclaimers

***Last Revised on September 30, 2024***

## LEGAL DISCLAIMERS

All Eigen Labs, Inc. (“**Eigen Labs**”) blog posts, social media posts and accounts, forum posts, podcasts, speeches, videos, documentation, website copy, including [www.eigenlayer.xyz](https://www.eigenlayer.xyz), [www.eigenda.xyz](https://www.eigenda.xyz), and [www.eigenlabs.org](https://www.eigenlabs.org), or other content (collectively “**Content**”) are for entertainment and informational purposes only and do not necessarily express the views of Eigen Labs or any of its employees or contractors. The Content may contain hypothetical, forward-looking, incomplete, or incorrect information, which are not guaranteed and are subject to change. No Content, whether oral or written, from Eigen Labs or its employees or contractors, should be construed as a representation or warranty, express or implied, of any kind whatsoever. You should not rely on any Content as advice of any kind, including legal, investment, financial, tax or other professional advice, and the Content is not a substitute for advice from a qualified professional.

Any Content should not be construed as an offer to sell or the solicitation of an offer to purchase any token, financial instrument or security, and is not an offering, advertisement, solicitation, confirmation, statement, or any financial promotion that can be construed as an invitation or inducement to engage in any investment activity or similar.


---

---
sidebar_position: 1
title: Privacy Policy
---

# Privacy Policy

***Last Revised on March 20, 2024***

This Privacy Policy for Eigen Labs, Inc. ("Company", "we", "us" "our") describes how we collect, use and disclose information about users of the Company's website (eigenlayer.xyz), and any related services, tools and features, including the EigenLayer service (collectively, the "Services"). For the purposes of this Privacy Policy, "you" and "your" means you as the user of the Services. ​ Please read this Privacy Policy carefully. By using, accessing, or downloading any of the Services, you agree to the collection, use, and disclosure of your information as described in this Privacy Policy. If you do not agree to this Privacy Policy, please do not use, access or download any of the Services. ​

## UPDATING THIS PRIVACY POLICY

​We may modify this Privacy Policy from time to time in which case we will update the "Last Revised" date at the top of this Privacy Policy. If we make material changes to the way in which we use information we collect, we will use reasonable efforts to notify you (such as by emailing you at the last email address you provided us, by posting notice of such changes on the Services, or by other means consistent with applicable law) and will take additional steps as required by applicable law. If you do not agree to any updates to this Privacy Policy please do not access or continue to use the Services. ​

## COMPANY'S COLLECTION AND USE OF INFORMATION

​ When you access or use the Services, we may collect certain categories of information about you from a variety of sources, which comprises: ​

- The following information about you: name, email address, and Discord Tag. We collect your email address and Discord Tag in order to communicate with you through the Services and through third party platforms, such as Discord.
- Information included in any identity documents you provide to us, including without limitation driver’s license or passport number, date of birth and/or country of residence. We collect this in limited circumstances for the purposes of identification of the jurisdiction of residence of certain users or as otherwise needed to satisfy certain regulatory obligations.
- The following third-party wallet ("Wallet") information: public wallet address and token holdings. We collect third-party Wallet information in order to facilitate your use of the Services. ​
- Any other information you choose to include in communications with us, for example, when sending a message through the Services. ​ 

We also automatically collect certain information about your interaction with the Services ("Usage Data"). To do this, we may use cookies, web beacons/clear gifs and other geolocation tracking technologies ("Tracking Technologies"). Usage Data comprises of: ​
- Device information (e.g., unique device identifier, device type, IP address, operating system) ​
- Browser information (e.g., browser type) ​
- Location information (e.g., approximate geolocation) ​
- Other information regarding your interaction with the Services (e.g., log data, date and time stamps, clickstream data, ​ We use Usage Data to tailor features and content to you and to run analytics and better understand user interaction with the Services. For more information on how we use Tracking Technologies and your choices, see the section below, Cookies and Other Tracking Technologies. ​ In addition to the foregoing, we may use any of the above information to comply with any applicable legal obligations, to enforce any applicable terms of service, and to protect or defend the Services, our rights, and the rights of our users or others. ​

## HOW THE COMPANY SHARES YOUR INFORMATION

​In certain circumstances, the Company may share your information with third parties for legitimate purposes subject to this Privacy Policy. Such circumstances comprise of: ​

- With vendors or other service providers, such as ​
- Blockchain analysis service providers, including Chainanalysis ​
- Data analytics vendors, including Google Analytics ​
- To comply with applicable law or any obligations thereunder, including cooperation with law
  enforcement, judicial orders, and regulatory inquiries ​
- In connection with an asset sale, merger, bankruptcy, or other business transaction ​
- To enforce any applicable terms of service ​
- To ensure the safety and security of the Company and/or its users ​
- When you request us to share certain information with third parties, such as through your use of login integrations ​
- With professional advisors, such as auditors, law firms, or accounting firms ​

## COOKIES AND OTHER TRACKING TECHNOLOGIES

​Do Not Track Signals ​ Your browser settings may allow you to transmit a "Do Not Track" signal when you visit various websites. Like many websites, our website is not designed to respond to "Do Not Track" signals received from browsers. To learn more about "Do Not Track" signals, you can visit [http://www.allaboutdnt.com/.](http://www.allaboutdnt.com) ​ Cookies and Other Tracking Technologies ​ Most browsers accept cookies automatically, but you may be able to control the way in which your devices permit the use of cookies, web beacons/clear gifs, other geolocation tracking technologies. If you so choose, you may block or delete our cookies from your browser; however, blocking or deleting cookies may cause some of the Services, including any portal features and general functionality, to work incorrectly. If you have questions regarding the specific information about you that we process or retain, as well as your choices regarding our collection and use practices, please contact us using the information listed below. ​ To opt out of tracking by Google Analytics, click [here](https://tools.google.com/dlpage/gaoptout). ​ Your browser settings may allow you to transmit a "Do Not Track" signal when you visit various websites. Like many websites, our website is not designed to respond to "Do Not Track" signals received from browsers. To learn more about "Do Not Track" signals, you can visit [http://www.allaboutdnt.com/.](http://www.allaboutdnt.com) ​

## SOCIAL NETWORKS AND OTHER THIRD PARTY WEBSITES AND LINKS

​We may provide links to websites or other online platforms operated by third parties, including third-party social networking platforms, such as Twitter, Discord, or Medium, operated by third parties (such platforms are "Social Networks"). If you follow links to sites not affiliated or controlled by us, you should review their privacy and security policies and other terms and conditions. We do not guarantee and are not responsible for the privacy or security of these sites, including the accuracy, completeness, or reliability of information found on these sites. Information you provide on public or semi-public venues, including information you share or post on Social Networks, may also be accessible or viewable by other users of the Services and/or users of those third-party online platforms without limitation as to its use by us or by a third party. Our inclusion of such links does not, by itself, imply any endorsement of the content on such platforms or of their owners or operators, except as disclosed on the Services. ​

## THIRD PARTY WALLET EXTENSIONS

​Certain transactions conducted via our Services, will require you to connect a Wallet to the Services. By using such Wallet to conduct such transactions via the Services, you agree that your interactions with such third party Wallets are governed by the privacy policy for the applicable Wallet. We expressly disclaim any and all liability for actions arising from your use of third party Wallets, including but without limitation, to actions relating to the use and/or disclosure of personal information by such third party Wallets.

## CHILDREN'S PRIVACY

​Children under the age of 18 are not permitted to use the Services, and we do not seek or knowingly collect any personal information about children under 13 years of age. If we become aware that we have unknowingly collected information about a child under 13 years of age, we will make commercially reasonable efforts to delete such information from our database. ​ If you are the parent or guardian of a child under 13 years of age who has provided us with their personal information, you may contact us using the below information to request that it be deleted. ​

## DATA SECURITY

​Please be aware that, despite our reasonable efforts to protect your information, no security measures are perfect or impenetrable, and we cannot guarantee "perfect security." Please further note that any information you send to us electronically, while using the Services or otherwise interacting with us, may not be secure while in transit. We recommend that you do not use unsecure channels to communicate sensitive or confidential information to us. ​

## HOW TO CONTACT US

Should you have any questions about our privacy practices or this Privacy Policy, please email us at notices@eigenlabs.org or contact us at 15790 Redmond Way #1176, Redmond, WA 98052 .


---

---
sidebar_position: 2
title: Terms of Service
---

# Terms of Service
***Last Revised on August 29, 2024***

These Terms of Service (these "**Terms**") explain the terms and conditions by which you may access and use our websites, www.eigenlayer.xyz (the "**EigenLayer Website**") and www.eigenda.xyz (together with the EigenLayer Website, the "Websites"), operated by or on behalf of Eigen Labs, Inc. ("**Company**", "**we**" or "**us**"). Our Websites, our App (as defined below), our EigenLayer App testnet ("**Testnet**"), our application programming interfaces ("**APIs**"), and any content, tools, documentation, features and functionality offered on or through the Websites or App are collectively referred to herein as the **"Services"**. Effective as of August 29, 2024, the Websites and Services do not include the following subdomains of the EigenLayer Website: forum.eigenlayer.xyz (the **“Forum”**), the research forum available at  research.eigenlayer.xyz  (**"Research"** and collectively with the Forum, and any other subdomains that contain a terms of service indicating the are operated by EigenFoundation, the **"Third-Party Subdomains"**), each including any lower-level domains and any content, tools, documentations, features and functionality offered therein. As of August 29, 2024, the Third-Party Subdomains are operated by or on behalf of EigenFoundation or its subsidiaries, not us, and your access and use of the Foundation Website after such date is governed by the terms and conditions available at docs.eigenfoundation.org/legal/terms-of-service . Notwithstanding the foregoing, all rights and liabilities related to your use of the Third-Party Subdomains prior to August 29, 2024 are governed by these Terms.

These Terms govern your access to and use of the Services. Please read these Terms carefully, as they include important information about your legal rights. By accessing and/or using the Services, you are agreeing to these Terms. If you do not understand or agree to these Terms, please do not use the Services.

For purposes of these Terms, "**you**" and "**your**" means you as the user of the Services. If you use the Services on behalf of a company or other entity then "you" includes you and that entity, and you represent and warrant that (a) you are an authorized representative of the entity with the authority to bind the entity to these Terms, and (b) you agree to these Terms on the entity's behalf.

> SECTION 9 CONTAINS AN ARBITRATION CLAUSE AND CLASS ACTION WAIVER. BY AGREEING TO THESE TERMS, YOU AGREE (A) TO RESOLVE ALL DISPUTES (WITH LIMITED EXCEPTION) RELATED TO THE COMPANY'S SERVICES AND/OR PRODUCTS THROUGH BINDING INDIVIDUAL ARBITRATION, WHICH MEANS THAT YOU WAIVE ANY RIGHT TO HAVE THOSE DISPUTES DECIDED BY A JUDGE OR JURY, AND (B) TO WAIVE YOUR RIGHT TO PARTICIPATE IN CLASS ACTIONS, CLASS ARBITRATIONS, OR REPRESENTATIVE ACTIONS, AS SET FORTH BELOW. YOU HAVE THE RIGHT TO OPT-OUT OF THE ARBITRATION CLAUSE AND THE CLASS ACTION WAIVER AS EXPLAINED IN SECTION 9.

1. **THE SERVICES**
    1. Services. The Services provide a front-end interface (the "**App**") that display data that facilitates users interfacing with a set of decentralized smart contracts that allow for the restaking of digital assets, such as Ether (ETH). These underlying smart contracts are referred to herein as the "**EigenLayer Protocol**”.  The Services may also reference or provide an App or APIs related to smart contracts that provide a data availability service built on top of Ethereum. These underlying smart contracts are referred to herein as the “**EigenDA Protocol**”. Collectively, the EigenLayer Protocol and EigenDA Protocol are referred to herein as the **“Protocols**”). The Services also provide documentation available at [docs.eigenlayer.xyz](https://docs.eigenlayer.xyz) related to the App and Protocol ("**Documentation**"). **The Protocols are not part of the Services, and your use of the Protocols is entirely at your own risk. Additionally, the third party technologies required to be used or interacted with in order to interact with the Protocols, including but not limited to a Wallet (as defined below, and collectively the “Third-Party Tools”), are not part of the Services, and your use of such Third-Party Tools are entirely at your own risk.** The App is separate and distinct from either of the Protocols and any Third-Party Tools. The App is not essential to accessing the Protocols. The App merely displays blockchain data and provides a web application that reduces the complexity of using the Third-Party Tools or otherwise accessing either of the Protocols. All activity on each of the Protocols is run by permissionless smart contracts, and other developers are free to create their own interfaces to function with the Protocols.

    2. Wallets. To use certain of the Services you may need to link a third-party digital wallet (**"Wallet"**) with the Services. By using a Wallet in connection with the Services, you agree that you are using the Wallet under the terms and conditions of the applicable third-party provider of such Wallet. Wallets are not associated with, maintained by, supported by or affiliated with the Company. You acknowledge and agree that we are not party to any transactions conducted while accessing our App, and we do not have possession, custody or control over any digital assets appearing on the Services. When you interact with the App, you retain control over your digital assets at all times. The Company accepts no responsibility or liability to you in connection with your use of a Wallet, and makes no representations and warranties regarding how the Services will operate with any specific Wallet. **The private keys and/or seed phrases necessary to access the assets held in a Wallet are not held by the Company. The Company has no ability to help you access or recover your private keys and/or seed phrases for your Wallet, so please keep them in a safe place.**

    3. Updates; Monitoring. We may make any improvement, modifications or updates to the Services, including but not limited to changes and updates to the underlying software, infrastructure, security protocols, technical configurations or service features (the "**Updates**") from time to time. Your continued access and use of the Services are subject to such Updates and you shall accept any patches, system upgrades, bug fixes, feature modifications, or other maintenance work that arise out of such Updates. We are not liable for any failure by you to accept and use such Updates in the manner specified or required by us. Although the Company is not obligated to monitor access to or participation in the Services, it has the right to do so for the purpose of operating the Services, to ensure compliance with the Terms and to comply with applicable law or other legal requirements.

    4. The Company may charge or pass through fees for some or part of the Services we make available to you, including transaction or processing fees, blockchain gas or similar network fees. We will disclose the amount of fees we will charge or pass through to you for the applicable Service at the time you access, use or otherwise transact with the Services. Although we will attempt to provide accurate fee information, any such information reflects our estimate of fees, which may vary from the fees actually paid to use the Services and interact with the applicable blockchain with which the Services are compatible. Additionally, your external Wallet provider may impose a fee to transact on the Services. We are not responsible for any fees charged by a third party. All transactions processed through the Services are non-refundable. You will be responsible for paying any and all taxes, duties and assessments now or hereafter claimed or imposed by any governmental authority associated with your use of the Services. In certain cases, your transactions through the Services may not be successful due to an error with the blockchain or the Wallet. We accept no responsibility or liability to you for any such failed transactions, or any transaction or gas fees that may be incurred by you in connection with such failed transactions. You acknowledge and agree that all information you provide with respect to transactions on the Services, including, without limitation, credit card, bank account, PayPal or other payment information is accurate, current and complete, and you have the legal right to use such payment method.

    5. Rewards.  In your use of the Services, you may be attributed certain reputation indicators, points, or other intangible rewards (“**Rewards”**). Rewards are not, and may never convert to, accrue to, be used as basis to calculate, or become any other tokens or virtual assets or distribution thereof. Rewards are virtual items with no monetary value. Rewards do not constitute any currency or property of any type and are not redeemable, refundable, or eligible for any fiat or virtual currency or anything else of value. Rewards are not transferable between users, and you may not attempt to sell, trade, or transfer any Rewards, or obtain any manner of credit using any Rewards. Any attempt to sell, trade, or transfer any Rewards or tokens redeemable for or representing any Rewards will be null and void. 

2. **Who May Use the Services**

    1. You must be 18 years of age or older and not be a Prohibited Person to use the Services. A "**Prohibited Person**" is any person or entity that is (a) listed on any U.S. Government list of prohibited or restricted parties, including without limitation the U.S. Treasury Department's list of Specially Designated Nationals or the U.S. Department of Commerce Denied Person's List or Entity List, (b) located or organized in any U.S. embargoed countries or region any country or region that has been designated by the U.S. Government as "terrorist supporting", or (c) owned or controlled by such persons or entities listed in (a)-(b). You acknowledge and agree that you are solely responsible for complying with all applicable laws of the jurisdiction you are located or accessing the Services from in connection with your use of the Services. By using the Services, you represent and warrant that you meet these requirements and will not be using the Services for any illegal activity or to engage in the prohibited activities in Section 5.3.

    2. To use certain of the Services, you may need to create an account or link another account ("**Account**"). You agree to provide us with accurate, complete and updated information for your Account. You are solely responsible for any activity on your Account and maintaining the confidentiality and security of your password. We are not liable for any acts or omissions by you in connection with your Account. You must immediately notify us at [notices@eigenlabs.org](mailto:notices@eigenlabs.org) if you know or have any reason to suspect that your Account or password have been stolen, misappropriated or otherwise compromised, or in case of any actual or suspected unauthorized use of your Account. You agree not to create any Account if we have previously removed yours, or we previously banned you from any of our Services, unless we provide written consent otherwise.

    3. We may require you to provide additional information and documents regarding your use of the Services, including at the request of any competent authority or in case of application of any applicable law or regulation, including laws related to anti-money laundering or for counteracting financing of terrorism. We may also require you to provide additional information or documents in cases where we have reason to believe: (i) that your Wallet is being used for illegal money laundering or for any other illegal activity; (ii) you have concealed or reported false identification information or other details; or (iii) you are a Prohibited Person. You agree that if it is determined in our sole discretion that you may be violating this Section 2 or engaging in any activities prohibited in these Terms, we may disable your ability to use the Services including the App, which may include but is not limited to preventing you from restaking assets or withdrawing previously restaked assets. 

3. **The Testnet**

    1. Purpose and Participation. The Testnet is designed to demonstrate the functionality and features of the App (or any portion thereof) and to improve participant experiences prior to the App's launch. YOUR PARTICIPATION IN THE TESTNET IS ENTIRELY VOLUNTARY, BUT IF YOU ARE PARTICIPATING IN THE TESTNET, YOU MUST STRICTLY ADHERE TO THESE TERMS. We make no representation or warranty that the Testnet will accurately or completely simulate, duplicate or replicate the App.
    2. Duration. The availability of the Testnet will commence on the date prescribed by the Company and continue until terminated by the Company in its sole discretion. Notwithstanding any other information provided by the Company regarding the Testnet (including on the Websites, blog posts or through other communications (such as forums, Telegram, Github, Discord, or other channels)), the Company may change, discontinue, or terminate, temporarily or permanently, all or any part of the Testnet, at any time and without notice, at its sole discretion (including prior to providing any incentives or rewards). The Company may retain control or upgradeability over certain aspects of the Testnet that it will not retain on Mainnet.
    3. The Testnet Eligibility. Your participation in the Testnet (or any portion thereof) may be subject to eligibility criteria determined by the Company in its sole discretion (including, without limitation, geographical distribution and applicant reputation). By applying or registering, there is no promise or guarantee that you will be able to participate in the Testnet. Notwithstanding any other information provided by the Company regarding the Testnet (including on the Websites, blog posts or through other communications (such as forums, Telegram, Github, Discord, or other channels)), the Company may change or modify at any time the number of participants eligible to participate in the Testnet or the requirements of the Testnet and terminate any participant's participation in the Testnet at any time. The Testnet may operate in certain phases. Your selection or participation in any one phase of the Testnet does not imply that you will be selected for any other phases of the Testnet. The Company reserves the right to block your access to the Testnet at any time in its sole discretion.
    4. No Monetary Value. In your use of the Testnet, you may interact with or transfer certain cryptocurrencies or other digital assets on the Testnet ("**Testnet Tokens**"), such as Testnet Tokens obtained through a faucet. Testnet Tokens are not, and shall never convert to or accrue to become any other tokens or virtual assets. Testnet Tokens are virtual items with no monetary value. Testnet Tokens do not constitute any currency or property of any type and are not redeemable, refundable, or eligible for any fiat or digital currency or anything else of value. Testnet Tokens are not transferable between users outside of the Testnet, and you may not attempt to sell, trade, or transfer any Testnet Tokens outside of the Testnet, or obtain any manner of credit using any Testnet Tokens. Any attempt to sell, trade, or transfer any Testnet Tokens outside of the Testnet will be null and void. Testnet Tokens will not be converted into any future rewards offered by the Company.

4. **Location of Our Privacy Policy**

    1. Privacy Policy. Our Privacy Policy describes how we handle the information you provide to us when you use the Services. For an explanation of our privacy practices, please visit our [Privacy Policy here](./privacy-policy.md).
    

5. **Rights We Grant You**

    1. Right to Use Services. We hereby permit you to use the Services for your personal non-commercial use only, provided that you comply with these Terms in connection with all such use. If any software, content or other materials owned or controlled by us are distributed to you as part of your use of the Services, we hereby grant you, a personal, non-assignable, non-sublicensable, non-transferrable, and non-exclusive right and license to access and display such software, content and materials provided to you as part of the Services, in each case for the sole purpose of enabling you to use the Services as permitted by these Terms. Your access and use of the Services may be interrupted from time to time for any of several reasons, including, without limitation, the malfunction of equipment, periodic updating, maintenance or repair of the Service or other actions that Company, in its sole discretion, may elect to take. Certain elements of the Protocols, including the underlying smart contracts, are made available under an open-source or source-available license (e.g., at https://github.com/Layr-Labs and https://github.com/eigenfoundation), and these Terms do not override or supersede the terms of those licenses.

    2. Right to Use Our APIs. Subject to these Terms, we hereby grant you a non-exclusive, non-transferable, non-sublicensable, worldwide, revocable right and license to use our APIs for the limited purposes set forth in the documentation for the Services. Your use of our APIs must comply with the technical documentation, usage guidelines, call volume limits, and other documentation maintained at [https://docs.eigenlayer.xyz/](https://docs.eigenlayer.xyz/) or such other location we may designate from time to time. We may terminate your right to use the API from time to time at any time.
    3. Restrictions On Your Use of the Services. You may not do any of the following in connection with your use of the Services, unless applicable laws or regulations prohibit these restrictions or you have our written permission to do so:
        1. download, modify, copy, distribute, transmit, display, perform, reproduce, duplicate, publish, license, create derivative works from, or offer for sale any information contained on, or obtained from or through, the Services, except for temporary files that are automatically cached by your web browser for display purposes, or as otherwise expressly permitted in these Terms;
        1. duplicate, decompile, reverse engineer, disassemble or decode the Services (including any underlying idea or algorithm), or attempt to do any of the same;
        1. use, reproduce or remove any copyright, trademark, service mark, trade name, slogan, logo, image, or other proprietary notation displayed on or through the Services;
        1. use automation software (bots), hacks, modifications (mods) or any other unauthorized third-party software designed to modify the Services;
        8. exploit the Services for any commercial purpose, including without limitation communicating or facilitating any commercial advertisement or solicitation;
        9. access or use the Services in any manner that could disable, overburden, damage, disrupt or impair the Services or interfere with any other party's access to or use of the Services or use any device, software or routine that causes the same;
        10. attempt to gain unauthorized access to, interfere with, damage or disrupt the Services, accounts registered to other users, or the computer systems, wallets, accounts, protocols or networks connected to the Services;
        11. circumvent, remove, alter, deactivate, degrade or thwart any technological measure or content protections of the Services or the computer systems, wallets, accounts, protocols or networks connected to the Services;
        12. use any robot, spider, crawlers or other automatic device, process, software or queries that intercepts, "mines," scrapes or otherwise accesses the Services to monitor, extract, copy or collect information or data from or through the Services, or engage in any manual process to do the same;
        13. introduce any viruses, trojan horses, worms, logic bombs or other materials that are malicious or technologically harmful into our systems;
        14. submit, transmit, display, perform, post or store any content that is inaccurate, unlawful, defamatory, obscene, lewd, lascivious, filthy, excessively violent, pornographic, invasive of privacy or publicity rights, harassing, threatening, abusive, inflammatory, harmful, hateful, cruel or insensitive, deceptive, or otherwise objectionable, use the Services for illegal, harassing, bullying, unethical or disruptive purposes, or otherwise use the Services in a manner that is obscene, lewd, lascivious, filthy, excessively violent, harassing, harmful, hateful, cruel or insensitive, deceptive, threatening, abusive, inflammatory, pornographic, inciting, organizing, promoting or facilitating violence or criminal or harmful activities, defamatory, obscene or otherwise objectionable;
        15. violate any applicable law or regulation in connection with your access to or use of the Services; or
        16. access or use the Services in any way not expressly permitted by these Terms.
    1. Interactions with Other Users on the Services. You are responsible for your interactions with other users on or through the Services. While we reserve the right to monitor interactions between users, we are not obligated to do so, and we cannot be held liable for your interactions with other users, or for any user's actions or inactions. If you have a dispute with one or more users, you release us (and our affiliates and subsidiaries, and our and their respective officers, directors, employees and agents) from claims, demands and damages (actual and consequential) of every kind and nature, known and unknown, arising out of or in any way connected with such disputes. In entering into this release you expressly waive any protections (whether statutory or otherwise) that would otherwise limit the coverage of this release to include only those claims which you may know or suspect to exist in your favor at the time of agreeing to this release.

6. **Ownership and Content**

    1. Ownership of the Services. The Services, including their "look and feel" (e.g., text, graphics, images, logos), proprietary content, information and other materials, are protected under copyright, trademark and other intellectual property laws. You agree that the Company and/or its licensors own all right, title and interest in and to the Services (including any and all intellectual property rights therein) and you agree not to take any action(s) inconsistent with such ownership interests. We and our licensors reserve all rights in connection with the Services and its content, including, without limitation, the exclusive right to create derivative works.
    2. Ownership of Trademarks. The Company's name, trademarks and logos and all related names, logos, product and service names, designs and slogans are trademarks of the Company or its affiliates or licensors. Other names, logos, product and service names, designs and slogans that appear on the Services are the property of their respective owners, who may or may not be affiliated with, connected to, or sponsored by us.
    3. Ownership of Feedback. We welcome feedback, bug reports, comments and suggestions for improvements to the Services ("**Feedback**"). You acknowledge and expressly agree that any contribution of Feedback does not and will not give or grant you any right, title or interest in the Services or in any such Feedback. All Feedback becomes the sole and exclusive property of the Company, and the Company may use and disclose Feedback in any manner and for any purpose whatsoever without further notice or compensation to you and without retention by you of any proprietary or other right or claim. You hereby assign to the Company any and all right, title and interest (including, but not limited to, any patent, copyright, trade secret, trademark, show-how, know-how, moral rights and any and all other intellectual property right) that you may have in and to any and all Feedback.
    4. Your Content License Grant. In connection with your use of the Services, you may be able to post, upload, or submit content to be made available through the Services ("Your Content"). In order to operate the Service, we must obtain from you certain license rights in Your Content so that actions we take in operating the Service are not considered legal violations. Accordingly, by using the Service and uploading Your Content, you grant us a license to access, use, host, cache, store, reproduce, transmit, display, publish, distribute, and modify (for technical purposes, e.g., making sure content is viewable on smartphones as well as computers and other devices) Your Content but solely as required to be able to operate, improve and provide the Services. You agree that these rights and licenses are royalty free, transferable, sub-licensable, worldwide and irrevocable (for so long as Your Content is stored with us), and include a right for us to make Your Content available to, and pass these rights along to, others with whom we have contractual relationships related to the provision of the Services, solely for the purpose of providing such Services, and to otherwise permit access to or disclose Your Content to third parties if we determine such access is necessary to comply with our legal obligations. As part of the foregoing license grant you agree that the other users of the Services shall have the right to comment on and/or tag Your Content and/or to use, publish, display, modify or include a copy of Your Content as part of their own use of the Services; except that the foregoing shall not apply to any of Your Content that you post privately for non-public display on the Services. To the fullest extent permitted by applicable law, the Company reserves the right, and has absolute discretion, to remove, screen, edit, or delete any of Your Content at any time, for any reason, and without notice. By posting or submitting Your Content through the Services, you represent and warrant that you have, or have obtained, all rights, licenses, consents, permissions, power and/or authority necessary to grant the rights granted herein for Your Content. You agree that Your Content will not contain material subject to copyright or other proprietary rights, unless you have the necessary permission or are otherwise legally entitled to post the material and to grant us the license described above.
    5. Notice of Infringement -- DMCA (Copyright) Policy. 
    
    If you believe that any text, graphics, photos, audio, videos or other materials or works uploaded, downloaded or appearing on the Services have been copied in a way that constitutes copyright infringement, you may submit a notification to our copyright agent in accordance with 17 USC 512(c) of the Digital Millennium Copyright Act (the "**DMCA**"), by providing the following information in writing:
        1. identification of the copyrighted work that is claimed to be infringed;
        2. identification of the allegedly infringing material that is requested to be removed, including a description of where it is located on the Service;
        3. information for our copyright agent to contact you, such as an address, telephone number and e-mail address;
        4. a statement that you have a good faith belief that the identified, allegedly infringing use is not authorized by the copyright owners, its agent or the law;
        5. a statement that the information above is accurate, and under penalty of perjury, that you are the copyright owner or the authorized person to act on behalf of the copyright owner; and
        6. the physical or electronic signature of a person authorized to act on behalf of the owner of the copyright or of an exclusive right that is allegedly infringed.

    Notices of copyright infringement claims should be sent by mail to: Eigen Labs, Inc., Attn: Legal, 15790 Redmond Way #1176 Redmond, WA 98052 ; or by e-mail to [notices@eigenlabs.org](mailto:notices@eigenlabs.org). It is our policy, in appropriate circumstances and at our discretion, to disable or terminate the accounts of users who repeatedly infringe copyrights or intellectual property rights of others.

    A user of the Services who has uploaded or posted materials identified as infringing as described above may supply a counter-notification pursuant to sections 512(g)(2) and (3) of the DMCA. When we receive a counter-notification, we may reinstate the posts or material in question, in our sole discretion. To file a counter-notification with us, you must provide a written communication (by fax or regular mail or by email) that sets forth all of the items required by sections 512(g)(2) and (3) of the DMCA. Please note that you will be liable for damages if you materially misrepresent that content or an activity is not infringing the copyrights of others.

7. **Third Party Services and Materials**

    1. Third Party Services and Materials. The Services may allow you to browse the availability of  certain (i) actively validated services (“**AVSs**”) (ii) operators that offer to run certain AVSs in connection with your delegated restaked digital assets and/or (iii) other services or products developed or run by third parties displayed on the Services, including the App  (“**Third-Party Services**”) and may display, include or make available content, data, information, applications or materials from third parties (“**Third-Party Materials**”) or provide links to certain third party websites. For clarity, effective August 29, 2024, the Third-Party Subdomains are each a Third-Party Service and the content, data, information, applications or materials therein are Third-Party Materials. The Company does not endorse or recommend any Third-Party Materials, the use of any provider of any Third-Party Services, or the restaking or delegation of any assets to any Third-Party Services. You agree that your access and use of such Third-Party Services and Third-Party Materials is governed solely by the terms and conditions of such Third-Party Services and Third-Party Materials, as applicable. The Company is not responsible or liable for, and make no representations as to any aspect of such Third-Party Materials and Third-Party Services, including, without limitation, their content or the manner in which they handle, protect, manage or process data or any interaction between you and the provider of such Third-Party Services. The Company is not responsible for examining or evaluating the content, accuracy, completeness, availability, timeliness, validity, copyright compliance, legality, decency, quality, security or any other aspect of such Third Party Services or Third Party Materials or websites. You irrevocably waive any claim against the Company with respect to such Third-Party Services and Third-Party Materials. We are not liable for and you expressly disclaim any liability with respect to any damage or loss caused or alleged to be caused by or in connection with your enablement, access or use of any such Third-Party Services or Third-Party Materials, or your reliance on the privacy practices, data security processes or other policies of such Third-Party Services, including without limitation, the delegation of any assets to any Third-Party Service or the staking of any assets with any Third-Party Service that results in slashing or any other loss of funds or the integration of any Third-Party Service such as an AVS into your product or service that results in any damages whatsoever. Third-Party Services, Third-Party Materials and links to other websites are provided solely as a convenience to you. Certain Third-Party Services or Third-Party Materials may automatically populate on the Company’s Services. The Company reserves the right to remove any Third-Party Services or Third-Party Materials from the Services, including without limitation, any AVSs or operators for any reason whatsoever. 

8. **Disclaimers, Limitations of Liability and Indemnification**

    1. Disclaimers. Your access to and use of the Services and any Protocols are at your own risk. You understand and agree that the Services are provided to you on an "AS IS" and "AS AVAILABLE" basis. Without limiting the foregoing, to the maximum extent permitted under applicable law, the Company, its parents, affiliates, related companies, officers, directors, employees, agents, representatives, partners and licensors (the "**Company Entities**") and MultiSig Committee Members (as defined below) DISCLAIM ALL WARRANTIES AND CONDITIONS, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING WITHOUT LIMITATION ANY WARRANTIES RELATING TO TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, USAGE, QUALITY, PERFORMANCE, SUITABILITY OR FITNESS OF THE SERVICES AND THE PROTOCOLS FOR ANY PARTICULAR PURPOSE, OR AS TO THE ACCURACY, QUALITY, SEQUENCE, RELIABILITY, WORKMANSHIP OR TECHNICAL CODING THEREOF, OR THE ABSENCE OF ANY DEFECTS THEREIN WHETHER LATENT OR PATENT. The Company Entities and MultiSig Committee Members make no warranty or representation and disclaim all responsibility and liability for: (a) the completeness, accuracy, availability, timeliness, security or reliability of the Services, and the Protocols; (b) any harm to your computer system, loss of data, or other harm that results from your access to or use of the Services or the Protocols; (c) the operation or compatibility with any other application or any particular system or device, including any Wallets; (d) whether the Services or the Protocols will meet your requirements or be available on an uninterrupted, secure or error-free basis;  (e) whether the Services or the Protocols will protect your assets from theft, hacking, cyber attack or other form of loss caused by third party conduct; (f) loss of funds or value resulting from intentional or unintentional slashing or as a result of a fork of any token such as via a social slashing or intersubjective forking mechanism and (g) the deletion of, or the failure to store or transmit, Your Content and other communications maintained by the Services. No advice or information, whether oral or written, obtained from the Company Entities or the MultiSig Committee Members or through the Services, will create any warranty or representation not expressly made herein. You should not rely on the Services, for advice of any kind, including legal, tax, investment, financial or other professional advice.
    2. Limitations of Liability. TO THE EXTENT NOT PROHIBITED BY LAW, YOU AGREE THAT IN NO EVENT WILL THE COMPANY ENTITIES AND MULTISIG COMMITTEE MEMBERS BE LIABLE (A) FOR DAMAGES OF ANY KIND, INCLUDING INDIRECT, SPECIAL, EXEMPLARY, INCIDENTAL, CONSEQUENTIAL OR PUNITIVE DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, LOSS OF USE, DATA OR PROFITS, BUSINESS INTERRUPTION OR ANY OTHER DAMAGES OR LOSSES, ARISING OUT OF OR RELATED TO YOUR USE OR INABILITY TO USE THE SERVICES), HOWEVER CAUSED AND UNDER ANY THEORY OF LIABILITY, WHETHER UNDER THESE TERMS OR OTHERWISE ARISING IN ANY WAY IN CONNECTION WITH THE SERVICES OR THESE TERMS AND WHETHER IN CONTRACT, STRICT LIABILITY OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) EVEN IF THE COMPANY ENTITIES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE, OR (B) FOR ANY OTHER CLAIM, DEMAND OR DAMAGES WHATSOEVER RESULTING FROM OR ARISING OUT OF OR IN CONNECTION WITH THESE TERMS OR THE DELIVERY, USE OR PERFORMANCE OF THE SERVICES. THE COMPANY ENTITIES' AND MULTISIG COMMITTEE MEMBERS' TOTAL LIABILITY TO YOU FOR ANY DAMAGES FINALLY AWARDED SHALL NOT EXCEED ONE HUNDRED DOLLARS ($100.00) RESPECTIVELY.
    3. SOME JURISDICTIONS (SUCH AS THE STATE OF NEW JERSEY) DO NOT ALLOW LIMITATIONS ON IMPLIED WARRANTIES OR THE EXCLUSION OR LIMITATION OF INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO SOME OR ALL OF THE ABOVE DISCLAIMERS, EXCLUSION OR LIMITATION MAY NOT APPLY TO YOU, AND YOU MAY HAVE ADDITIONAL RIGHTS.
    4. Assumption of Risks.
        1. By using the Services, you represent that you have sufficient knowledge and experience in business and financial matters, including a sufficient understanding of blockchain or cryptographic tokens and technologies and other digital assets, storage mechanisms (such as Wallets), blockchain-based software systems, and blockchain technology, to be able to assess and evaluate the risks and benefits of the Services contemplated hereunder, and will bear the risks thereof, including loss of all amounts paid, and the risk that the tokens may have little or no value. You acknowledge and agree that there are risks associated with purchasing and holding cryptocurrency, using blockchain technology and staking cryptocurrency. These include, but are not limited to, risk of losing access to cryptocurrency due to slashing, loss of private key(s), custodial error or purchaser error, risk of mining or blockchain attacks, risk of hacking and security weaknesses, risk of unfavorable regulatory intervention in one or more jurisdictions, risk related to token taxation, risk of personal information disclosure, risk of uninsured losses, volatility risks, and unanticipated risks. You acknowledge that cryptocurrencies are not (i) deposits of or guaranteed by a bank (ii) insured by the FDIC or by any other governmental agency and (iii) that we do not custody and cannot transfer any cryptocurrency or digital assets you may interact with on the Services or Protocols. 
        1. There are certain multi-signature crypto wallets (the "**MultiSigs**", and the signatories to such MultiSigs, the "**MultiSig Committee Members**") that have certain controls related to one or more of the Protocols, that may include, but are not limited to, the ability to pause certain functionality of the Protocols, reverse or pause slashing, implement or influence upgrades to the Protocols (or any aspect thereof) and certain other controls of the functionality of the Protocols as described in the documentation or in public communications made by us. Certain MultiSigs may be controlled by us or MultiSig Committee Members that are employed or engaged by us, and certain other MultiSigs will be controlled partially or entirely by MultiSig Committee Members that are unaffiliated third parties over which we have no or limited control. We will not be able to control the actions of such MultiSig Committee Members if they are not employed or engaged by us and thus certain MultiSigs will be outside of our control.
        1. The regulatory regime governing blockchain technologies, cryptocurrencies and other digital assets is uncertain, and new regulations or policies may materially adversely affect the potential utility or value of such cryptocurrencies and digital assets. There also exists the risks of new taxation of the purchase or sale of cryptocurrencies and other digital assets.
        1. We cannot control how third-party exchange platforms quote or value cryptocurrencies and other digital assets and we expressly deny and disclaim any liability to you and deny any obligations to indemnify or hold you harmless for any losses you may incur as a result of fluctuations in the value of cryptocurrencies or other digital assets.
        1. Smart contracts execute automatically when certain conditions are met. Since smart contracts typically cannot be stopped or reversed, vulnerabilities in their programming and design or other vulnerabilities that may arise due to hacking or other security incidents can have adverse effects to restaked assets, including but not limited to significant volatility and risk of loss.
        1. Certain protocols and networks subject staked assets to slashing upon certain conditions, including, but not limited to, if a validator or operator engages in harmful or malicious behavior, fails to perform their role as a validator or operator properly, or incorrectly validates a transaction, and we expressly deny and disclaim any liability to you and deny any obligations to indemnify or hold you harmless for any losses you may incur as a result of slashing.
        1. Certain protocols and networks require that a certain amount of staked assets be locked for a certain period of time while staking, and withdrawal of staked assets may be delayed. We do not guarantee the security or functionality of any third-party protocol, software or technology intended to be compatible with restaked assets.
    5. Indemnification. By entering into these Terms and accessing or using the Services, you agree that you shall defend, indemnify and hold the Company Entities and MultiSig Committee Members harmless from and against any and all claims, costs, damages, losses, liabilities and expenses (including attorneys’ fees and costs) incurred by the Company Entities or MultiSig Committee Members arising out of or in connection with: (a) your violation or breach of any term of these Terms or any applicable law or regulation; (b) your violation of any rights of any third party; (c) your misuse of the Services; or (d) your negligence or wilful misconduct; or (e) your Content. If you are obligated to indemnify any Company Entity or MultiSig Committee Members hereunder, then you agree that the Company (or, at its discretion, the applicable Company Entity) or MultiSig Committee Members, as applicable, will have the right, in its sole discretion, to control any action or proceeding and to determine whether the Company or MultiSig Committee Member, as applicable, wishes to settle, and if so, on what terms, and you agree to fully cooperate with the Company or MultiSig Committee Members in the defense or settlement of such claim.
    6. Third Party Beneficiaries. You and the Company acknowledge and agree that the Company Entities (other than the Company) and the MultiSig Committee Members are third party beneficiaries of these Terms, including under Section 8 and 9.

9. **ARBITRATION AND CLASS ACTION WAIVER**

    1. PLEASE READ THIS SECTION CAREFULLY -- IT MAY SIGNIFICANTLY AFFECT YOUR LEGAL RIGHTS, INCLUDING YOUR RIGHT TO FILE A LAWSUIT IN COURT AND TO HAVE A JURY HEAR YOUR CLAIMS. IT CONTAINS PROCEDURES FOR MANDATORY BINDING ARBITRATION AND A CLASS ACTION WAIVER.
    2. Informal Process First. You and the Company agree that in the event of any dispute between you and the Company Entities or the MultiSig Committee Members, either party will first contact the other party and make a good faith sustained effort to resolve the dispute before resorting to more formal means of resolution, including without limitation, any court action, after first allowing the receiving party 30 days in which to respond. Both you and the Company agree that this dispute resolution procedure is a condition precedent which must be satisfied before initiating any arbitration against you, any Company Entity or any MultiSig Committee Members, as applicable.
    3. Arbitration Agreement and Class Action Waiver. After the informal dispute resolution process, any remaining dispute, controversy, or claim (collectively, "**Claim**") relating in any way to the Services, including the App, any use or access or lack of access thereto, and any other usage of the Protocols even if interacted with outside of the Services or App, will be resolved by arbitration, including threshold questions of arbitrability of the Claim. You and the Company agree that any Claim will be settled by final and binding arbitration, using the English language, administered by JAMS under its Comprehensive Arbitration Rules and Procedures (the "**JAMS Rules**") then in effect (those rules are deemed to be incorporated by reference into this section, and as of the date of these Terms). Because your contract with the Company, these Terms, and this Arbitration Agreement concern interstate commerce, the Federal Arbitration Act ("FAA") governs the arbitrability of all disputes. However, the arbitrator will apply applicable substantive law consistent with the FAA and the applicable statute of limitations or condition precedent to suit. Arbitration will be handled by a sole arbitrator in accordance with the JAMS Rules. Judgment on the arbitration award may be entered in any court that has jurisdiction. Any arbitration under these Terms will take place on an individual basis -- class arbitrations and class actions are not permitted. You understand that by agreeing to these Terms, you and the Company are each waiving the right to trial by jury or to participate in a class action or class arbitration.
    4. Batch Arbitration. To increase the efficiency of administration and resolution of arbitrations, you and the Company agree that in the event that there are one-hundred (100) or more individual Claims of a substantially similar nature filed against the Company by or with the assistance of the same law firm, group of law firms, or organizations, then within a thirty (30) day period (or as soon as possible thereafter), JAMS shall (1) administer the arbitration demands in batches of 100 Claims per batch (plus, to the extent there are less than 100 Claims left over after the batching described above, a final batch consisting of the remaining Claims); (2) appoint one arbitrator for each batch; and (3) provide for the resolution of each batch as a single consolidated arbitration with one set of filing and administrative fees due per side per batch, one procedural calendar, one hearing (if any) in a place to be determined by the arbitrator, and one final award (**“Batch Arbitration”**). All parties agree that Claims are of a “substantially similar nature” if they arise out of or relate to the same event or factual scenario and raise the same or similar legal issues and seek the same or similar relief. To the extent the parties disagree on the application of the Batch Arbitration process, the disagreeing party shall advise JAMS, and JAMS shall appoint a sole standing arbitrator to determine the applicability of the Batch Arbitration process (**“Administrative Arbitrator”**). In an effort to expedite resolution of any such dispute by the Administrative Arbitrator, the parties agree the Administrative Arbitrator may set forth such procedures as are necessary to resolve any disputes promptly. The Administrative Arbitrator’s fees shall be paid by the Company. You and the Company agree to cooperate in good faith with JAMS to implement the Batch Arbitration process including the payment of single filing and administrative fees for batches of Claims, as well as any steps to minimize the time and costs of arbitration, which may include: (1) the appointment of a discovery special master to assist the arbitrator in the resolution of discovery disputes; and (2) the adoption of an expedited calendar of the arbitration proceedings. This Batch Arbitration provision shall in no way be interpreted as authorizing a class, collective and/or mass arbitration or action of any kind, or arbitration involving joint or consolidated claims under any circumstances, except as expressly set forth in this provision.

    5. Exceptions. Notwithstanding the foregoing, you and the Company agree that the following types of disputes will be resolved in a court of proper jurisdiction: (i) disputes or claims within the jurisdiction of a small claims court consistent with the jurisdictional and dollar limits that may apply, as long as it is brought and maintained as an individual dispute and not as a class, representative, or consolidated action or proceeding; (ii) disputes or claims where the sole form of relief sought is injunctive relief (including public injunctive relief); or (iii) intellectual property disputes.
    6. Costs of Arbitration. Payment of all filing, administration, and arbitrator costs and expenses will be governed by the JAMS Rules, except that if you demonstrate that any such costs and expenses owed by you under those rules would be prohibitively more expensive than a court proceeding, the Company will pay the amount of any such costs and expenses that the arbitrator determines are necessary to prevent the arbitration from being prohibitively more expensive than a court proceeding (subject to possible reimbursement as set forth below).

        1. Fees and costs may be awarded as provided pursuant to applicable law. If the arbitrator finds that either the substance of your claim or the relief sought in the Demand is frivolous or brought for an improper purpose (as measured by the standards set forth in Federal Rule of Civil Procedure 11(b)), then the payment of all fees will be governed by the JAMS rules. In that case, you agree to reimburse the Company for all monies previously disbursed by it that are otherwise your obligation to pay under the applicable rules. If you prevail in the arbitration and are awarded an amount that is less than the last written settlement amount offered by the Company before the arbitrator was appointed, the Company will pay you the amount it offered in settlement. The arbitrator may make rulings and resolve disputes as to the payment and reimbursement of fees or expenses at any time during the proceeding and upon request from either party made within fourteen (14) days of the arbitrator's ruling on the merits.

    7. **Opt-Out. You have the right to opt-out and not be bound by the arbitration provisions set forth in these Terms by sending written notice of your decision to opt-out to notices@eigenlabs.org. The notice must be sent to the Company within thirty (30) days of your first registering to use the Services or agreeing to these Terms; otherwise you shall be bound to arbitrate disputes on a non-class basis in accordance with these Terms. If you opt out of only the arbitration provisions, and not also the class action waiver, the class action waiver still applies. You may not opt out of only the class action waiver and not also the arbitration provisions. If you opt-out of these arbitration provisions, the Company also will not be bound by them.**
    8. WAIVER OF RIGHT TO BRING CLASS ACTION AND REPRESENTATIVE CLAIMS. TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, YOU AND THE COMPANY EACH AGREE THAT ANY PROCEEDING TO RESOLVE ANY DISPUTE, CLAIM OR CONTROVERSY WILL BE BROUGHT AND CONDUCTED ONLY IN THE RESPECTIVE PARTY'S INDIVIDUAL CAPACITY AND NOT AS PART OF ANY CLASS (OR PURPORTED CLASS), CONSOLIDATED, MULTIPLE-PLAINTIFF, OR REPRESENTATIVE ACTION OR PROCEEDING ("CLASS ACTION"). YOU AND THE COMPANY AGREE TO WAIVE THE RIGHT TO PARTICIPATE AS A PLAINTIFF OR CLASS MEMBER IN ANY CLASS ACTION. YOU AND THE COMPANY EXPRESSLY WAIVE ANY ABILITY TO MAINTAIN A CLASS ACTION IN ANY FORUM. IF THE DISPUTE IS SUBJECT TO ARBITRATION, THE ARBITRATOR WILL NOT HAVE THE AUTHORITY TO COMBINE OR AGGREGATE CLAIMS, CONDUCT A CLASS ACTION, OR MAKE AN AWARD TO ANY PERSON OR ENTITY NOT A PARTY TO THE ARBITRATION. FURTHER, YOU AND THE COMPANY AGREE THAT THE ARBITRATOR MAY NOT CONSOLIDATE PROCEEDINGS FOR MORE THAN ONE PERSON'S CLAIMS, AND IT MAY NOT OTHERWISE PRESIDE OVER ANY FORM OF A CLASS ACTION. FOR THE AVOIDANCE OF DOUBT, HOWEVER, YOU CAN SEEK PUBLIC INJUNCTIVE RELIEF TO THE EXTENT AUTHORIZED BY LAW AND CONSISTENT WITH THE EXCEPTIONS CLAUSE ABOVE. 3. IF THIS CLASS ACTION WAIVER IS LIMITED, VOIDED, OR FOUND UNENFORCEABLE, THEN, UNLESS THE PARTIES MUTUALLY AGREE OTHERWISE, THE PARTIES' AGREEMENT TO ARBITRATE SHALL BE NULL AND VOID WITH RESPECT TO SUCH PROCEEDING SO LONG AS THE PROCEEDING IS PERMITTED TO PROCEED AS A CLASS ACTION. IF A COURT DECIDES THAT THE LIMITATIONS OF THIS PARAGRAPH ARE DEEMED INVALID OR UNENFORCEABLE, ANY PUTATIVE CLASS, PRIVATE ATTORNEY GENERAL OR CONSOLIDATED OR REPRESENTATIVE ACTION MUST BE BROUGHT IN A COURT OF PROPER JURISDICTION AND NOT IN ARBITRATION.

10. **Additional Provisions**

    1. Updating These Terms. We may modify these Terms from time to time in which case we will update the "**Last Revised**" date at the top of these Terms. If we make changes that are material, we will use reasonable efforts to attempt to notify you, such as by e-mail and/or by placing a prominent notice on the first page of the Website. However, it is your sole responsibility to review these Terms from time to time to view any such changes. The updated Terms will be effective as of the time of posting, or such later date as may be specified in the updated Terms. Your continued access or use of the Services after the modifications have become effective will be deemed your acceptance of the modified Terms. No amendment shall apply to a dispute for which an arbitration has been initiated prior to the change in Terms.
    2. Suspension; Termination. If you breach any of the provisions of these Terms, all licenses granted by the Company will terminate automatically. Additionally, the Company may, in its sole discretion, suspend or terminate your Account and/or access to or use of any of the Services, with or without notice, for any or no reason, including, without limitation, (i) if we believe, in our sole discretion, you have engaged in any of the prohibited activities set forth in Section 5.3; (ii) if you provide any incomplete, incorrect or false information to us; (iii) if you have breached any portion of these Terms; (iv) if we suspect you may be a Prohibited Person or any Wallet used to access the Services is linked with any illegal or high-risk activity; and/or (v) if we determine such action is necessary to comply with these Terms, any of our policies, procedures or practices, or any law rule or regulation.  If the Company deletes your Account for any suspected breach of these Terms by you, you are prohibited from re-registering for the Services under a different name. In the event of Account deletion for any reason, the Company may, but is not obligated to, delete any of Your Content. the Company shall not be responsible for the failure to delete or deletion of Your Content. All sections which by their nature should survive the termination of these Terms shall continue in full force and effect subsequent to and notwithstanding any termination of this Agreement by the Company or you. Termination will not limit any of the Company’s other rights or remedies at law or in equity.
    3. Injunctive Relief. You agree that a breach of these Terms will cause irreparable injury to the Company for which monetary damages would not be an adequate remedy and the Company shall be entitled to equitable relief in addition to any remedies it may have hereunder or at law without a bond, other security or proof of damages.
    4. California Residents. If you are a California resident, in accordance with Cal. Civ. Code § 1789.3, you may report complaints to the Complaint Assistance Unit of the Division of Consumer Services of the California Department of Consumer Affairs by contacting them in writing at 1625 North Market Blvd., Suite N 112 Sacramento, CA 95834, or by telephone at (800) 952-5210.
    5. Export Laws. You agree that you will not export or re-export, directly or indirectly, the Services and/or other information or materials provided by the Company hereunder, to any country for which the United States or any other relevant jurisdiction requires any export license or other governmental approval at the time of export without first obtaining such license or approval. In particular, but without limitation, the Services may not be exported or re-exported (a) into any U.S. embargoed countries or any country that has been designated by the U.S. Government as a "terrorist supporting" country, or (b) to anyone listed on any U.S. Government list of prohibited or restricted parties, including the U.S. Treasury Department's list of Specially Designated Nationals or the U.S. Department of Commerce Denied Person's List or Entity List. By using the Services, you represent and warrant that you are not located in any such country or on any such list. You are responsible for and hereby agree to comply at your sole expense with all applicable United States export laws and regulations.
    6. Force Majeure. We will not be liable or responsible to you, nor be deemed to have defaulted under or breached these Terms, for any failure or delay in fulfilling or performing any of our obligations under these Terms or in providing the Services, when and to the extent such failure or delay is caused by or results from any events beyond our ability to control, including acts of God; flood, fire, earthquake, epidemics, pandemics, tsunami, explosion, war, invasion, hostilities (whether war is declared or not), terrorist threats or acts, riot or other civil unrest, government order, law, or action, embargoes or blockades, strikes, labor stoppages or slowdowns or other industrial disturbances, shortage of adequate or suitable Internet connectivity, telecommunication breakdown or shortage of adequate power or electricity, and other similar events beyond our control.
    7. Miscellaneous. If any provision of these Terms shall be unlawful, void or for any reason unenforceable, then that provision shall be deemed severable from these Terms and shall not affect the validity and enforceability of any remaining provisions. These Terms and the licenses granted hereunder may be assigned by the Company but may not be assigned by you without the prior express written consent of the Company. No waiver by either party of any breach or default hereunder shall be deemed to be a waiver of any preceding or subsequent breach or default. The section headings used herein are for reference only and shall not be read to have any legal effect. The Services are operated by us in the United States. Those who choose to access the Services from locations outside the United States do so at their own initiative and are responsible for compliance with applicable local laws. These Terms are governed by the laws of the State of New York, without regard to conflict of laws rules, and the proper venue for any disputes arising out of or relating to any of the same will be the state and federal courts located in New York, New York.
    8. How to Contact Us. You may contact us regarding the Services or these Terms by e-mail at **notices@eigenlabs.org**.


---

---
title: Intro to EigenLayer
sidebar_position: 1
---


## What is EigenLayer?


Building a new Web3 service comes with significant challenges: bootstrapping crypto-economic security and assembling a reliable network of Operators. Meanwhile, the Web3 ecosystem is rich with opportunities, including a surplus of asset holders eager to earn rewards and skilled Operators seeking to expand into new, value-driven services. EigenLayer bridges this gap, aligning incentives and unlocking untapped potential for both builders and the broader community.

EigenLayer is a protocol built on Ethereum that introduces Restaking, a new primitive for Web3 builders that provides a "marketplace for trust" bringing together Restakers, Operators, and Autonomous Verifiable Services (AVSs). It allows users to stake assets such as Native ETH, Liquid Staking Tokens (LSTs), the EIGEN token, or any ERC20 token into EigenLayer smart contracts, thereby extending Ethereum's cryptoeconomic security to additional applications on the network. It fosters innovation by enabling newer projects to benefit from Ethereum’s robust security guarantees without the need to replicate the costly process of securing their own network.

AVSs have tools to make economic commitments to their end users, such as proper or fair execution of their code run by Operators. The [Rewards v2 (currently in Testnet) upgrade](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-001.md#eigenlayer-improvement-proposal-001-rewards-v2) enables AVSs to issue rewards to Operators and Stakers when the AVS’ services are properly run (the carrot). The [Slashing and Operator Sets](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md) (currently in Testnet) upgrade gives AVSs the ability to slash stake in instances where the commitments to properly run their services are broken (the stick).

## Why Build with EigenLayer?

Ethereum is a secure foundation for decentralized applications and has established itself as the best in class infrastructure for smart contract apps. However, many Web3 builders wish to expand beyond Ethereum’s compute capability and offer secured off-chain services for their communities. EigenLayer acts as an additional layer on top of Ethereum, allowing developers to build on this foundation without having to duplicate the cost, complexities, or resources needed to create their own blockchain network and services.

EigenLayer solves the bootstrapping problem for new Web3 services by aggregating a ready-to-deploy network of Operators and Restaked assets that are ready to operate and validate new Web3 services. Instead of requiring every Web3 builder to independently raise capital, establish cryptoeconomic security, and onboard Operators, EigenLayer offers Cryptoeconomic Security as a Service. This approach frees builders to focus on their core differentiators, accelerating innovation without the need to build security frameworks from scratch.

The key benefits of building an AVS on EigenLayer include:

- Security via Restaking: leverage Ethereum’s staking mechanism to secure your service.
- Focus on your project's unique value: spend less time and resources accumulating economic security from scratch.
- Bootstrap your Operator network: quickly access a large network of experienced Operators.
- Decentralization and Trust: build on trust minimized, decentralized infrastructure.
- Composability: seamlessly integrate with the broader Ethereum ecosystem.

## EigenLayer Architecture Overview

The core components of the EigenLayer protocol include:

- **Restaking** enables stakers to restake their Native ETH or Liquid Staking Tokens (LST) to provide security for services in the EigenLayer ecosystem, known as Autonomous Verifiable Services (AVSs).
- **Autonomous Verifiable Services (AVSs)** are services built on the EigenLayer protocol that leverage Ethereum's shared security. AVSs deliver services to users and the broader Web3 ecosystem. 
- **Operators** are entities that run AVS software and perform validation tasks for AVSs built on EigenLayer. They register in EigenLayer and allow stakers to delegate to them, then opt in to provide various services (AVSs) built on top of EigenLayer.
- **Delegation** is the process where stakers delegate their restaked ETH or LSTs to Operators or run validation services themselves, effectively becoming an Operator. This process involves a double opt-in between both parties, ensuring mutual agreement.
- EigenLayer **Rewards** enables AVSs to make rewards distributions to stakers and operators that opt-in to support the AVS. AVSs make RewardsSubmissions to the RewardsCoordinator, a core protocol contract.
- **Slashing** is a penalty for improperly or inaccurately completing tasks assigned in Operator Sets by an AVS. A slashing results in a burning/loss of funds.

<img src="/img/overview/eigenlayer-arch-v2.png" width="75%"
    style={{ margin: '50px'}}>
</img>

## Next Steps
To learn more about EigenLayer, refer to the [Whitepapers](whitepaper.md) or explore the [Learning Resources](../resources/learning-resources.md).

Get started with EigenLayer:
- [Restake on EigenLayer](/restakers/concepts/overview)
- [Register as an Operator](/operators/howto/operator-installation)
- [Build an AVS](/developers/Concepts/avs-developer-guide)
- Join our Ecosystem: [Discord](https://discord.com/invite/eigenlayer), [Twitter](https://twitter.com/eigenlayer)



---

---
title: Key Terms
sidebar_position: 2
---



- **Autonomous Verifiable Services (AVS):**  a service built externally to EigenLayer that requires active verification by a set of Operators. An AVS deploys its service manager to interact with EigenLayer core contracts that allow for Operator registration to Operator Sets, slashing, and rewards distribution. Once registered, an Operator agrees to run the AVS’s off-chain code.

- **Allocation / Deallocation:** an in-protocol commitment of security to an AVS’s Operator Set by an Operator. The act of allocating demarcates portions of an Operator’s delegated stake as Unique Stake, making it slashable by a single AVS. Deallocation is the same process in reverse, subject to additional time delays that ensure AVSs can appropriately slash for tasks that have occurred in the past.

- **AVS Developer**: development team that builds an AVS service.
- **Cryptoeconomic security:** security model that uses economic incentives and cryptography to ensure the proper functioning and security of a network.
- **Delegation:** the process by which a Staker assigns their staked tokens to a chosen Operator, granting the Operator the authority to use the value of those tokens for validating AVSs. The Operator cannot directly access the delegated tokens, but can subject any delegated tokens to slashing by an AVS. Delegations themselves are the sum of a given Operator’s delegated stake from Stakers.
- **EigenPod:** contract that is deployed on a per-user basis that facilitates native restaking.
- **Free-market governance:** EigenLayer provides an open market mechanism that allows stakers to choose which services to opt into, based on their own risk and reward analysis.
- **Liquid Staking:** a service that enables users to deposit their ETH into a staking pool and receive a liquid staking token. This token represents a claim on their ETH and its staking yield. Liquid staking tokens can be traded in the DeFi ecosystem and redeemed for their underlying ETH value after a waiting period.
- **LST Restaking:** a method where LST holders restake their Liquid Staking Tokens (LSTs) by transferring them into the EigenLayer smart contracts.
- **Magnitude**: The accounting tool used to track Operator allocations to Operator Sets. Represented as \`wads\` in the AllocationManager and \`bips\` in the CLI. Magnitudes represent proportions of an Operator’s delegations for a specific Strategy. The sum of all of an Operator’s Magnitudes cannot exceed the INITIAL\_TOTAL\_MAGNITUDE.
- **Native Restaking:** a method where Ethereum stakers restake their staked ETH natively by pointing their withdrawal credentials to the EigenLayer contracts.
- **On-chain slashing contract:** a smart contract deployed by service modules on EigenLayer that enforces slashing, specifying and penalizing any misbehavior.
- **Operator:** An entity that registers an Operator address on Eigenlayer to receive delegations from Stakers and run AVS infrastructure. Operators allocate their delegated stake to Operator Sets created by an AVS.
- **Operator Set:** a segmentation of Operators created by an AVS that secures a specific set of tasks for the AVS with staked assets that may be reserved for securing that set.
- **Pooled security via restaking:** when multiple parties combine their resources to provide greater security for a system. In EigenLayer, Ethereum stakers can “restake” their ETH or Liquid Staking Tokens (LST) by opting into new services built on EigenLayer.
- **Programmatic Incentives** are EIGEN tokens minted by the EigenLayer protocol to Stakers and Operators.
- **Restaker**: a person who restakes Native or LST ETH to the EigenLayer protocol.
- **Rewards**: Tokens sent by AVSs to Stakers and/or Operators to compensate participation.
- **Slashing:** A penalty for improperly or inaccurately completing tasks assigned in Operator Sets by an AVS. A slashing results in a burning/loss of funds.
- **Staker:** An individual address that directly supplies assets to Eigenlayer. Such an address could be an EOA wallet or a smart contract controlled by an individual or institution.
- **Strategies**: assets that are restaked into the platform.
- **Unique Stake:** Assets made slashable exclusively by one Operator Set. Unique Stake is an accounting tool defined on the level of Operator Sets that ensures AVSs and Operators maintain key safety properties when handling staked security and slashing on EigenLayer. Unique Stake is allocated to different Operator Sets on an opt-in basis by Operators. Unique Stake represents the proportion of an Operator’s delegated stake from Stakers that an AVS can slash.
- **Withdrawal:** The process through which assets are moved out of the EigenLayer protocol after safety delays and with applied slashings to the nominal amounts. 

---

# Community and EIGEN Claim Support

For any discussion, engagement, and learning about EigenLayer, please join the [EigenLayer Community Discord](https://discord.gg/eigenlayer).

# Restaker, Operator, and AVS Development Support

For issues with the dApp, LST and restaking issues and Operator questions you may send us a question via our AI-enabled chatbot and Support team here:  <a href="javascript:void(0)"  id="intercom_trigger_eldocs" >EigenLayer Support Desk</a>

# EigenLayer Forum

If you are interested in EigenLayer at a deeper level, please check out the [EigenLayer forum](https://forum.eigenlayer.xyz/)! There are groups of researchers, AVS developers, and more contributing their expertise to help build the open verifiable cloud.

# EIGEN Claim Support

For any issues concerning EIGEN including token claims and stakedrop issues, please visit the stakedrop-support channel in the [EigenLayer Community Discord](https://discord.gg/eigenlayer). The Eigen Foundation support team can address your question there. Please see docs.eigenfoundation.org for information related to EIGEN token claims.

Please beware of any fraudulent tokens, dApps, and phishing sites:
- The only site to claim EIGEN is: claims.eigenfoundation.org .
- The EIGEN token contract address is: `0xec53bF9167f50cDEB3Ae105f56099aaaB9061F83` .
- The only support website is: docs.eigenlayer.xyz .
    
For a complete list of links and more information, please visit the: [EigenLayer Community Discord](https://discord.gg/eigenlayer).



---

# Whitepapers

**EigenLayer: The Restaking Collective** ([PDF](/pdf/EigenLayer_WhitePaper.pdf) / <a href="/html/EigenLayer_WhitePaper-converted-xodo.html" target="_blank">HTML</a>): the research paper that formed the basis of the EigenLayer protocol development. The document discusses the original architecture of EigenLayer, the Restaking primitive, and the concept of AVSs. Please note that some components of the design have changed since the original conception of the protocol. Use this document for high level guidance. For specific implementation details, please see the respective protocol implementation source code repositories.


**EIGEN The Universal Intersubjective Work Token:**([PDF](/pdf/EIGEN_Token_Whitepaper.pdf) / <a href="/html/EIGEN_Token_Whitepaper-converted-xodo.html" target="_blank">HTML</a>): the research paper that introduces the structure of the EIGEN token, a universal intersubjective work token. We view this intersubjective work token as a first step towards the goal of building the Verifiable Digital Commons.




---

---
sidebar_position: 4
title: Allocation Manager Interface
---

The `AllocationManager` interface handles all allocation and deallocation signals.

```solidity
interface IAllocationManager {

   /**
    * @notice struct used to modify the allocation of slashable magnitude to an operator set
    * @param operatorSet the operator set to modify the allocation for
    * @param strategies the strategies to modify allocations for
    * @param newMagnitudes the new magnitude to allocate for each strategy to this operator set
    */
   struct AllocateParams {
       OperatorSet operatorSet;
       IStrategy[] strategies;
       uint64[] newMagnitudes;
   }

   /**
     * @notice Called by the delegation manager OR an operator to set an operator's allocation delay.
     * This is set when the operator first registers, and is the number of blocks between an operator
     * allocating magnitude to an operator set, and the magnitude becoming slashable.
     * @param operator The operator to set the delay on behalf of.
     * @param delay the allocation delay in blocks
     */
    function setAllocationDelay(
	address operator, 
	uint32 delay
    ) external;

    /**
     * @notice Modifies the proportions of slashable stake allocated to an operator set  from a list of strategies
     * Note that deallocations remain slashable for DEALLOCATION_DELAY blocks therefore when they are cleared they may
     * free up less allocatable magnitude than initially deallocated.
     * @param operator the operator to modify allocations for
     * @param params array of magnitude adjustments for one or more operator sets
     * @dev Updates encumberedMagnitude for the updated strategies
     * @dev msg.sender is used as operator
     */
    function modifyAllocations(
	address operator, 
	AllocateParams[] calldata params
    ) external;

    /**
     * @notice struct used to modify the allocation of slashable magnitude to an operator set
     * @param operatorSet the operator set to modify the allocation for
     * @param strategies the strategies to modify allocations for
     * @param newMagnitudes the new magnitude to allocate for each strategy to this operator set
     */
    struct AllocateParams {
        OperatorSet operatorSet;
        IStrategy[] strategies;
        uint64[] newMagnitudes;
    }

    /**
     * @notice This function takes a list of strategies and for each strategy, removes from the deallocationQueue
     * all clearable deallocations up to max `numToClear` number of deallocations, updating the encumberedMagnitude
     * of the operator as needed.
     *
     * @param operator address to clear deallocations for
     * @param strategies a list of strategies to clear deallocations for
     * @param numToClear a list of number of pending deallocations to clear for each strategy
     *
     * @dev can be called permissionlessly by anyone
     */
    function clearDeallocationQueue(
        address operator,
        IStrategy[] calldata strategies,
        uint16[] calldata numToClear
    ) external;
}
```

---

---
sidebar_position: 4
title: Safety Delays
---

Safety delays for allocations and deallocations are included in the table.

| Parameter | Description                                                                                                                                                                                                                                                                                                                                           | Value | Setter & Configuration |
| :---- |:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| :---- | :---- |
| `ALLOCATION_CONFIGURATION_DELAY` | Amount of blocks between an Operator queuing an `ALLOCATION_DELAY` change and the change taking effect.                                                                                                                                                                                                                                               | 126000 blocks (~17.5 days) | Core Protocol: Set via governance |
| `ALLOCATION_DELAY` | Amount of blocks it takes for an Operator’s allocation to be live in an Operator Set for a given Strategy. Must be set by the Operator before any allocations and applies globally to all Operator Sets and Strategies.  The protocol provides no constraints on this value. It can be any unsigned integer value and can be changed by the Operator. | Unsigned integer value representing a number of blocks  | Operator: Set via `AllocationManager` Must be set in order to allocate |
| `DEALLOCATION_DELAY` | Amount of blocks between an Operator queuing a deallocation of stake from an Operator Set for a strategy and the deallocation taking effect. This delay also applies to an Operator *deregistering* from an Operator Set, either by their own action or that of the AVS.                                                                              | 100800 blocks (~14 days) | Core Protocol: Set via governance |
| `INITIAL_TOTAL_MAGNITUDE` | Initial value of the monotonically decreasing total magnitude for every Operator for every strategy. Initially set high enough to start out with a large level of precision in magnitude allocations and slashings.                                                                                                                                   | 1e18 | Core Protocol: Constant, unlikely to change |
| `WITHDRAWAL_DELAY` | Amount of blocks between a Staker queueing a withdrawal and the withdrawal becoming non-slashable and completable.                                                                                                                                                                                                                                    | 100800 blocks (~14 days) | Core Protocol: Set via governance |

:::note 
On EigenLayer testnet deployments, the `ALLOCATION_CONFIGURATION_DELAY` is set to 75 blocks (~15 mins), and the `DEALLOCATION_DELAY` and `WITHDRAWAL_DELAY` is set to 25 blocks (~5 mins) for ease of use.
:::

---

---
sidebar_position: 3
title: Releases
---
# Mainnet

The [Slashing](https://github.com/Layr-Labs/eigenlayer-contracts/releases/tag/v1.3.0) and Rewards v2.1 releases are available on mainnet.

The Slashing release includes [User Access Management (UAM)](concepts/uam/user-access-management.md).


The following components include updated functionality for the Slashing release:
* [Operator CLI](https://github.com/Layr-Labs/eigenlayer-cli)
* [AVS Sync](https://github.com/Layr-Labs/avs-sync)
* [EigenSDK-GO](https://github.com/Layr-Labs/eigensdk-go)
* [EigenSDK-Rust](https://github.com/Layr-Labs/eigensdk-rs)
* [Middleware](https://github.com/Layr-Labs/eigenlayer-middleware)
* [Sidecar](https://github.com/Layr-Labs/sidecar)
* [EigenLayer app](https://app.eigenlayer.xyz/)

:::important 
Unless specified otherwise, this documentation matches the functionality available on mainnet. For mainnet specific documentation 
in the [eigenlayer-contracts](https://github.com/Layr-Labs/eigenlayer-contracts) and [eigenlayer-middleware](https://github.com/Layr-Labs/eigenlayer-middleware) repositories, refer to the `/docs` repository on the `mainnet` branch.

:::

## Documentation Updates included in Slashing Release


### Slashing 

Refer to: 
* [Slashing concept](concepts/slashing/slashing-concept)
* For developers, [Implement Slashing](../developers/HowTo/build/slashing/implement-slashing)
* For Stakers and Operators, [Slashable Stake Risk](concepts/slashing/slashable-stake-risks)

### Operator Sets

The Slashing release introduced Operator Sets. The AllocationManager core contract manages Operator Sets and replaces
the AVSDirectory for registering Operators to an AVS. [The AVSDirectory will be deprecated in a future upgrade](https://docs.eigenlayer.xyz/developers/HowTo/slashing/migrate-to-operatorsets).

### Rewards v2.1

Rewards v2.1 introduced Operator directed rewards for Operator sets. For AVSs using Operator Sets, use `createOperatorDirectedOperatorSetRewardsSubmission`. 
`createAVSRewardsSubmission` and `createOperatorDirectedAVSRewardsSubmission` remain available for use by AVSs that have not yet [migrated to Operator Sets](https://docs.eigenlayer.xyz/developers/HowTo/slashing/migrate-to-operatorsets).


### Rewards 

Refer to:
* [Rewards concept](concepts/rewards/rewards-concept)
* For developers, [Submit Rewards Submissions](../developers/HowTo/build/submit-rewards-submissions)
* For Operators, [Configure Rewards](../operators/howto/confirgurerewards/set-rewards-split) and [Claim Rewards](https://docs.eigenlayer.xyz/operators/howto/confirgurerewards/set-rewards-split)
* For Stakers, [Claim Rewards](../restakers/restaking-guides/claim-rewards-app)

### Operator Sets

Refer to: 
* [Operator Sets concept](concepts/operator-sets/operator-sets-concept)
* For developers, [Manage Operator Sets](../developers/HowTo/build/manage-operator-sets) and [Migrate to Operator Sets](../developers/HowTo/build/slashing/migrate-to-operatorsets)
* For Operators, [Allocate and Register to Operator Sets](../operators/howto/operator-sets)

### User Access Management (UAM)

Refer to: 
* [UAM Concept](concepts/uam/user-access-management)
* For developers, [Add and Remove Admins](../developers/HowTo/build/uam/dev-add-remove-admins) and [Add and Remove Appointees](../developers/HowTo/build/uam/dev-add-remove-admins)
* For Operators, [Add and Remove Admins](../operators/howto/uam/op-add-remove-admins) and [Add and Remove Appointees](../operators/howto/uam/op-add-remove-appointees)

# Samples

The [Hello World AVS](https://github.com/Layr-Labs/hello-world-avs) and [Incredible Squaring](https://github.com/Layr-Labs/incredible-squaring-avs)
samples are available to for development and testing to get familiar with EigenLayer. We are currently updating these to 
include rewards and slashing capabilities.

---

---
sidebar_position: 2
title: APIs, Dashboards, and Tooling
---

### APIs

- [EigenExplorer API](https://docs.eigenexplorer.com/api-reference/introduction)
- [Dune EigenLayer API](https://docs.dune.com/api-reference/eigenlayer/introduction)

### Dashboards

- [Eigen Economy (maintained by Eigen Labs)](https://economy.eigenlayer.xyz/)
- [EigenExplorer Dashboard](https://dashboard.eigenexplorer.com/)
- [The Ultimate Restaking Dashboard](https://dune.com/hahahash/eigenlayer)
- [AVS Dune Dashboard](https://dune.com/hahahash/avs)
- [EigenLayer Dune dashboard by dyorcrypto](https://dune.com/dyorcrypto/eigenlayer)
- [Validator.info - In-depth real-time EigenLayer analytics](https://validator.info/eigenlayer)
- [Restaking Info by Nethermind](https://restaking.info/)
- [OpenBlock EigenLayer Restaking Dashboard](https://app.openblocklabs.com/app/restaking/eigenlayer)
- [EigenLayer Dashboard](https://daic.capital/projects/eigenlayer)


---

---
sidebar_position: 3
title: EigenLayer Infinite Hackathon
---

The EigenLayer Infinite Hackathon encourages submissions from developers building on EigenLayer, EigenLayer AVSs, EigenDA, and rollups built on EigenDA at any hackathon happening anywhere at any time now and in the future, both in-person and online.

Submit your project [here](https://airtable.com/appnYZo360sWuEYLS/shrrnj9BWIPevjc5c).

If you're in the process of hacking in the EigenLayer ecosystem, join us in the EigenLayer Hacker group chat [here](https://airtable.com/appnYZo360sWuEYLS/shrz6Pstds7EXjC5N)!

![EigenLayer Infinite Hackathon](/img/infinite-hackathon.png)

If you are building within the EigenLayer ecosystem as part of your hackathon project, you are qualified to submit and be eligible for prizes in the following categories.

## 1. AVSs and open source AVS reference architectures

Any new AVS or AVS reference architecture. Emphasis on code quality, documentation quality, and real world utility.

1. Ether - $7,500.00
2. Finney - $5,000.00
3. Gwei - $2,500.00
4. Wei - $1,000.00

To learn more about building AVSs, see [Awesome AVS](https://github.com/Layr-Labs/awesome-avs).

## 2. Apps

Any new application that is built on EigenLayer AVSs or EigenDA rollups. Emphasis on code quality, documentation quality, and real world utility.

1. Ether - $7,500.00
2. Finney - $5,000.00
3. Gwei - $2,500.00
4. Wei - $1,000.00

You can see AVSs live on EigenLayer mainnet [here](https://www.eigenlayer.xyz/ecosystem?category=AVS), and rollups live on EigenDA [here](https://www.eigenlayer.xyz/ecosystem?category=EigenDA).

## 3. EigenDA and rollups

Any new tooling for, or rollups built, on EigenDA. Emphasis on code quality, documentation quality, and real world utility.

1. Ether - $7,500.00
2. Finney - $5,000.00
3. Gwei - $2,500.00
4. Wei - $1,000.00

To learn more about EigenDA, see the documentation [here](https://docs.eigenlayer.xyz/eigenda/overview).

### Eligibility Criteria

Participants of hackathons that are already hosted by, or that include prizes offered by, Eigen Labs or Eigen Foundation are not eligible.

Projects must be submitted within 14 days of original hackathon deadline.

Project code must be open source.

Full Hackathon Terms of Service are available [here](https://docs.google.com/document/d/1ZmW_WakvPobyps5XP_fkNs_AEAyXp-bq/edit?usp=sharing&ouid=115843462632021279280&rtpof=true&sd=true)

---

---
sidebar_position: 1
title: Learning Resources
---

# EigenLayer Learning Resources

### Start here

* [Boys Club Ep 127: What is EigenLayer?](https://open.spotify.com/episode/2aR83WBag0pj0ldRRm2vZD)
* [You Could've Invented EigenLayer (Video)](https://www.youtube.com/watch?v=fCl_PucMytU)
* [The Three Pillars of Programmable Trust: The EigenLayer End Game](https://www.blog.eigenlayer.xyz/the-three-dimensions-of-programmable-trust/)
* [Shared Security: The Four Superpowers](https://twitter.com/sreeramkannan/status/1742949397523304600)

### Blog posts

* [EigenLayer Blog](https://www.blog.eigenlayer.xyz/)
* [You Could've Invented EigenLayer (Blog)](https://www.blog.eigenlayer.xyz/ycie/)
* [The EigenLayer Universe: Ideas for Building the Next 15 Unicorns](https://www.blog.eigenlayer.xyz/eigenlayer-universe-15-unicorn-ideas/)
* [Dual Staking](https://www.blog.eigenlayer.xyz/dual-staking/)
* [EigenLayer for Developers](https://nader.substack.com/p/beyond-restaking-eigenlayer-for-developers)
* [EigenLayer: Intersubjective Faults, Token forking, bEIGEN & more](https://mirror.xyz/edatweets.eth/l3QtrWv-27h5DVkrSdFMq96MRJ8AotemvmZIQ23Ew3A)

### Videos and podcasts

* [Official EigenLayer YouTube](https://www.youtube.com/@EigenLayer)
* [Unchained Podcast EigenLayer interview ](https://www.youtube.com/watch?v=16p7YG8S3ec)
* [EigenLayer in 2024](https://www.youtube.com/watch?v=ms94dx9HvL0)
* [EigenLayer: The Endgame Coordination Layer](https://www.youtube.com/watch?v=o9y_pZUr0Nc)
* [EigenLayer Explained: 4th Paradigm in CryptoEconomic Capital Efficiency](https://www.youtube.com/watch?v=iMFscq9Sxdk)

### Developer resources

Please see Developer Learning Resources [here](/docs/developers/Reference/resources.mdx).

### Community

* [EigenLayer Forum](https://forum.eigenlayer.xyz/)
* [EigenLayer Research Forum](https://research.eigenlayer.xyz/)
* [Build on Eigen group chat](https://airtable.com/appnYZo360sWuEYLS/shrz6Pstds7EXjC5N)
* [Discord](https://discord.com/invite/eigenlayer)
* [EigenLayer Twitter](https://twitter.com/eigenlayer)
* [BuildOnEigen Twitter](https://x.com/buildoneigen)


---

---
sidebar_position: 2
title: EigenLayer Roadmap
---
# EigenLayer Roadmap

EigenLayer is a protocol and developer platform for building, operating, and securing verifiable applications and services 
using Ethereum’s cryptoeconomic security. Developers can create scalable services that verify off-chain actions and enforce 
trust-based commitments. Stakers can restake ETH, liquid staking tokens (LSTs), and ERC-20 assets to secure these services, 
nominate Operators, and access performance data to make informed decisions. Institutional Stakers can participate through 
custodians or liquid restaking tokens integrated with DeFi.

Operators can secure AVSs (Autonomous Verifiable Services), earn rewards, and manage slashing risks with tools for key management,
role delegation, and secure protocol interactions. AVS builders can deploy services, attract Operators, and use EigenLayer’s SDKs,
middleware, and templates to create scalable, composable solutions. Applications built on EigenLayer benefit from seamless AVS 
integration, EigenDA for high-performance data availability, and tools for bootstrapping adoption.

This roadmap outlines **our key development priorities to make EigenLayer’s marketplace even more transparent, rewarding, 
and accessible** for Stakers, Operators, Developers, and Users alike:


<img src="/img/roadmap.png" width="75%" style={{ margin: '50px'}}>
</img>

## Universal Commitments: EigenLayer is the universal commitment marketplace

EigenLayer is pioneering a Commitment Economy offering cryptoeconomic mechanisms with intuitive user experiences to enable
a secure, functional marketplace for trust. Our roadmap for this marketplace centers on:

1. **Security and Flexibility:** EigenLayer will equip AVS builders with adaptable security models, allowing stakers to delegate
stake to operators across multiple AVS ("pooled security"). Stakers should be able to allocate natively-restaked ETH, any ERC-20
token, or assets from L2s and even non-Ethereum chains. They will be able to redelegate stakes, manage slashing risks, and
commit security long-term for added rewards. AVSs should be able to launch across chains and enforce guarantees via operator 
penalties, fund redistribution, and other offchain mechanisms.

2. **Transparency and Accessibility:** EigenLayer will offer transparency to the ecosystem through a unified dashboard displaying
metrics, monitoring and a simple Marketplace UI for restaking. Stakers and Operators will be able to access verified metadata, 
performance history, and accounting tools. Insights into live AVS activity and restaking opportunities will strengthen coordination
and inform decision making.

3. **Expressive:** EigenLayer will enable programmable incentives, allowing AVSs to distribute rewards and Operators to set reward
splits. Rewards should be flexible and expressive, aligning with AVS goals and utility. These systems will create a competitive
marketplace for high-quality Operators while aligning security and participation goals.

### In Progress Features

* **Slashing:** A key deterrent in EigenLayer, penalizing broken commitments between AVSs, Operators, and users. Unique Stake
ensures slashing mitigates risk without systemic impact.

* **Operator Sets:** Segmented Operator groups created by AVSs for business logic, rewards distribution, slashing, and architectural
organization.

* **Rewards Boost:** Enabling EIGEN to be distributed weekly to stakers and operators, proportional to AVS reward distributions.

## Trusted Primitives: EigenLayer has high-quality primitives with full-stack trust

EigenLayer will enable developers to create high-performance, trusted services and applications, by delivering:

1. **EIGEN token forking for full-stack trust:** Existing tokens like ETH and ERC20 tokens, require staking for validation
and can be penalized (slashed) for rule violations, but they are usually special-purpose (tied to a specific task) and objective
(enforceable only when violations have on-chain proofs). We proposed a novel token design for EIGEN, which expands the utility
of the staking token to be both universal (can be used for arbitrary tasks) and intersubjective (slashing enforceable as long
as the violations have offchain observability).

2. **Scalability via EigenDA:** EigenDA provides mechanisms for chains, services and apps to scale via a highly scalable 
data availability layer. EigenDA is live on mainnet, utilizes EIGEN staking and is able to run at 15 MB/s. EigenDA will 
offer integrations with OP Stack, Arbitrum Orbit, and zkSync and offer robust DA guarantees, slashing functionality through 
intersubjective forking, and flexible bandwidth options. EigenLayer Rollapps will have access to restaked services like DA, 
sequencing, and finality gadgets for optimal performance. 

### In Progress Features

* **DA Performance and Robustness:**  A network upgrade with architectural updates and efficient bridging strategies for
improved performance and robustness is being built.

* **Intersubjective Forking:** The first version of the token is live in production for EigenDA and the extension of the 
intersubjective forking to arbitrary tasks built by AVS developers is currently in development.

* **Liquidity incentivization for multiple chains:** Grow EigenDA Total Value Secured & LRT TVL by shipping our liquidity 
incentive program to multiple new partner chains.

## Verifiable Services: EigenLayer is the leading platform for building cloud services that make verifiable commitments

EigenLayer will deliver a stable, intuitive platform, enabling AVS builders to deploy verifiable cloud services efficiently
and enabling operators to manage them securely and reliably. Our roadmap for this developer platform centers on:

1. **Simplified AVS Development:** Clear documentation, templates, and tools for developers, with standardized contracts, 
pre-built integrations, and built-for-purpose services like EigenDA. Plug-and-play templates will handle business logic, 
operator penalties, and workload liveness. An intuitive UI will help developers manage AVS lifecycles with minimal overhead. 
Operators will have tools for onboarding to AVSs, including role-based access controls (RBAC), automated workflows, and a 
self-service portal for AVS evaluation. As our AVS ecosystem grows, EigenLayer will allow developers to integrate and bundle
multiple services easily, enabling faster development.

2. **Management and Monitoring:** Secure, flexible environment to support both AVS builders and Operators. Developers can 
delegate management roles, while Operators will be able to configure and maintain AVS infrastructure with key management, 
service discovery, and risk monitoring tools. The platform will include lifecycle management tooling for AVS services upgrades, 
versioning, and performance monitoring ensuring seamless operations across multiple AVSs.

3. **Cross-Service Coordination:** Modular middleware, task orchestration, and service coordination to support cross-chain
interoperability for AVS builders. Operators will gain visibility into cross-service interactions and dependencies, allowing
them to manage AVSs effectively across multiple networks. As the ecosystem expands, operators will play a crucial role in 
ensuring cross-chain compatibility and service synchronization.

4. **Expressive Incentives and Monitoring:** AVS builders will be able to distribute rewards programmatically, while operators
can monitor rewards, penalties, and staking opportunities. Customizable dashboards, alerts, and notifications will be available
for critical events. Lifecycle tools will help operators manage role delegation and fulfill AVS commitments efficiently.

### In Progress Features
   
* **AVS Lifecycle Management:** Tools to manage AVS registration, upgrades, and version control, to ensure smooth operations 
and easy governance for both builders and operators.

* **Dev Environments:** Mainnet equivalent testnet and developer sandbox environments for AVS builders and operators to 
safely test and debug services.

* **AVS Templates:** Pre-built templates for business logic integration, operator penalties and rewards.

## Get Involved

Eigen Labs is committed to building the EigenLayer protocol and expanding its services. The purpose of this roadmap is to
drive legibility for all of our users into our priorities and goals. We are committing to updating this view regularly to 
provide awareness of our progress.

While some of this work is already in flight, we are looking for feedback and welcome teams who want to contribute to the 
core protocol. To join the conversation about the future of EigenLayer, visit our [Forum](https://forum.eigenlayer.xyz/t/merged-elip-001-rewards-v2/14196).
You can also [check out our GitHub](https://github.com/eigenfoundation/ELIPs) with historical EigenLayer Improvement Proposals (ELIPs). 


---

---
sidebar_position: 2
---

# Audits

As a key component of our development process, please see the most recent audits that help assess the robustness and reliability of our systems:
- [Sigma Prime](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/audits/M2%20Mainnet%20-%20Sigma%20Prime%20-%20Feb%202024.pdf)  
- [Dedaub](https://github.com/Layr-Labs/eigenlayer-middleware/blob/dev/audits/M2%20Mainnet%20-%20Dedaub%20-%20Feb%202024.pdf)
- [Cantina](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/audits/M2%20Mainnet%20-%20Cantina%20-%20Apr%202024.pdf)

Please see the following repositories for all current and past audits:
- [EigenLayer-Contracts / Audits](https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/audits)
- [EigenLayer-Middleware / Audits](https://github.com/Layr-Labs/eigenlayer-middleware/tree/dev/audits)

We encourage you to review all audits carefully as they offer an in-depth analysis of our technology's capabilities, security measures, and overall reliability.

Instructions are also available for [Installation and Running Tests / Analyzers](https://github.com/Layr-Labs/eigenlayer-contracts#installation) via the Github repo.


---

---
sidebar_position: 3
description: Check out the official bug bounty program for EigenLayer on Immunefi
---

# Bug Bounty

Check out the official bug bounty program for EigenLayer on Immunefi:
[https://immunefi.com/bounty/eigenlayer/](https://immunefi.com/bounty/eigenlayer/)


---

---
sidebar_position: 4
---

# Guardrails

There will be a 7-day [withdrawal delay](withdrawal-delay.md) that will serve as a security measure during the early stages of the EigenLayer mainnet, to optimize for the safety of assets. This withdrawal lag, which is common in staking protocols, is required when AVSs go live, as there is a lag to verify that activity associated with any AVS was completed successfully.

---

---
sidebar_position: 1
---

# Governance

Please see [EigenFoundation Governance](https://docs.eigenfoundation.org/category/protocol-governance) for latest information.

---

---
sidebar_position: 5
---

# Withdrawal Delay

EigenLayer contracts feature a withdrawal delay for LST tokens, EIGEN token, and Native Restaking, a critical security measure for instances of vulnerability disclosure or when anomalous behavior is detected by monitoring systems. The delays serve as a preventive mechanism and also allows, in certain cases, to help mitigate protocol attacks. When contracts are paused and withdrawals disabled, the system enables arbitrary state or code changes to the contracts through upgrades. While technically feasible, such interventions are not a routine practice and should be approached with caution.

The Withdrawal Delay is also referred to as the Escrow Period. Please see Restaking [Escrow Period](/docs/restakers/restaking-guides/testnet/README.md#testnet-vs-mainnet-differences) for details on the specific duration.

There are two main caveats to this system. The first is the potential for a vulnerability that can bypass the withdrawal delay. The second is the risk of a flaw in the code managing requests after they have undergone the delay period.

To mitigate these risks, the approach involves optimizing complex code processes before the delay, while ensuring simpler code operations post-delay. This is coupled with the aim of developing a robust and foolproof delay framework, thereby enhancing the overall security and resilience of the system.


---

---
sidebar_position: 1
title: Overview
---

# Introduction

## What is a Node Operator within EigenLayer?

Operators, who can be either individuals or organizations, play an active role in the EigenLayer protocol. By registering within EigenLayer, they enable ETH stakers to delegate their staked assets, whether in the form of native ETH or LSTs. The Node Operators then opt-in to provide a range of services to AVSs, enhancing the overall security and functionality of their networks.


## Operator Eligibility and Restaking Criteria

Becoming an Operator in the EigenLayer ecosystem does not require a specific amount of delegated restaked TVL. Essentially, any Ethereum address can serve as an Operator. An address can function as both a Restaker, engaging in either liquid or native restaking, and as an Operator simultaneously. However, it is important to note that this dual role is not mandatory. An Operator can participate in the EigenLayer network without having any restaked tokens.

Most Operators will receive token delegations sourced from other Restakers within the network, otherwise Operators can choose to self-delegate by allocating their restaked token balance.


## Staker and Operator Roles Clarification

Operators are not required to be Restakers. An Ethereum address can be both a Restaker (via liquid or native restaking) and 
simultaneously an Operator, however this is not a requirement. An Operator can have zero restaked tokens in EigenLayer.

An Operator is required to have tokens delegated to their address. The delegation can come from other Restakers or they 
can self-delegate their restaked token balance.

:::important
If a single address is used for Restaking and Operating activities when an Operator self delegates as a Restaker, the Operator
cannot undelegate from itself, and the Operator can only withdraw restaked funds. To avoid this limitation, use separate addresses
for Restaking and Operating activities when self delegating as a Restaker.
:::

## Rewards
Please see the [rewards claiming](../howto/claimrewards/claim-rewards-cli.mdx) documentation on how to claim rewards.


### Operator Sets

For information on Operator Sets, refer to [Operator Sets concept](../../eigenlayer/concepts/operator-sets/operator-sets-concept.md).




---

---
sidebar_position: 4
title: Operator Keys
---

For information on Operator keys, refer to [Keys](../../eigenlayer/concepts/keys-and-signatures).

For information on key management best practices, refer to: 
* [Node Operators](../howto/managekeys/institutional-operators.md)
* [Solo Stakers](../howto/managekeys/solo-operators.md).

---

---
sidebar_position: 2
title: User Access Management
---

For concept material on User Access Management (UAM) and roles, refer to:
* [User Access Management](../../eigenlayer/concepts/uam/user-access-management.md)
* [Accounts](../../eigenlayer/concepts/uam/uam-accounts.md)
* [Admins](../../eigenlayer/concepts/uam/uam-admins.md)
* [Appointees](../../eigenlayer/concepts/uam/uam-appointees.md)

User Access Management (UAM) enables Operators to set appointees for actions enabling a range of key management solutions to be 
implemented.  For example, from simple (ECDSA key rotation) to complex (upstream smart contract permissioning schemes).

The protocol functions that an Operator can set appointees for are:
* [`AllocationManager.modifyAllocations`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#modifyallocations)
* [`AllocationManager.registerForOperatorSets`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#registerforoperatorsets)
* [`AllocationManager.deregisterFromOperatorSets`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#deregisterfromoperatorsets)
* [`AllocationManager.setAllocationDelay`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/AllocationManager.md#setallocationdelay)
* [`DelegationManager.modifyOperatorDetails`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md#modifyoperatordetails)
* [`DelegationManager.updateOperatorMetadataURI`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md#updateoperatormetadatauri)
* [`DelegationManager.undelegate`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md#undelegate)
* [`RewardsCoordinator.setClaimerFor`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#setclaimerfor)
* [`RewardsCoordinator.setOperatorAVSSplit`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#setoperatoravssplit)
* [`RewardsCoordinator.setOperatorPISplit`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#setoperatorpisplit)
* [`RewardsCoordinator.setOperatorSetSplit`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#setoperatorsetsplit)

For information on how to set admins and appointees for an AVS, refer to:
* [Add and Remove Admins](../howto/uam/op-add-remove-admins.md)
* [Add and Remove Appointees](../howto/uam/op-add-remove-appointees.md)


---

---
sidebar_position: 5
title: Implement Security Best Practices
---

# Operator Security Risks

## Malicious AVS 

- Guest container breaking  into host machine:
    - Kernel Exploits: Containers share the same kernel as the host. If there are vulnerabilities in the kernel, a container might exploit them to gain elevated privileges on the host.
    - Escape to Host: There have been vulnerabilities in the past that allowed processes within a container to escape and get access to the host. This is especially dangerous if containers are run with elevated privileges.
    - Inter-container Attacks: If one container is compromised, an attacker might try to move laterally to other containers on the same host.

- Access to the host’s network. Because containers run in a home stakers environment, they have access to a home network or a k8s environment.
- Malware in the container or via a supply chain attack or AVS is malicious.



## AVS Implementation and Deployment Bugs

- Running outdated software.
- Misconfigured ports and services open to the internet.
- Running containers with elevated privileges.


# What can operators do to mitigate malicious AVS risks?
## Operator Best Practices

- Regularly update and patch containers and the host system.
- Don't share your keys between AVSs / ETH validator. Refer to key management section.
- Monitor container runtime (logs) behavior for any suspicious activities and setup alerts as relevant.
- Do not run containers with privileged flag.It can give them almost unrestricted access to the host.
- Limit Resources to a container so it doesn’t take down the cluster / node
- Data Theft: Do not mount entire volumes into containers to prevent data leak, container escapes etc.
- Follow Network Access / Least privilege principles in your organization to reduce attack surface

## Infrastructure

General
- Only allow Network traffic to ports / from whitelisted ip's required by the AVS.
- Do not expose critical services like ssh to the internet.
- Configure your firewall with a DENY ALL approach and explicitly allow traffic that is required.
  
Docker Infra
- Network Segmentation: Use Docker's network policies to segment containers  and limit inter-container communication.
- Regular Audits: audit and monitor container activities using tools like - Docker Bench for Security or Clair.
- Isolation
    - Through VMs: lightweight VMs (like Kata Containers or gVisor) combine container - flexibility with VM isolation.
    - User namespaces, seccomp, AppArmor, and SELinux etc can help further restrict the container.

K8’s Infra
- Network Segmentation: Limit the services your AVSs can talk to. Follow least privilege principles via [Kubernetes Documentation Network Policies](https://kubernetes.io/docs/concepts/services-networking/network-policies/).

Incident Response Plan: 
- Have a plan in place for how to respond if a container is compromised. This includes isolating affected containers, analyzing, and restoring services.
- Regular Backups: Regularly backup your data and configurations to recover from any malicious changes.
- Stay Updated: Always keep an eye on Docker's official documentation, security advisories, and community forums for the latest best practices and updates.









---

---
sidebar_position: 3
title: Batch Claim Rewards
---

Batch rewards claiming for Stakers and Operators using the EigenLayer CLI is a gas efficient way to claim on behalf 
of multiple Earners in a single transaction.

To batch claim rewards, use the `-–batch-claim-file` option:

`eigenlayer rewards claim --earner-address 0x025246421e7247a729bbcff652c5cc1815ac6373 --eth-rpc-url http://rpc-url --network holesky --batch-claim-file samples/batch-claim.yaml`

The batch claim yaml file includes the Earner addresses, and token addresses for which to claim. For example:

```yaml
- earner_address: "0x025246421e7247a729bbcff652c5cc1815ac6373"
  token_addresses:
    - "0x3B78576F7D6837500bA3De27A60c7f594934027E"
- earner_address: "0x025246421e7247a729bbcff652c5cc1815ac6373"
  token_addresses:
    - "0x3B78576F7D6837500bA3De27A60c7f594934027E"
```

---

---
sidebar_position: 1
title: Claim Rewards
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Prerequisites
* EigenLayer CLI installed.
* Wallet keys for the Earner or Claimer address accessible to the CLI.

### Earner

To claim rewards using the EigenLayer CLI as an [Earner](../../../eigenlayer/concepts/rewards/earners-claimers-recipients.md):

1. Check if rewards are available to claim.

<Tabs groupId="network">
  <TabItem value="mainnet" label="Mainnet">
    ```bash
    ./bin/eigenlayer rewards show \
      --network mainnet \
      --earner-address <earner-address> \
      --claim-type unclaimed

    ```

  </TabItem>
  <TabItem value="sepolia" label="Sepolia">
    ```bash
    ./bin/eigenlayer rewards show \
      --network sepolia \
      --earner-address <earner-address> \
      --claim-type unclaimed
    ```
  </TabItem>
</Tabs>

The token addresses and associated unclaimed rewards are displayed.

```bash
---------------------------------------------------------------------------------------
Token Address                              | Wei Amount
---------------------------------------------------------------------------------------
0x554c393923c753d146aa34608523ad7946b61662 | 6324648267039518
0xdf3b00151bf851e8c4036ceda284d38a2f1d09df | 132817613607829878
---------------------------------------------------------------------------------------
```

2. If using a local keystore file:

<Tabs groupId="network">
  <TabItem value="mainnet" label="Mainnet">

    ```bash
    ./bin/eigenlayer rewards claim \
      --network mainnet \
      --eth-rpc-url <mainnet-eth-rpc-url> \
      --earner-address <earner-address> \
      --recipient-address <address-to-send-rewards-to> \
      --path-to-key-store /path/to/key/store-json \
      --token-addresses <comma-separated-list-of-token-addresses> \
      --broadcast
    ```

  </TabItem>
  <TabItem value="sepolia" label="Sepolia">

    ```bash
    ./bin/eigenlayer rewards claim \
      --network sepolia \
      --eth-rpc-url <sepolia-eth-rpc-url> \
      --earner-address <earner-address> \
      --recipient-address <address-to-send-rewards-to> \
      --path-to-key-store /path/to/key/store-json \
      --token-addresses <comma-separated-list-of-token-addresses> \
      --broadcast
    ```
    `comma-separated-list-of-token-addresses` - You can get this from output of Step 3
  </TabItem>
</Tabs>

Where: 
* `earner-address` - [Earner](../../../eigenlayer/concepts/rewards/earners-claimers-recipients.md) with wallet keys accessible to the CLI. 
* `token-addresses` - Token addresses from output of previous step. 
* `recipient-address` - Address to receive the Rewards. The default is the [Earner](../../../eigenlayer/concepts/rewards/earners-claimers-recipients.md).

If you are using private key hex, Fireblocks or Web3Signer for key management, refer to the CLI help for the respective key manager.

```bash
./bin/eigenlayer rewards claim --help
```

### Claimer

To claim rewards using the EigenLayer CLI as a [Claimer](../../../eigenlayer/concepts/rewards/earners-claimers-recipients.md),
use the same commands as for Earner except specify the `claimer-address` option instead of the `earner-address` option.

---

---
sidebar_position: 3
title: Claim Rewards as a Smart Contract
---

To claim rewards when the [Earner](../../../eigenlayer/concepts/rewards/earners-claimers-recipients.md) is a smart contract, 
generate either:
* JSON object with the arguments to call [`RewardsCoorinator.processClaim`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#processclaim).
* Calldata that can be signed and broadcast.

## JSON Object

To generate the JSON object, use:
```bash
    ./bin/eigenlayer rewards claim \
      --network mainnet \
      --eth-rpc-url <mainnet-eth-rpc-url> \
      --earner-address <earner-address> \
      --recipient-address <address-to-send-rewards-to> \
      --path-to-key-store /path/to/key/store-json \
      --token-addresses <comma-separated-list-of-token-addresses> \
      --output-type json
```

## Calldata

To generate the calldata, use:

```bash
    ./bin/eigenlayer rewards claim \
      --network mainnet \
      --eth-rpc-url <mainnet-eth-rpc-url> \
      --earner-address <earner-address> \
      --recipient-address <address-to-send-rewards-to> \
      --path-to-key-store /path/to/key/store-json \
      --token-addresses <comma-separated-list-of-token-addresses> \
      --output-type calldata
```

---

---
sidebar_position: 4

---

# Rewards Distribution Data

Rewards snapshot distribution data is available:
* From an [EigenLayer Sidecar](#using-eigenlayer-sidecar).
* Via a [public S3 bucket](#via-s3-bucket). Users may access this data for their own analytics purposes.

## Using EigenLayer Sidecar

The [EigenLayer Sidecar](https://sidecar-docs.eigenlayer.xyz/docs/sidecar/running/getting-started) is an open source, permissionless, verified indexer enabling anyone (for example AVS, Operator) to access 
EigenLayer’s protocol rewards in real-time.

For information on how to install and launch a Sidecar, refer to the [Sidecar documentation](https://sidecar-docs.eigenlayer.xyz/docs/sidecar/running/getting-started).

There are two methods to access the rewards data from a Sidecar:
* Terminal or a bash script with `curl` and `grpcurl`.
* Using the gRPC or HTTP clients published in the [protocol-apis](https://github.com/Layr-Labs/protocol-apis) Go package.

Refer to the [sidecar](https://github.com/Layr-Labs/sidecar) repository for [examples](https://github.com/Layr-Labs/sidecar/blob/master/examples/rewardsData/main.go).

To obtain rewards snapshot distribution data using a EigenLayer Sidecar:

1. List distribution roots. 
   ``` 
   # grpcurl
   grpcurl -plaintext -d '{ }' localhost:7100 eigenlayer.sidecar.v1.rewards.Rewards/ListDistributionRoots | jq '.distributionRoots[0]'

   # curl
   curl -s http://localhost:7101/rewards/v1/distribution-roots

   {
     "root": "0x2888a89a97b1d022688ef24bc2dd731ff5871465339a067874143629d92c9e49",
     "rootIndex": "217",
     "rewardsCalculationEnd": "2025-02-22T00:00:00Z",
     "rewardsCalculationEndUnit": "snapshot",
     "activatedAt": "2025-02-24T19:00:48Z",
     "activatedAtUnit": "timestamp",
     "createdAtBlockNumber": "3418350",
     "transactionHash": "0x769b4efbefb99c6c80738405ae5d082829d8e2e6f97ee20da615fa7073c16d90",
     "blockHeight": "3418350",
     "logIndex": "544"
   }
   ```
2. Use the `rootIndex` to fetch the rewards data.
   ```
   # grpcurl
   grpcurl -plaintext --max-msg-sz 2147483647 -d '{ "rootIndex": 217 }' localhost:7100 eigenlayer.sidecar.v1.rewards.Rewards/GetRewardsForDistributionRoot > rewardsData.json

   # curl
   curl -s http://localhost:7101/rewards/v1/distribution-roots/217/rewards > rewardsData.json

   {
    "rewards": [
     {
      "earner": "0xe44ce641a7cf6d52c06c278694313b08c2b181c0",
      "token": "0x3b78576f7d6837500ba3de27a60c7f594934027e",
      "amount": "130212752259281570",
      "snapshot": "2025-02-22T00:00:00Z"
     },
    // ...
    ]
   }
   ```

## Via S3 Bucket

To obtain rewards snapshot distribution data from the S3 bucket: 

To get a list of snapshot dates from RewardsCoordinator contract:

1. Find the RewardsCoordinator Proxy address for Testnet or Mainnet [here](https://github.com/Layr-Labs/eigenlayer-contracts/?tab=readme-ov-file#deployments).
    1. Get the DistributionRoot(s) needed for the rewards time ranges desired.
       * Call `getCurrentDistributionRoot` to get the most recent root posted. `getCurrentClaimableDistributionRoot` returns the most recent claimable root since there is an activation delay.
       * Find the rewardsCalculationEndTimestamp value as the second value in the [DistributionRoot struct](https://github.com/Layr-Labs/eigenlayer-contracts/blob/b4fa900a11df04f3b0034e225deb1eb42b39f8bc/src/contracts/interfaces/IRewardsCoordinator.sol#L72) resulting tuple.
       * Or Index on the event `DistributionRootSubmitted` which is emitted when a [root is created](https://etherscan.io/tx/0x2aff6f7b0132092c05c8f6f41a5e5eeeb208aa0d95ebcc9022d7823e343dd012#eventlog).
       * Note: the current snapshot cadence is at most once per day for Testnet, weekly for Mainnet if there are new rewards to publish ([more detail here](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/RewardsCoordinator.md#off-chain-calculation)).
   2. Convert this rewardsCalculationEndTimestamp value from unix time stamp integer format to the date format YYYY-MM-DD using a conversion tool ([example here](https://www.unixtimestamp.com/)).

2. Construct the URL to return the claim-amounts.json file for the desired snapshot date in the following format:

`<bucket url>/<environment>/<network>/<snapshot date>/claim-amounts.json`

* bucket_url: 
  * [https://eigenlabs-rewards-testnet-holesky.s3.amazonaws.com](https://eigenlabs-rewards-testnet-holesky.s3.amazonaws.com)
  * [https://eigenlabs-rewards-mainnet-ethereum.s3.amazonaws.com](https://eigenlabs-rewards-mainnet-ethereum.s3.amazonaws.com)
* environment: testnet or mainnet
* network: holesky or ethereum

Example:

`https://eigenlabs-rewards-mainnet-ethereum.s3.amazonaws.com/mainnet/ethereum/2024-08-11/claim-amounts.json`

Extract data from the claim-amounts.json file as needed. Please find the schema here:

```

{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "EigenLayer rewards cumulative earnings",
  "type": "object",
  "properties": {
    "earner": {
      "type": "string",
      "description": "Ethereum address"
    },
    "token": {
      "type": "string",
      "Ethereum address"
    },
    "snapshot": {
      "type": "number",
      "Unix timestamp of the snapshot date in UTC"
    },
    "cumulative_amount": {
      "type": "string",
      "Cumulative amount of tokens earned over time (includes both claimed and unclaimed rewards)"
    }
  },
  "required": [
    "earner",
    "token",
    "snapshot",
    "cumulative_amount"
  ]
}
```

Note: claim-amounts.json file is not a json file, but a json line file where each line is a valid json object.


---

---
sidebar_position: 2
title: Set Programmatic Incentives Split
---

The default [Operator split for Programmatic Incentives (PI) is 10%](../../../eigenlayer/concepts/rewards/pi-split.md).

## Get Current PI Split

To obtain the current PI split, use:

`eigenlayer operator get-pi-split [options]` with

* `operator-address` - Operator address for which to get the operator split

To get the default split at the protocol level, use `eigenlayer operator get-pi-split` without specifying
`operator-address`.

The current split is returned in bips (1000 bips = 10%, 10000 bips = 100%).

## Update PI Split

To update the PI split by Operator, use:

`eigenlayer operator set-pi-split [options]` with

* `operator-address` - Operator address for which to update the PI split
* `operator-split` - Split to set for the Operator in bips

---

---
sidebar_position: 3
title: Set Rewards Claimer
---

## Prerequisites

* EigenLayer CLI installed.
* Wallet keys for the Earner address accessible to the CLI.

## Set Claimer Address

To set an address as the [Claimer for an Earner](../../../eigenlayer/concepts/rewards/earners-claimers-recipients.md), use:

`eigenlayer rewards set-claimer [options]` with 

* `earner-address` - Address of the Earner
* `claimer-address` - Address of the Claimer

---

---
sidebar_position: 1
title: Set Rewards Split
---

The default Operator split for rewards is 10%. [The Operator split can be varied by AVS or by Operator Set](../../../eigenlayer/concepts/rewards/rewards-split.md).

## Get Current AVS Rewards Split

To obtain the current AVS rewards split, use:

`eigenlayer operator get-rewards-split [options]` with:

* `avs-address` - AVS address for which to get the operator split
* `operator-address` - Operator address for which to get the operator split

To get the default split at the protocol level, use `eigenlayer operator get-rewards-split` without specifying `avs-address`
or `operator-address`.

The current split is returned in bips (1000 bips = 10%, 10000 bips = 100%).

## Update AVS Rewards Split

To update the AVS rewards split, use:

`eigenlayer operator set-rewards-split [options]` with:
* `avs-address` - AVS address for which to update the Operator split
* `operator-address` - Operator address for which to update the Operator Set split
* `operator-split` - Split to set for the Operator in bips for the specified AVS

Changes to the Rewards split take effect after a 7-day activation delay. Only one split can be pending.  That is, any pending
Rewards split must be completed before setting a new Rewards split.

## Get Current Operator Set Rewards Split

To obtain the current Operator Set rewards split, use:

`eigenlayer operator get-operatorset-split [options]` with:

* `avs-address` - AVS address for which to get the operator split
* `operator-address` - Operator address for which to get the operator split
* `operatorset-id` - Operator Set ID for which to get the split

The current split is returned in bips (1000 bips = 10%, 10000 bips = 100%).

## Update Operator Set Rewards Split

To update the Operator Set rewards split, use:

`eigenlayer operator set-operatorset-split [options]` with
* `avs-address` - AVS address for which to update the Operator Set split
* `operator-address` - Operator address for which to update the Operator Set split
* `operatorset-id` - Operator Set ID for which to update the split
* `operator-split` - Split to set for the Operator in bips for the specified Operator Set

Changes to the Rewards split take effect after a 7-day activation delay. Only one split can be pending.  That is, any pending
Rewards split must be completed before setting a new Rewards split. 


---

---
sidebar_position: 2
title: Node and Smart Contract Operators
---

# Key Management Best Practices for Node Operators

- Secure keys, including secrets such as passphrases or mnemonics, using services like AWS Secrets Manager or Hashicorp Vault. These services can be seamlessly integrated with automated mechanisms that safely retrieve secrets or keys (e.g., remote signers). If resources permit, consider running your own Hashicorp Vault instance, which grants full custody of keys and secrets while sacrificing the service provider's availability and security guarantees.
- Avoid generating all keys with the same mnemonic. Minimize the attack surface by employing a new mnemonic for every 200 or 1000 validator keys, depending on your preference. This approach also reduces the risk of losing key generation capabilities if a single mnemonic is lost, and limits the impact if an attacker gains access to a few mnemonics.
- Given that AVS keys are likely to be much fewer, not using the same seed to generate the keys is probably safer; generate each AVS key independently if possible.
- Use a remote signer like **[Web3signer](https://github.com/ConsenSys/web3signer)** or, better yet, distributed signers to eliminate single points of failure.
- Develop a custom solution involving tailor-made tools. For instance, use Web3signer for remote signing and store keys on AWS Secrets Manager. A custom tool can manage automatic key storage in Secrets Manager and facilitate interactions with Web3signer.

# Smart Contract Operators

We encourage institutional operators to register with EigenLayer using an [erc-1271](https://eips.ethereum.org/EIPS/eip-1271) smart contract wallet. This allows a lot more fine-grained control, such as multisig authorization and key rotation, which is currently not possible for EOA operators.

---

---
sidebar_position: 3
id: solo-stakers
title: Solo stakers
---

# Key Management Best Practices for Solo Stakers

Individuals managing a limited number of validator keys typically do not require intricate distributed infrastructure for running nodes or employing remote signers. For these individuals, extensive staking services may be excessive and unnecessary. This means they will often store the keys with the decryption keys locally with the validator client or Node (which they maintain), which increases the vulnerability of the secrets, but, while stakers must safeguard validator keys against attacks, most key losses typically result from mundane reasons, such as losing the hardware containing the key. Users necessitate a backup strategy, mindful that if an attacker accesses the backed-up keys, they can sign any message deemed valid against the validator's public key. Appropriate precautions should be implemented to guarantee that backed-up validator keys are as inaccessible as feasible, ideally being completely offline and physically secure. Some of these precautions can be listed:

- Use hardware wallets: Store backed-up keys on secure hardware wallets such as Ledger or Trezor devices. These wallets provide an additional layer of protection by isolating the keys from internet-connected devices.
- Create multiple backups: Generate multiple copies of your backed-up keys and store them in separate, secure locations, such as safety deposit boxes, fireproof safes, or encrypted USB drives.
- Encrypt backups: Ensure your backed-up keys are encrypted using robust encryption algorithms. This protects the keys from unauthorized access in case the storage medium falls into the wrong hands.
- Implement physical security: Ensure the stored locations for backed-up keys are secure, with controlled access and protection against theft or damage.
- Regularly test recovery: Periodically test the recovery of your backed-up keys to ensure that they remain accessible and functional in case of an emergency.
- Employ secure communication channels: When transferring backed-up keys, use secure communication methods such as end-to-end encrypted messaging or other secure channels to prevent interception by malicious actors.
- Limit access: Restrict access to backed-up keys to a select few trusted individuals, and consider implementing a multi-signature scheme to require multiple parties for key recovery.
- Maintain secrecy: Avoid discussing the location or existence of your backed-up keys with others, and do not store any written records that could lead an attacker to their location.
- Continuously update security measures: Regularly assess and update the security measures in place to protect your backed-up keys, staying informed about the latest threats and best practices.
- Use an air-gapped device: Consider using an air-gapped device, such as a computer not connected to the internet, to store backed-up keys. This provides an additional layer of security against remote attacks. Use USB devices or QR codes for sharing the keys with the air-gapped device.

## Securing Mnemonic or Seed Phrases for Key Generation

The mnemonic (if applicable) or seed phrase utilized for generating keys should not be stored on any device, and the aforementioned precautions should be taken into account for safekeeping. Avoid key generation tools that write the mnemonic to the Terminal, an insecure buffer, or a file. Aim to generate keys on an air-gapped device, ensuring the mnemonic and passphrase are securely stored or loaded into memory.


---

---
sidebar_position: 6
title: Follow Webapp Content Guidelines
---

# Webapp Content Guidelines

## Operator Page

The following are guidelines (**“Guidelines”**) for what content Operators should include in their listing of their Operator on app.eigenlayer.xyz (the “**App**”). These Guidelines are intended to help ensure that Operators are providing relevant information from which restakers can select an Operator. 

The content in the Operator tile may include the following: 
- Factual information relating to:
    - The company or team running the Operator
    - The technical ability or experience relevant to the competence of the Operator 
- Links to website or social profiles associated with the Operator
- Logos associated with the Operator

The following content is **<ins>not permitted</ins>** to be displayed in the Operator tile:
- Any offer or promotion of illegal activities
- Any (i) vulgar or profane language or content or (ii) links to vulgar or profane content
- Promotions or incentives for stakers including offering of tokens
- Any false or misleading content
- Any links to content that is not owned or controlled by the Operator 
- Any links to social profiles other than those associated with the Operator
- Any content that violates the intellectual property rights of any other person or entity (including using the branding or logo of EigenLayer or Eigen Labs)
- Anything violating the [Terms of Service](/docs/eigenlayer/legal/terms-of-service.md)


Eigen Labs, Inc. (“**Eigen Labs**”) reserves the right to update these Guidelines at any time and without notice. If you violate these Guidelines, Eigen Labs may delist you or otherwise decrease your visibility on the App. 

## Reporting a Violation or Remediation of Guidelines

Please use our [Support channel](https://support.eigenlayer.xyz/) for reporting either of the following:
- Operator violations of Webapp Content Guidelines.
- Appeal to review and whitelist an Operator who has remediated their violation of the guidelines.

Click on the Intercom chat icon in the bottom right of your screen, then choose “Create a Ticket: Operator Blocklist”.



---

---
sidebar_position: 1
title: Install and register Operators
---

# Installation and Registration

## Node Operator Checklist

### **Software Requirements**

- Docker: Ensure that Docker is installed on your system. To download Docker, follow the instructions listed [here](https://docs.docker.com/get-docker/).
- Docker Compose: Make sure Docker Compose is also installed and properly configured. To download Docker Compose, follow the instructions listed [here](https://docs.docker.com/compose/install/).
- Linux Environment: EigenLayer is supported only on Linux. Ensure you have a Linux environment, such as Docker, for installation.
  - If you choose to install eigenlayer-cli using the Go programming language, ensure you have Go installed, version 1.21 or higher. You can find the installation guide [here](https://go.dev/doc/install).

---

### Checking for Requirements

On a native Linux system, you can use the lsb_release -a command to get information about your Linux distribution.

**Check for Docker**
If you are not using a native Linux system and want to use EigenLayer, you can check if Docker is installed:

- Open a terminal or command prompt.
- Run the following command to check if Docker is installed and running:`css`

```
docker --version
```

If Docker is installed and running, EigenLayer can be used within a Docker container, which provides a Linux environment.

By following these steps, you can determine if you have a suitable Linux environment for EigenLayer installation.

---

## CLI Installation

### Install CLI using Binary

To download a binary for latest release, run:

```
curl -sSfL https://raw.githubusercontent.com/layr-labs/eigenlayer-cli/master/scripts/install.sh | sh -s
```

The binary will be installed inside the `~/bin` directory.

To add the binary to your path, run:

```
export PATH=$PATH:~/bin
```

#### Install CLI in A Custom Location

To download the binary in a custom location, run:

```
curl -sSfL https://raw.githubusercontent.com/layr-labs/eigenlayer-cli/master/scripts/install.sh | sh -s -- -b <custom_location>
```

---

### Install CLI Using Go

Now we’re going to install the eigenlayer-CLI using Go. The following command will install eigenlayer’s executable along with the library and its dependencies in your system.

```
go install github.com/Layr-Labs/eigenlayer-cli/cmd/eigenlayer@latest
```

To check if the GOBIN is not in your PATH, you can execute `echo $GOBIN` from the Terminal. If it doesn't print anything, then it is not in your PATH. To add GOBIN to your PATH, add the following lines to your $HOME/.profile:

```
export GOBIN=$GOPATH/bin
export PATH=$GOBIN:$PATH
```

Changes made to a profile file may not apply until the next time you log into your computer. To apply the changes immediately, run the shell commands directly or execute them from the profile using a command such as source $HOME/.profile.

---

### Install CLI from Source

To pursue this installation method you need to have Go. Please ensure that you installed Go with a minimum version of 1.21 [here](https://go.dev/doc/install).

With this method, you generate the binary manually, downloading and compiling the source code.

```
git clone https://github.com/Layr-Labs/eigenlayer-cli.git
cd eigenlayer-cli
mkdir -p build
go build -o build/eigenlayer cmd/eigenlayer/main.go
```

or if you have **make** installed:

```
git clone https://github.com/Layr-Labs/eigenlayer-cli.git
cd eigenlayer-cli
make build
```

The executable will be in the build folder.

In case you want the binary in your PATH (or if you used the [Go](https://github.com/Layr-Labs/eigenlayer-cli#install-eigenlayer-cli-using-go) method and you don't have $GOBIN in your PATH), please copy the binary to /usr/local/bin:

---

## Create and List Keys

ECDSA keypair corresponds to the operator Ethereum address and key for interacting with Eigenlayer. The BLS key is used for attestation purposes within the EigenLayer protocol. BLS key is used when you register an AVS to EigenLayer.

### Create Keys

Generate encrypted ECDSA and BLS keys using the CLI:

```
eigenlayer operator keys create --key-type ecdsa [keyname]
eigenlayer operator keys create --key-type bls [keyname]
```

- `[keyname]` - This will be the name of the created key file. It will be saved as `<keyname>.ecdsa.key.json` or `<keyname>.bls.key.json`.

This will prompt a password which you can use to encrypt the keys. Keys will be stored in a local disk and will be shown once keys are created. It will also show the private key only once, so that you can back it up in case you lose the password or key file.

You can also create keys by piping your password to this command. This can help in automated key creation and will not prompt for password. This support got added in [v0.6.2](https://github.com/Layr-Labs/eigenlayer-cli/releases/tag/v0.6.2)
```
echo "password" | eigenlayer operator keys create --key-type ecdsa [keyname]
```

#### Input Command

```
eigenlayer operator keys create --key-type ecdsa test
```

The tool is requesting a password to encrypt the ECDSA private key for security purposes. The password input is hidden for security reasons.

#### Output

```
? Enter password to encrypt the ecdsa private key:
ECDSA Private Key (Hex):  b3eba201405d5b5f7aaa9adf6bb734dc6c0f448ef64dd39df80ca2d92fca6d7b
Please backup the above private key hex in safe place.

Key location: /home/ubuntu/.eigenlayer/operator_keys/test.ecdsa.key.json
Public Key hex:  f87ee475109c2943038b3c006b8a004ee17bebf3357d10d8f63ef202c5c28723906533dccfda5d76c1da0a9f05cc6d32085ca1af8aaab5a28171474b1ad0aa68
Ethereum Address 0x6a8c0D554a694899041E52a91B4EC3Ff23d8aBD5

```

### Import Keys

You can import existing ECDSA and BLS keys using the CLI, which are required for operator registration and other on-chain operations. This is useful if you already have an address which you want to use as your operator.

To import an ECDSA key, use the command: `eigenlayer operator keys import --key-type ecdsa [keyname] [privatekey]`.

To import a BLS key, use the command: `eigenlayer operator keys import --key-type bls [keyname] [privatekey]`.

- `[keyname]` is the name of the imported key file, and it will be saved as `<keyname>.ecdsa.key.json` or `<keyname>.bls.key.json`.
- `privatekey` is the private key of the key you wish to import.
  - For BLS keys, it should be a large number.
  - For ECDSA keys, it should be in hex format.


You can also import keys by piping your password to this command. This can help in automated key creation and will not prompt for password. This support got added in [v0.6.2](https://github.com/Layr-Labs/eigenlayer-cli/releases/tag/v0.6.2)
```
echo "password" | eigenlayer operator keys import --key-type ecdsa [keyname] [privatekey]
```

#### Input Command

This part of the command tells the EigenLayer tool that you want to import a key.

```
eigenlayer operator keys import --key-type ecdsa test 6842fb8f5fa574d0482818b8a825a15c4d68f542693197f2c2497e3562f335f6
```

#### Output

This is a prompt asking you to enter a password to encrypt the ECDSA private key.

```
? Enter password to encrypt the ecdsa private key: *******
ECDSA Private Key (Hex):  6842fb8f5fa574d0482818b8a825a15c4d68f542693197f2c2497e3562f335f6
Please backup the above private key hex in safe place.

Key location: /home/ubuntu/.eigenlayer/operator_keys/test.ecdsa.key.json
Public Key hex:  a30264c19cd7292d5153da9c9df58f81aced417e8587dd339021c45ee61f20d55f4c3d374d6f472d3a2c4382e2a9770db395d60756d3b3ea97e8c1f9013eb1bb
Ethereum Address 0x9F664973BF656d6077E66973c474cB58eD5E97E1

```

This will initiate a password prompt that you can use to encrypt the keys. The keys will be stored on your local disk and will be displayed after they are created.

The private key will also be shown only once, enabling you to create a backup in case you forget the password or lose the key file.

### List Keys

This is the command you can use to retrieve a list of the keys you have created with the EigenLayer cli tool.

```
eigenlayer operator keys list
```

When you run the Eigenlayer operator keys list command, it will display a list of all the keys that were generated using this specific command, along with their corresponding public keys.

This information can be useful for managing and identifying the keys you've created. Public keys are typically used for encryption, authentication, and verifying digital signatures.

### Export keys
If you want to see the private key of the existing keys, you can use the below command. This will only work if your keys are in default location (`~/.eigenlayer/operator_keys`)

```
eigenlayer operator keys export --key-type ecdsa [keyname]
```

This will also prompt for the password used to encrypt the key.

If your keys is not in the default location, you can give the full path to the key file using --key-path flag. You don't need to provide the key name in that case.

```
eigenlayer operator keys export --key-type ecdsa --key-path [path]
```

---

## Fund ECDSA Wallet

Send **at least 1 ETH** to the “address” field referenced in your operator.yaml file. This ETH will be used to cover the gas cost for operator registration in the subsequent steps.

If you are deploying to Testnet, please follow the instructions in [Obtaining Testnet ETH](https://docs.eigenlayer.xyz/restaking-guides/testnet/obtaining-testnet-eth-and-liquid-staking-tokens-lsts) to fund a web3 wallet with HolEth.


---

## Operator Configuration and Registration


**Step 1:** Create the config files needed for operator registration using the below command:

```
eigenlayer operator config create
```

When prompted for operator address, make sure your operator address is same as the ecdsa key address you created/imported in key creation steps. 

The command will create two files: `operator.yaml` and `metadata.json`.

**Step 2:** Upload Logo Image, Configure `metadata.json`, and Upload Both

Upload the logo of the operator to a publicly accessible location and set the url in your `metadata.json` file. Operator registration only supports `.png` images for now and must be less than 1MB in size.

The `name` and `description` should comply with the regex mention [here](https://github.com/Layr-Labs/eigensdk-go/blob/master/utils/utils.go#L29). You can use services like https://regex101.com/ to validate your fields. 

Complete your the details in `metadata.json`.  The `metadata.json` must be less than 4KB in size. Upload the file to a publicly accessible location and set that url in `operator.yaml`. Please note that a **publicly accessible** metadata url is required for successful registration. An example operator.yaml file is provided for your reference here: [operator.yaml](https://github.com/Layr-Labs/eigenlayer-cli/blob/master/pkg/operator/config/operator-config-example.yaml) .


:::info
For Mainnet Operators - the `metadata.json` and operator logo .png files MUST be hosted via github.com repositories specifically. Caveat: **gist.github.com** hosted files are not permitted.
These requirements do not apply to Testnet Operators.
:::

:::warning
When using Github for hosting please ensure you link to the raw file ([example](https://raw.githubusercontent.com/Layr-Labs/eigenlayer-cli/master/pkg/operator/config/metadata-example.json)), rather than the github repo URL ([example](https://github.com/Layr-Labs/eigenlayer-cli/blob/master/pkg/operator/config/metadata-example.json)).
:::


**Step 3:** Configure RPC Node:  

The EigenLayer CLI requires access to an Ethereum RPC node in order to post registration. Please plan to either leverage an RPC node provider or run your own local RPC node to reference in operator.yaml.


Please find example lists of RPC node providers here:
- https://chainlist.org/
- https://www.alchemy.com/list-of/rpc-node-providers-on-ethereum


Ensure that your Operator server can reach your RPC provider at this point. You may run the following command from your Operator server:
`curl -I [your_server_url]`




**Step 4:** DelegationManager Contract Address

You must configure the correct DelegationManager contract address for your environment.
- Navigate to [EigenLayer Contracts: Deployments](https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments) and locate the Proxy address for `DelegationManager` for your environment (Mainnet, Testnet).
- Set the value for `el_delegation_manager_address` in your operator config file to the address for your environment.


**Optional:** Set Delegation Approver

Operators have the option to set [delegationApprover](https://github.com/Layr-Labs/eigenlayer-contracts/blob/mainnet/src/contracts/interfaces/IDelegationManager.sol#L30) when they register. If the `delegationApprover` is set to a nonzero value, then the `delegationApprover` address will be required sign its approval of new delegations from Stakers to this Operator. If the default value is left as the zero address (0x000...) then all new delegations will be automatically approved without the need for any signature. Please see [delegationApprover Design Patterns](#delegationapprover-design-patterns) below for more detail.

 The EigenLayer Web App simulates transactions to check for contract reversions. If the delegate call will revert for any reason the button will be disabled.





**Step 5:** Registration Command

This is the command you can use to register your operator.

```
eigenlayer operator register operator.yaml
```

:::note
ECDSA key is required for operator registration. You may choose to either: 
* [_create_](https://github.com/Layr-Labs/eigenlayer-cli/blob/master/README.md#create-keys) your own set of keys using the EigenLayer CLI (if you have not previously created keys).
* [_import_](https://github.com/Layr-Labs/eigenlayer-cli/blob/master/README.md#import-keys) your existing keys (if you have previously created keys).
:::

---

## Checking Status of Registration

This is the command you can use to inquire about the registration status of your operator.

```
eigenlayer operator status operator.yaml
```

---

## Metadata Updates
### General metadata update
This is the command you can use to make changes or updates to the metadata of your operator. Post v0.9.0, this command will not update metadata uri. Please use [below](#update-metadata-uri-post-v090) command to update it. 

```
eigenlayer operator update operator.yaml
```

### Update metadata URI (Post v0.9.0)
In [v0.9.0](https://github.com/Layr-Labs/eigenlayer-cli/releases/tag/v0.9.0), we have introduced a new command to update metadata uri.

```
eigenlayer operator update-metadata-uri operator.yaml
```



## delegationApprover Design Patterns

Delegation Approver functionality can be used in multiple ways to give Operators additional programmatic control over which Restakers they accept delegation from.


### Passing Signatures from the DelegationApprover to Stakers

One series of designs involves passing a unique signature from the Operator to the Restaker requesting approval. The unique signature will have a corresponding ‘salt’ (unique value used once) and an ‘expiry’. The Restaker passes the signature (salt & expiry) into the `DelegationManager.delegateTo` function ([source here](https://github.com/Layr-Labs/eigenlayer-contracts/blob/mainnet/src/contracts/core/DelegationManager.sol#L135-L155)). This function uses EIP1271 to check the signature, so either:
- A) The Operator has set an EOA as their `delegationApprover` and the DelegationManager simply checks that the signature is a valid ECDSA signature from the EOA.
- OR B) The Operator has set a smart contract as their `delegationApprover` and the DelegationManager calls the isValidSignature function on the `delegationApprover` and checks if the contract returns `0x1626ba7e` (as defined in the [EIP-1271 specification](https://eips.ethereum.org/EIPS/eip-1271#specification)).

If the delegationApprover themself calls the DelegationManager.delegateToBySignature function, then they need to provide a [signature from the Restaker](https://github.com/Layr-Labs/eigenlayer-contracts/blob/mainnet/src/contracts/core/DelegationManager.sol#L157-L204). The approverSignatureAndExpiry input is ignored if the caller is themselves the delegationApprover. One potential drawback to this approach is the delegationApprover would pay the gas for the transaction.

#### Generating approval signatures using eigenlayer-cli
If you want to generate signatures for stakers using delegationApprover address, you can use eigenlayer-cli (>= v0.10.8) to generate those. Use the following command to generate the approval signature.
```bash
eigenlayer operator get-delegation-approval \
  --ecdsa-private-key <delegation-approval-address-private-key> \
  operator.yaml <staker-address>
  --
```
This command will generate a signature similar to the example below.
```bash
operator: 0x2222AAC0C980Cc029624b7ff55B88Bc6F63C538f
approverSignatureAndExpiry.signature: 0xd8af4e2d294d644a989a517583420037d9a089de23bb828b3c00e309e5c6517b236221a5af145cea9eeba59f24732bb410efa79bc840130724b2bf23640011271c
approverSignatureAndExpiry.expiry: 1729989609
approverSalt: 0xdca4f1809aeb9c0f7059e328d1e28b317efff44b4ae9c2de67a53af8865876d3
```
Provide these details to stakers so they can successfully delegate to the operator. By default, the salt’s expiry is set to 3600 seconds. To modify this, use the --expiry flag followed by the desired expiry value. You can also use `--path-to-key-store` flag instead of `--ecdsa-private-key` if you have your approval key as a keystore. We do NOT support web3signer or fireblocks for this operation. 

In case you want to generate the unsigned salt and sign it yourself, just skip passing any signer information
```bash
eigenlayer operator get-delegation-approval \
  operator.yaml <staker-address>
```
The following command generates the salt hash. Sign this hash with the delegation approval key, then pass the resulting signature to your stakers.
```bash
staker: 0x5f8C207382426D3f7F248E6321Cf93B34e66d6b9
operator: 0x2222AAC0C980Cc029624b7ff55B88Bc6F63C538f
_delegationApprover: 0x111116fE4F8C2f83E3eB2318F090557b7CD0BF76
approverSalt: 0x5a94beaf38876a825bc1a12ba0c1e290e28934b9f9748a754cf76e3d10ecef23
expiry: 1729990089

hash: 0x48d6bfbd7ebc9c106c060904b0c9066951349858f1390d566d5cd726600dd1e8 (sign this payload)
```

#### Whitelisting and Blacklisting Restakers for Delegation

If the Operator uses option B above, a smart contract for their `delegationApprover`, they can also maintain an approved whitelist. The contract can store a Merkle root of approved signature hashes and provide each Restaker with a Merkle proof when they delegate. [This branch](https://github.com/Layr-Labs/eigenlayer-contracts/blob/feat-example-operator-delegation-whitelist/src/contracts/examples/DelegationApproverWhitelist.sol) provides a  proof of concept (PoC)  of what such a smart contract could look like.

The example above could be modified to act as a “blacklist” by using Merkle proofs of non-inclusion instead of Merkle proofs of inclusion.






---

---
sidebar_position: 2
title: Allocate and Register to Operator Set
---

:::important
Before proceeding, review the [Slashing Concept](../../eigenlayer/concepts/slashing/slashing-concept.md) content for information on how Operator Sets and Allocations work.
:::

Set Allocation Delay:

```
eigenlayer operator allocations set-delay <flags> <allocation-delay>
```

Before allocating for their first Operator Set, an Operator is required to set an `ALLOCATION_DELAY` in the `AllocationManager`. If an Operator is registering with EigenLayer for the first time, they will be required to provide an `ALLOCATION_DELAY` during registration. It takes the amount of time specified in the `ALLOCATION_CONFIGURATION_DELAY` for the Operator's `ALLOCATION_DELAY` to be set initially or updated. This delay is to ensure Stakers have time to adjust to changes in their delegated Operator’s stake allocations. Stakers can withdraw their funds if an allocation is viewed as undesirable, subject to the `WITHDRAWAL_DELAY`

Set Allocations per Operator Set and Strategy

```
eigenlayer operator allocations update 
	--network sepolia
	--operator-address <operator-address> 
	--csv-file updates.csv 
	--caller-address <address-of-caller>
```

Use the csv in the below format to set multiple allocations in one transaction, where update.csv will look like:

```
avs_address,operator_set_id,strategy_address,bips
0x2222AAC0C980Cc029624b7ff55B88Bc6F63C538f,2,0x4936BA8f0a04CcC2e49b8C9E42448c5cD04bF3f5,1200
0x2222AAC0C980Cc029624b7ff55B88Bc6F63C538f,1,0x4936BA8f0a04CcC2e49b8C9E42448c5cD04bF3f5,165
```

The bips you provide here will be the final bips of your total stake.

* If the bips is more than what is currently slashable, it will take effect after allocation delay time which you have set in Step 1  
* If the bips is less than what is currently slashable, it will take effect after a deallocation delay which is set by protocol and can’t be changed per operator.  
  * Mainnet \- 14 days in blocks.  
  * Testnet \- 5 min in blocks.

There can only be one allocation or deallocation per (operator, strategy, operator set) at a time. Once the pending allocations/deallocation completes then you can start another if you would like. 

View all your allocations with show command as below

```
eigenlayer operator allocations show 
	--network sepolia
	--operator-address <operator-address> 
	--strategy-addresses <comma-separated-strategy-addresses>

```

Register to Operator Set

```
eigenlayer operator register-operator-sets 
	--operator-address <operator-address> 
	--avs-address <avs-service-manager-address> 
	--operator-set-ids <comma-separated-list-of-operator-set-ids>
	--caller-address <address-of-caller>
```

De-register from Operator Sets
```
eigenlayer operator deregister-operator-sets 
	--operator-address <operator-address> 
	--avs-address <avs-address> 
	--operator-set-ids <comma-separated-list-of-operator-set-ids>
	--caller-address <address-of-caller>
```

Note: If you are deregistering from an operator set which has some active allocation bips, you will have to explicitly deallocate from that operator set using the \`eigenlayer operator allocations update\` command specified above. If you don’t do this, that amount of stake would be unavailable until it is deallocated. Once you deallocate then after deallocation delay it will be available.


---

---
sidebar_position: 7
title: Troubleshoot
---

# Troubleshooting

Before creating an issue with EigenLayer support please check this page to see if you can resolve your issues. If you are still stuck, please create a support ticket

#### Getting "no contract code at given address"

If you are getting this issue then either you are using a wrong rpc in your [operator.yaml](https://github.com/Layr-Labs/eigenlayer-cli/blob/master/pkg/operator/config/operator-config-example.yaml#L32) file or you have wrong smart contract address in your [config](https://github.com/Layr-Labs/eigenlayer-cli/blob/master/pkg/operator/config/operator-config-example.yaml#L25).

* Please make sure you have correct rpc node chosen for your network and that it is also reachable via your machine.

* Please find the correct smart contract addresses listed in the [Operator Installation](operator-installation.md) section.

#### How to resolve the error "No contract code at given address" imply?

Ensure that your operator is pointing to the correct RPC service and that it is accessible from your operator ([example](https://chainlist.org/)).

#### My operator's metadata (name, description, logo) is not showing up in the webapp
Please make sure to comply with our metadata [guidelines](operator-installation.md#operator-configuration-and-registration)

---

---
sidebar_position: 1
title: Add and Remove Admins
---

:::caution
Security of admin keys is critical. UAM enables appointees with lessened permissions, and use of keys that can be rotated or
destroyed. For more information on key management best practices, refer to [AVS Developer Security Best Practices](../../../developers/Reference/avs-developer-best-practices.md).

After an account has added an admin and the pending admin has accepted, the account address no
longer has default admin privileges. That is, the original account key of the Operator or AVS cannot be
used for write operations to the protocol, unless previously added as an admin, or is added back as admin in the future.
There is no superadmin role.

The removal of default admin privileges upon adding additional admins enables accounts
to perform a key rotation to remove permissions from a potentially compromised original key.

For an account to retain admin
privileges for its own address, add the account first as an admin. After the account is added as an admin, add other admins as needed.
:::

## Add an Admin Using EigenLayer CLI 

Admins are added via a 2-step process. To add an admin:
1. As the current admin (or account if no admin has been set), add the pending admin:

    `eigenlayer user admin add-pending-admin [options]` with:
    * `account-address` - Operator address for which admin is being added
    * `admin-address` - Admin address to be added
    * `caller-address` - Not required when using `--broadcast` or the admin using the CLI is the `account-address`.
      Must be specified if `--output-type` is `calldata` and the admin using the CLI is not the `account-address`.
      Set to the address of the admin using the CLI.

2. As the pending admin, accept the admin:

    `eigenlayer user admin accept-admin [command options]` with: 
    * `account-address` - Operator address for which admin is being added
    * `accepter-address` - Address of admin accepting the pending invite 

## Remove an Admin Using EigenLayer CLI

The caller must be an admin. Once an account has added an admin, there must always be at least one admin for the account. 

To remove a pending admin before they have accepted:
 
`eigenlayer user admin remove-pending-admin [options]` with:
    * `account-address` - Operator address for pending admin
    * `admin-address` - Pending admin address to be removed
    * `caller-address` - Not required when using `--broadcast` or the admin using the CLI is the `account-address`.
      Must be specified if `--output-type` is `calldata` and the admin using the CLI is not the `account-address`.
      Set to the address of the admin using the CLI.

To remove an admin:

`eigenlayer user admin remove-admin [options]` with:
    * `account-address` - Operator address for admin
    * `admin-address` - Admin address to be removed  
    * `caller-address` - Not required when using `--broadcast` or the admin using the CLI is the `account-address`.
       Must be specified if `--output-type` is `calldata` and the admin using the CLI is not the `account-address`.
       Set to the address of the admin using the CLI.




---

---
sidebar_position: 1
title: Add and Remove Appointees
---

Only admins (or the account if no admin has been set) can add appointees. Unlike adding an admin, there is no requirement
for an appointee to accept the appointment.

For the list of contracts and functions that can have appointees set, refer to:
* [User Account Management](../../../developers/Concepts/uam-for-avs.md) for AVS
* [User Account Management](../../concepts/uam-for-operators.md) for Operators

## Add an Appointee Using EigenLayer CLI 

To add an appointee:

`eigenlayer user appointee set [options]` with:
    * `account-address` - Operator address for admin
    * `appointee-address` - Appointee address to have ability to call specified function granted
    * `caller-address` - Not required when using `--broadcast` or the admin using the CLI is the `account-address`.
      Must be specified if `--output-type` is `calldata` and the admin using the CLI is not the `account-address`.
      Set to the address of the admin using the CLI.
    * `selector` - Function for which to grant appointee ability to call. Use Etherscan to obtain the selector.
    * `target-address` - Contract address containing function for which appointee is being granted permission to call 
      (for example, `AllocationManager`). The contract addresses are published in the [core contracts](https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments) repository.

## Remove an Appointee Using EigenLayer CLI

To remove an appointee: 

` eigenlayer user appointee remove [options]`

With the same options as adding an appointee but the permission is being removed instead of granted.


---

---
sidebar_position: 7
title: Operator FAQ
---



#### Am I required to publicly host metadata url?

Yes. You are required to host the metadata url publicly. The `metadata` url should always be available and should return a proper json response like [this](https://holesky-operator-metadata.s3.amazonaws.com/metadata.json)

#### Am I required to publicly host logo in metadata json?

Yes. You are required to host the logo publicly like [this](https://holesky-operator-metadata.s3.amazonaws.com/eigenlayer.png)

#### Are there any restrictions to the logo image?

Yes. We only support `.png` format and we strictly check the content of image. If your image doesn't satisfy the requirement then the EigenLayer App will not display the logo of your operator.

#### What if I lose access to my keys?

When you [create/import](../howto/operator-installation.md#create-and-list-keys) keys for the first time, it will ask a password to encrypt keys and once created, it will also show plaintext private key. Please make sure to backup the private key and the password. If you lose both you won't be able to get your keys back. If you lose the plaintext private key and still have your password you can run the export command to get your plaintext private key.

#### What is my operator address?

After you [create/import](../howto/operator-installation.md#create-and-list-keys) ecdsa key you will be shown below log message

```
? Enter password to encrypt the ecdsa private key:
ECDSA Private Key (Hex):  b3eba201405d5b5f7aaa9adf6bb734dc6c0f448ef64dd39df80ca2d92fca6d7b
Please backup the above private key hex in safe place.

Key location: /home/ubuntu/.eigenlayer/operator_keys/test.ecdsa.key.json
Public Key hex:  f87ee475109c2943038b3c006b8a004ee17bebf3357d10d8f63ef202c5c28723906533dccfda5d76c1da0a9f05cc6d32085ca1af8aaab5a28171474b1ad0aa68
Ethereum Address 0x6a8c0D554a694899041E52a91B4EC3Ff23d8aBD5
```

Your operator address is the `Ethereum Address` in the logs.

#### What if I want to change the password of my encrypted keys?

If you want to change the password of your encrypted keys, you have two options based on what information you have readily available:

1. If you know your private keys then you can just re-import and when importing, choose a different name and the new password.
2. If you don't know your private keys, you can get them using export. Once you have the private keys you can use option 1 to re-import.

#### What if I want to deactivate/deregister my operator from EigenLayer?

Currently, there's no way to deregister your operator but you can
update the name of your operator in metadata url to be `Deactivated` or something similar. This will help display your operator as not active on the webapp.

#### Is there a limit to the number of AVSs that an Operator can opt-in to?

There is no limit on the number of AVSs that an Operator can opt-in to. However, the Operator needs to ensure they have sufficient infrastructure capacity for the AVSs they opt-in to.



#### What is the process for rotating the keys for an existing operator? How can I register again and carry over the stake to a new key?

This operation is not supported at this time.


---

---
sidebar_position: 2
title: Native ETH Restaking Withdrawal Delays
---

Withdrawing funds from BeaconChain to an EigenPod and ultimately to a user’s wallet involves multiple sequential steps with
varying delays. The standard withdrawal flow and possible optimizations to the standard flow are described. 

## Standard withdrawal flow 

<img src="/img/restake-guides/withdrawal-flow.png" width="75%" style={{ margin: '50px'}}>
</img>

To move funds from a validator on BeaconChain to an EigenPod, the following steps occur:
1. Request Voluntary Exit
   * Broadcast a request to exit the validator on BeaconChain (usually very fast).

2. Exit Queue
   * Validators enter the exit queue.
   * The exit queue has never exceeded 7 days.
   * Typically \<1 day, but technically unbounded during extremely high congestion.

3. Withdrawal Delay
   * After reaching the end of the exit queue, a validator can be turned off, but there is an enforced delay before the ETH becomes withdrawable.
   * Fixed at 256 epochs (~27 hours).

4. Sequential Validator Sweep
   * Validators are checked sequentially 16/block to see if they have rewards to send to the execution layer.
   * Currently 0-9.1 days (randomized based on validator index in the sweep order).
     Maximum length depends on the number of active validators in the network.

5. Funds Enter EigenPod
   * Once swept, funds arrive in the EigenPod on the Execution Layer.

6. EigenLayer Withdrawal Escrow
   * 7-day* mandatory waiting period before final withdrawal can be executed.
   * The Escrow increases to 14 days post [Slashing upgrade](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md#why-is-withdrawal_delay-set-to-14-days-worth-of-blocks).

7. Complete Withdrawal
   * Once the escrow period ends, funds can be withdrawn from EigenLayer to the user’s wallet.

**Estimated Timeframe:** 8-17 days depending on how quickly the user initiates the withdrawal from the EigenPod after funds arrive.

## Optimized approach 

<img src="/img/restake-guides/optimized-withdrawal-flow.png" width="75%" style={{ margin: '50px'}}>
</img>

For users comfortable with smart contract interactions, it is possible to reduce the total withdrawal time by overlapping certain steps:
* The BeaconChain withdrawal process (1-10 days) can overlap with the EigenLayer escrow period (7* days) by proactively 
queuing withdrawals on-chain in advance.
  * Escrow increases to 14 days post [Slashing upgrade](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md#why-is-withdrawal_delay-set-to-14-days-worth-of-blocks).
* Overlapping these steps requires knowing the exact amount to withdraw ahead of time to prevent issues with overestimating (which leads to delays) or underestimating (which leaves residual funds in the EigenPod).

**Minimum Theoretical Withdrawal Time:** 1-10 days instead of 8-17 days.

## Key Considerations for Operators & Restaking Integrators
* Validator Sweep Randomness: The 0-9 day delay is unpredictable for a given validator due to the sequential sweep mechanism.
  * Potentially can be optimized by an operator with a large number of validators pointed to the same EigenPod by 
  selecting validators that are closer to the current index of the sweep.
  * This optimization is especially viable for custodial restaking operations.
* Risks of the Optimized Approach:
  * If a user underestimates the withdrawal amount, residual ETH remains in the EigenPod.
  * If a user overestimates, they must wait for the escrow to complete before adjusting.
  * Slashing events or penalties can disrupt planned withdrawals.

---

---
sidebar_position: 1
title: Restaking Overview
---


## **Liquid & Native Restaking**

**Liquid restaking** is the process of depositing "liquid" tokens, including LSTs, EIGEN token, and any ERC20 token into the EigenLayer smart contracts. For more information about adding new ERC20 tokens, please see [Permissionless Token Strategies](/docs/developers/HowTo/build/avs-permissionlesss.md).


**Native restaking** is the process of changing an Ethereum validator's[ withdrawal credentials](https://notes.ethereum.org/@launchpad/withdrawals-faq#Q-What-are-withdrawals) to EigenLayer's smart contracts. You must operate an Ethereum Validator node in order to participate in Native Restaking. To learn more or set up your Ethereum Validator please follow this link from the[ Ethereum Foundation](https://launchpad.ethereum.org/).

### EigenPod Overview 

An [EigenPod](https://github.com/Layr-Labs/eigenlayer-contracts/blob/master/docs/core/EigenPodManager.md) is a smart contract managed by users, designed to facilitate the EigenLayer protocol in monitoring and managing balance and withdrawal statuses. Please review the following considerations when planning your EigenPod and validator operations:

- You may repoint any number of validators to a single EigenPod.
- An Ethereum address (wallet) can only deploy a single EigenPod instance.
- The address that deploys an EigenPod becomes the owner of the contract (EigenPod Owner) and gains permission for restaking and withdrawal operations.
- Ownership of an EigenPod cannot be transferred.

### Checkpoint Proofs

[Checkpoint Proofs](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/EigenPod.md#checkpointing-validators) convert native validator ETH and validator yield to actively restaked shares. These proofs are initiated 
before any Restaking or Withdrawal action and are necessary to prove the expected funds are deposited in the EigenPod and/or validator. 
Checkpoint proofs are a two step process:
1. Starting a Checkpoint: this step occurs once.
1. Verify (and Completing) a Checkpoint: this step occurs multiple times until all of the remaining unproven ETH balance in the 
EigenPod has been proven.

## Delegation

Delegation is the process of assigning Restaked balance to an Operator. The Restaker will receive fees according to the AVSs 
that the Operator chooses to run. Restakers can undelegate their balance to end their assignment to the Operator and later 
redelegate the balance to a new Operator.

Please note the following conditions:
- Stakers can only delegate to a single Operator at a time.
- Delegation is an "all or nothing" operation. You must delegate all of your available Restaked balance to a single Operator.
- Delegation is not possible for Native Restakers while their validators are in the activation (aka entry) queue. Native Restaked 
tokens must be fully Restaked and proven on-chain before they can be delegated.
- If you have already delegated your stake to an operator, all new stakes will be delegated to the same operator automatically.
- If the delegated Operator is no longer in the active set of an AVS (such as due to operator ejection), the Restaker has 
the option to Redelegate their TVL balance to another Operator.

## Slashing 

:::important
When the Slashing and Operator Set upgrade is live on mainnet, stake can become slashable for a Staker that has previously
delegated stake to an Operator. Stakers are responsible for ensuring that they fully understand and confirm their risk tolerances
for existing and future delegations to Operators and the Operator’s slashable allocations. Additionally, stakers are responsible
for continuing to monitor the allocations of their chosen Operators as they update allocations across various Operator Sets.
:::

When the Slashing and Operator Sets upgrade is live on mainnet, AVSs can create [Operator Sets](../../eigenlayer/concepts/operator-sets/operator-sets-concept.md) that may include slashable
[Unique Stake](../../eigenlayer/concepts/slashing/unique-stake.md), and Operators can allocate their delegated stake to Operator Sets. If a Staker has previously delegated stake
to an Operator, the delegated stake becomes slashable when the Operator opts into an Operator Set and allocates Unique Stake.

Stakers are responsible for understanding the increased risk posed by allocation of their delegated stake as slashable
Unique Stake to an AVS. While the allocation of delegated stake to an Operator Set may be subject to the [Allocation Config
Delay and Allocation Delay](../../eigenlayer/reference/safety-delays-reference.md), it is important to understand the increased risk.

For more information on the safety delays for Stakers, refer to the :
* [Safety Delays reference](../../eigenlayer/reference/safety-delays-reference.md)
* [Allocating and Deallocating to Operator Sets section of ELIP-002](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md#unique-stake-allocation--deallocation).

## Escrow Period (Withdrawal Delay)

EigenLayer contracts feature a withdrawal delay for all Liquid and Native restaking, a critical security measure for instances 
of vulnerability disclosure or when anomalous behavior is detected by monitoring systems. Please see [Withdrawal Delay](/docs/eigenlayer/security/withdrawal-delay.md) 
for more detail.


---

---
sidebar_position: 1
---


# Restake and Delegate

The following instructions will walk you through how tokens can be restaked on the [EigenLayer Web App](https://app.eigenlayer.xyz/).

**Step 1:** Open the EigenLayer App and connect your Web3 wallet. Visit EigenLayer on the Ethereum Mainnet at [app.eigenlayer.xyz](https://app.eigenlayer.xyz/).


![](/img/restake-guides/lst-restake-1.png)

**Step 2:** Click **Token** tab to view assets available for restaking.

**Step 3:** Click on the asset you wish to restake. Choose the amount of the asset you wish to restake. Click **Submit** to continue.

:::info
This guide to Liquid Staking refers to all assets displayed on the Token tab, except for `Natively Staked Ether`, which refers to [Native Staking here](../native-restaking/README.md).
:::
![](/img/restake-guides/lst-restake-2.png)


If you have not yet delegated your assets to an Operator, you will be prompted to do so at this step. Click on an Operator then click **Submit** to continue.

![](/img/restake-guides/lst-restake-2.1.png)



**Step 4:** Token Approval, Deposit, and Delegate transactions:
- If this is your first time depositing a token on EigenLayer, you'll need to **Approve** token spending before you can restake. [Token Approval](https://support.metamask.io/transactions-and-gas/transactions/what-is-a-token-approval) gives a dApp permission to move the specified token from your wallet.
- If you have not yet delegated assets to an Operator, you will receive two transaction prompts: one for the **Deposit** transaction and second for the **Delegate** transaction.

**Step 5:** **Sign** the transaction(s) via your Web3 wallet to continue.


**Step 6:** Observe the confirmation that the Restake operation is completed.

![](/img/restake-guides/lst-restake-3.png)


---

---
sidebar_position: 2
---


# Unstake and Withdraw

:::info
All funds unstaked from EigenLayer will go through an escrow period before being eligible to be fully withdrawn. Please see the [Escrow Period](/docs/restakers/restaking-guides/testnet/README.md#testnet-vs-mainnet-differences) section for more detail.
:::

**Step 1:** Navigate to the token asset you wish to unstake. Click **Unstake** to continue.

![](/img/restake-guides/lst-unstake-1.png)


**Step 2:** Choose the amount of the asset you wish to restake. Click **Submit** to continue.

![](/img/restake-guides/lst-unstake-2.png)

**Step 3:** Click **Confirm** to sign the queue withdrawal transaction when prompted by your wallet.

**Step 4:** Observe the Unstake confirmation page. Your withdrawal is now in escrow. **Wait** for the escrow period to complete.

![](/img/restake-guides/lst-unstake-3.png)


**Step 5:** Once the escrow completes, you'll see the withdrawable balance under Available to Withdraw. Click **Withdraw** to complete the withdrawal. **Sign** the transaction when prompted by your Web3 wallet.

![](/img/restake-guides/lst-unstake-4.png)


After the transaction is completed your withdrawn assets will be visible in your Web3 wallet.

---

---
sidebar_position: 2
title: Native Restaking
---

# Native Restaking


:::warning
Please read this entire guide before launching your new validator or integrating your existing validator. Before you deploy a new validator you must plan to either:
- Initially provision the withdrawal credentials to your EigenPod address (created on the next page).
- Initially provision the withdrawal credentials to an 0x00 address. You can then later modify your withdrawal credentials to your EigenPod address.
:::

Native Restaking via the EigenLayer Web App consists of the following actions:
1. [Restake New Validator Native Beacon Chain ETH](#restake-new-validator-native-beacon-chain-eth)
2. [Restake Validator Yield (Rewards, Fees, and ETH)](#restake-validator-yield-rewards-fees-and-eth)
3. [Withdraw Native ETH or Validator Yield](#withdraw-native-eth-or-validator-yield)
4. [Delegate and Undelegate](#delegate-and-undelegate)


## Gas Cost Planning

We recommend users connect many validators to a single EigenPod in order to reduce cost and complexity where practical. For each of the actions below that require a checkpoint proof, the web app will batch up to 80 validators per proof transaction batch. Users with more validators will require additional transactions to complete each checkpoint proof. Please plan your gas costs accordingly.


## Restake New Validator (Native Beacon Chain ETH)

Create EigenPod:
1. Visit the [EigenLayer App](https://app.eigenlayer.xyz/).
1. Click **Natively Staked Ether** via the Dashboard or Token tab.
1. Click **Create EigenPod**.
1. **Sign** the transaction via your Web3 wallet when prompted.
1. Observe the new EigenPod contract address is displayed.

:::info
This address is responsible for all subsequent restaking and withdrawal activities associated with that EigenPod.
:::

Repoint Validator:
1. Configure the validator(s) credentials to point to the EigenPod address when the validator is created. Please see [Ethereum Launchpad](https://launchpad.ethereum.org/en/withdrawals#enabling-withdrawals) for more information. 
    * Confirming Withdrawal Address: you can confirm your withdrawal credentials (which should match your EigenPod), via the following URL: https://beaconcha.in/validator/[validator_index]#deposits
    * Optional: as of the PEPE release you may choose to set the FEE_RECIPIENT to your EigenPod address if you wish to Restake those fees.
1. Wait for the validator(s) to become active on-chain. Please see https://beaconcha.in/[validator_index] to follow your validator status. Please note: this process could take up to 10 days depending on the Beacon Chain deposit queue.
1. The validator's state will transition to `Awaiting Restake` in the web app.

Activate Restaking:
1. Once the Validator is active on-chain and the withdrawal address has been configured to point to the EigenPod address, the Restake button will become active.
1. Click **Restake** to initiate restaking the validator.
1. Sign the transaction with your web3 wallet.
1. Your validator is now **Restaked**.
1. You now have the option to delegate your restaked assets to your selected Operator. If you are already delegated to an Operator, your assets will automatically delegate to your currently selected Operator.


## Restake Validator Yield (Rewards, Fees, and ETH)

As of the PEPE release, users can now convert consensus rewards, validator execution fees and ETH sent to the EigenPod to restaked shares (referred to broadly in this document as "Validator Yield").  Initiating and completing a checkpoint proof will automatically convert any consensus rewards to restaked shares for the EigenPod.

1. Observe the value of `Unstaked Balance` becomes greater than zero when there is ETH available to convert to restaked shares in the EigenPod.
1. Click **Restake** to initiate a checkpoint proof.
1. Sign two transactions: Begin Restake (to initiate a checkpoint proof) and Restake (to complete the checkpoint proof).
1. Observe the Restaked Balance has increased by the amount of validator yield proven in the previous step.

:::info
1. The time lag associated with Ethereum beacon chain validator sweeps, which can be up to 65812 slots or 9 days. Please see the Ethereum docs [here](https://ethereum.org/en/staking/withdrawals/#validator-sweeping) for more information.
:::

### Checkpoint Frequency

Users should not initiate a checkpoint more frequently than once every two weeks (approximately). 
The longer you wait before performing a checkpoint, the more gas users will save. The gas cost of a checkpoint is the same, regardless of how many consensus rewards will be proven. Each user should determine the best interval to fit their gas cost and restaking benefit needs.

Consensus rewards are moved from the beacon chain to your EigenPod once every approximately 8 days per the Ethereum protocol. Checkpoint intervals more frequently than 8 days would result in no benefit for the user.



## Withdraw Native ETH or Validator Yield

Overview: the amount of ETH available to be queued for withdrawal will appear under "Available to Queue" in the web app. This amount will include any exited validators where the balance was withdrawn to EigenPod and any validator yield available to be withdrawn.


If you wish to withdraw native ETH from an active validator, complete the following steps before proceeding:
1. Ensure you have repointed your validator's withdrawal credentials to your EigenPod prior to continuing. Please see [Ethereum Launchpad](https://launchpad.ethereum.org/en/withdrawals#enabling-withdrawals) for more information. 
1. Fully exit your validator from the beacon chain. You may monitor its activity via beaconcha.in/validator/[validator_index].
1. Wait for the final beacon chain withdrawal to be deposited to your EigenPod. There can be a lag of up to 24 hours to 7 days between the validator appearing as "exited" and the withdrawal amount deposited to EigenPod. Please see the "Withdrawals" tab and "Time" column for your validator via beaconcha.in/validator/[validator_index]#withdrawals .


:::warning
Each queue withdrawal action will trigger a checkpoint and the associated gas costs. Please review the [Checkpoint Frequency](#checkpoint-frequency) section and plan for gas costs accordingly.
:::

Queue the Withdrawal:
1. Click **Queue Withdrawal** in the web app.
1. Choose the amount you wish to queue for withdrawal and continue
1. A checkpoint proof is initiated. **Sign** the associated transaction with your web3 wallet.
1. Wait for the [Escrow Period](/docs/restakers/restaking-guides/testnet/README.md#testnet-vs-mainnet-differences) to complete.


Redeposit or Complete Withdrawal:
Redeposit or Complete Withdrawal: Redepositing is available at this step for users who accidentally queued a withdrawal, but would like to resume staking and delegation.
1. Choose to either **Restake** (to Redeposit the assets) or **Withdraw** (to complete the withdrawal).
1. **Sign** the transaction using your web3 wallet.


## Delegate and Undelegate

Undelegate and/or Change Delegation
1. Click Undelegate
1. **Sign** the transaction using your web3 wallet. Note: a queue withdrawal event occurs via the smart contracts at this time, because Undelegate and Queue Withdrawal actions are linked at the smart contract level. This information is not presented to the user in order simplify the user flow and focus on the change delegation action.
1. User is now Undelegated from the Operator.
1. Wait for the [Escrow Period](/docs/restakers/restaking-guides/testnet/README.md#testnet-vs-mainnet-differences) to complete.

Delegate to a New Operator
1. Navigate to an Operator you wish to delegate your assets to.
1. Click **Delegate** to delegate to the new Operator.
1. **Sign** the transaction using your web3 wallet.
1. You are now delegated to the new operator


---

---
sidebar_position: 1
title: Delegate to an Operator
---

# Delegate EIGEN, LSTs, and Native Restaked ETH to an Operator

Follow the steps below to initiate delegation of your Restaked balance to an Operator of your choice. This Restaked balance includes EIGEN tokens, LST tokens, and Native Restaked TVL.

Delegation is a unified step in the standard EIGEN and LST Restaking flow. For Native Restakers or scenarios where the unified Restaking flow was not completed, the following steps will allow you to delegate your stake directly.



**Step 1:** Navigate to the **Operator** page to view a list of available Operators.

![](/img/restake-guides/delegate-1.png)

**Step 2:** Search for operators via their name or Ethereum address. Click on the **Operator's tile** to view their Detail page.

![](/img/restake-guides/delegate-2.png)

**Step 3:** Click **Delegate** to initiate a delegation of all your staked assets to that operator.

**Step 4:** Confirm the transaction in your Web3 wallet.

**Step 5:** Note the delegating progress message.

**Step 6:** After the transaction has been confirmed, please note your stake will show as Delegated for that Operator.

![](/img/restake-guides/delegate-3.png)

---

---
sidebar_position: 3
title: Change Your Delegation
---

# Change Your Delegation to a New Operator

The following steps are necessary for a Restaker to **move** their Delegated balance to a New Operator. The process below requires users to perform each of the following steps in order:
- **Undelegate** assets, which automatically queues a **withdrawal**. The Undelegate and Queue Withdrawal transactions are combined due to the security architecture of EigenLayer smart contracts. 
- **Redeposit** each asset.
- **Delegate** to the new Operator.

:::warning
Follow the steps below carefully to avoid a "partially delegated state". A partially delegated state is when some portion of your assets in Delegated state and other assets in a "queued for withdrawal" or "withdrawal ready for completion" state.
:::

## Process to Change Your Delegation to a New Operator

**Step 1:** Visit the **Operator** page for your currently delegated Operator. Click **Undelegate**.

![undelegate button](/img/restake-guides/delegate-3.png)


**Step 2:** **Confirm** the Undelegate transaction in your Web3 wallet.

**Step 3:** **Observe** that your Restaked balances are now 0.0 TVL. Those assets are now undelegated from the previous Operator appear in "Pending Withdraw" state.

**Step 4:** **Wait** for the escrow period to end before continuing. Please see [Testnet vs Mainnet differences for detail](/docs/restakers/restaking-guides/testnet/README.md#testnet-vs-mainnet-differences).

**Step 5:** Manually Redeposit each asset. **Navigate** to each asset page individually. Navigate to the  **Unstake** tab, click **Redeposit**. This will prompt a Redeposit transaction for each asset that you will confirm in your Web3 wallet.

**Step 6:** After all assets have been redeposited, **navigate** to the Operator page for the new operator you wish to delegate to. Click **Delegate** button.


![](/img/restake-guides/delegate-2.png)


**Step 7:** **Observe** that your delegation has been changed to the new Operator.


:::info
Do not click the **Redelegate** button on the Operator page. The button is intended to be used only for users that have funds in a "partially delegated state".
:::

---

---
sidebar_position: 2
title: Undelegate and Initiate Withdrawal
---

# Undelegate from an Operator and Initiate Withdrawal

Restakers can Undelegate their balance from an Operator at any time. Undelegation flows are the same for both Native and LST Restakers.

:::info
Initiating an Undelegate transaction will also **automatically queue a withdrawal**, but not complete (finalize) the withdrawal. The Undelegate and Queue Withdrawal transactions are combined due to the security architecture of EigenLayer smart contracts. If you wish to redeposit, you can do so immediately after the escrow period ends. If you want to complete the withdrawal, you can do so immediately after the escrow period ends.
:::


## Instructions to Undelegate and Queue Withdraw

**Step 1:** Navigate to the Operator tab, click the tile for the Operator you have delegated your funds to. Click the Undelegate button to continue.

![](/img/restake-guides/delegate-4.png)

**Step 2:** Confirm the Undelegate transaction in your Web3 wallet.

**Step 3:** Observe that your Restaked balances are now 0.0 TVL.

**Step 4:** Wait for the escrow period to end before continuing. Please see [Testnet vs Mainnet differences for detail](/docs/restakers/restaking-guides/testnet/README.md#testnet-vs-mainnet-differences).

**Step 5:** Visit any individual page for your unstaked assets and observe your **Unstaked** balance has increased by the corresponding amount.

**Step 6:** Click **Withdraw** to finalize the withdrawal for the asset.

![](/img/restake-guides/delegate-5.png)

:::info
The "Redeposit" button is also available for the user to Restake funds in case the withdrawal was initiated by mistake.
:::

**Step 7:** Repeat steps 5 and 6 above for any remaining assets where you wish to finalize withdrawal.


---

---
sidebar_position: 3
title: Restaking Smart Contract Developer
---



Smart Contract Restaking allows the user to interact directly with the EigenLayer core contracts. The following sections describe how to setup your Restaking integration with the EigenLayer contracts directly with no reliance on the EigenLayer Web App.

Key EigenLayer Protocol references for this guide:
* [Source Code](https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/src/contracts): for all the following references to EigenLayer core contracts and functions, please see the src/contracts folder for their source code.
* [Developer Documentation (specifications)](https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/docs): detailed protocol specifications for restaking smart contract integration developers.
* [Deployed Contract Addresses](https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments): deployed contract addresses for Mainnet and Testnet.
* [Integration Tests](https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/src/test/integration): tests that serve as examples on how to interact with the EigenLayer core contracts.





## Liquid Restaking Guide

The following sections describe the steps to Restake "liquid" tokens (including LSTs EIGEN token, and any ERC20 token).

### Deposit (Restake) Liquid Tokens

1. For the token being deposited, invoke ERC20(token).approve(StrategyManager, amount) to authorize EigenLayer contracts before depositing.
2. Invoke `StrategyManager.depositIntoStrategy()` .
   * Parameters:
     * `strategy` - use the address of the deployed strategy ([example list here](https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments)).
     * `token` - use the address of the token associated with that strategy.
4. User is now actively Restaked.

### Withdraw (Unstake) Liquid Tokens

1. Queue Withdrawal: invoke `DelegationManager.queueWithdrawal()` to trigger the escrow period. Wait for Escrow Period: 7 days. Please see further detail [here](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-user-guide/#escrow-period-withdrawal-delay).
   * Parameters: please see the [QueuedWithdrawalParams](https://github.com/Layr-Labs/eigenlayer-contracts/blob/v0.3.2-mainnet-rewards/src/contracts/interfaces/IDelegationManager.sol#L93)
   * `strategy` - use the address of the deployed strategy ([example list here](https://github.com/Layr-Labs/eigenlayer-contracts?tab=readme-ov-file#deployments)).
   * `shares` - the number of shares in the given strategy. Note this parameter is not meant to reference the amount of the underlying token. Invoke `[Strategy].underlyingToShares()` and `[Strategy].sharesToUnderlying()` as needed to convert their current balances between strategy shares and underlying token amounts.

2. Complete Withdrawal as Tokens: invoke `DelegationManager.completeQueuedWithdrawal()` to complete the withdrawal and return assets to the withdrawer's wallet.


## Smart Contract Delegation User Guide

The process of Delegating assets is the same for both liquid and native restaked assets. The user's Restaking wallet must Delegate all restaked assets to a single Operator. After the initial Delegate operation - any subsequent Deposited (Restaked) assets are also automatically delegated to the current operator.

### Delegate Assets

1. Invoke `DelegationManager.delegateTo()`. Please observe the following notes on the parameters:
   a. operator: the address of the operator you want to delegate to.
   b. approverSignatureAndExpiry: can be left blank.
   c. approverSalt: can be left blank.
2. Your Restaked assets are now delegated.

### Change Actively Delegated Operator


The following steps are necessary for a Restaker to **move** their Delegated balance to a New Operator. The process below requires users to perform each of the following steps in order:
- **Undelegate** assets, which 
- **Redeposit** each asset.
- **Delegate** to the new Operator.

1. Undelegate: invoke `DelegationManager.undelegate()`.
   * Note: this action automatically **queues a withdrawal for all restaked assets**. The Undelegate and Queue Withdrawal transactions are intentionally combined due to the security architecture of EigenLayer smart contracts.
2. Wait for the Escrow Period to complete.
3. Invoke DelegationManager.completeQueuedWithdrawal(). **Important:** you will choose to complete the withdrawal as shares, which is effectively a **redeposit** action.
   * `receiveAsTokens` should be set to _false_.
4. Invoke `DelegationManager.delegateTo()` to delegate your restaked assets to the new Operator.





## Native Restaking Guide

The following instructions describe how to Restake validator ETH. This mechanism is referred to as "Native Restaking".

Native Restaking consists of the following actions:
* [Restake New Validator Native Beacon Chain ETH](#restake-new-validator-native-beacon-chain-eth)
* [Convert Consensus Rewards to Restaked Shares](#convert-consensus-rewards-to-restaked-shares)
* [Withdraw](#withdraw)

### Gas Cost Planning

For users planning to restake multiple validators, connecting many validators to a single EigenPod where possible reduces 
gas cost and complexity. "Generate Proof Via eigenpod-proofs-generation CLI" will prove all connected validators.

### EigenPod Upgrades and Pending Consensus Rewards

For all M1 to PEPE migrations - we no longer require users to upgrade their EigenPod contracts per the deprecated `activateRestaking()` method. M1 pods will be upgraded automatically to PEPE compliant EigenPods by EigenLabs.

The delayed withdrawal router is being deprecated with the PEPE release, but will remain functional. It will not receive new consensus rewards from EigenPods, however if you have existing rewards you may continue to claim them as they become claimable.

To claim consensus rewards invoke `DelayedWithdrawalRouter.claimDelayedWithdrawals()`.
References:
* [DelayedWithdrawalRouter.claimDelayedWithdrawals](https://github.com/Layr-Labs/eigenlayer-contracts/blob/3b47ccf0ff98dc3f08befd24e3ae70d7ecce6342/src/contracts/pods/DelayedWithdrawalRouter.sol#L94)
* [Contract Deployment Addresses](https://github.com/Layr-Labs/eigenlayer-contracts/tree/v0.3.2-mainnet-rewards?tab=readme-ov-file#deployments): find the Proxy address of DelayedWithdrawalRouter here.

Eigen Labs will push through any rewards that are still in the delayed withdrawal router 7 days after the PEPE upgrade (after which point all rewards in there will be claimable). So if you haven’t claimed by this point, we’ll automatically process those claims on your behalf and send them to the wallet of the EigenPod owner.



### Key Management and EigenPod Proof Submitter

EigenLayer Native Restaking requires submitting proofs to EigenLayer contracts to prove the amount of validator ETH is active and its withdrawal address is pointing to the EigenPod. For users who do not wish to include the "EigenPod Owner" (aka The EigenPod generation key) in their proof generation commands, you may identify another wallet as the **Proof Submitter** and delegate its privilege to submit proofs on its behalf using the assign_submitter command. At any point in the future the `sender` of the proof can be the assigned submitter. The EigenPod owner can also designate a new Proof Submitter as needed.

Use the following command to assign a submitter for your EigenPod:
```bash
/cli assign-submitter --execNode $NODE_ETH --podAddress $EIGENPOD_ADDRESS --sender $EIGENPOD_OWNER_PK
```

Consider using a cold key for the EigenPod Owner role. This key should be stored securely and used infrequently. 
For cold keys, best practice is using hardware wallets (e.g., Ledger, HSMSs) or smart contract multisigs (e.g., Safe). 

Best practice is using a seperate key for the Proof Submitter, which can be considered a hot key. The Proof Submitter 
is any other address approved to submit proofs on behalf of the EigenPod owner. This separation allows the EigenPod owner 
key to remain secure and cold. Hot keys, while less secure, can be managed with solutions like Vault (Hashicorp) or environment 
variables. It is crucial not to store any meaningful value in your hot keys as operational keys are considered less secure. 

### Restake New Validator Native Beacon Chain ETH

The steps below are only required for new validator native beacon chain ETH. Any validator native beacon chain ETH that was restaked prior to the PEPE release will not need to repeat these steps.

**Prerequisites**

The user will need an environment available to run the [EigenPod Proof Gen CLI](https://github.com/Layr-Labs/eigenpod-proofs-generation/tree/master/cli#quickstart) including its software prerequisites.

#### Part 1: Create EigenPod

Invoke `EigenPodManager.createPod()`.  

#### Part 2: Configure Validator(s) Withdrawal Credentials

1. Configure the validator(s) credentials to point to the EigenPod address when the validator is created. Please see [Ethereum Launchpad](https://launchpad.ethereum.org/en/withdrawals#enabling-withdrawals) for more information. 
    a. Optional: you may choose to set the FEE_RECIPIENT to your EigenPod address if you wish to Restake those fees.

2. Wait for the validator(s) to become active on-chain. Please see https://beaconcha.in/ to follow your validator status.

3. Run the `status` command via the [EigenPod Proofs Generation CLI](https://github.com/Layr-Labs/eigenpod-proofs-generation/tree/master/cli#proof-generation). The command will confirm the withdrawal address is set correctly and the validator is active on the beacon chain.

![](/img/restake-guides/native-cli-status.png)


#### Part 3: Link the Validator to the EigenPod via Proof Generation

1. Run the `credentials` command via the [EigenPod Proofs Generation CLI](https://github.com/Layr-Labs/eigenpod-proofs-generation/tree/master/cli#proof-generation).
    

2. Invoke the `credentials` command with the `--sender $EIGENPOD_OWNER_PK` argument so that CLI will submit proofs and act on-chain for you. This is the private key of the wallet that was used to create the EigenPod. Example here:
```bash
./cli credentials --execNode $NODE_ETH --beaconNode $NODE_BEACON --podAddress $EIGENPOD_ADDRESS --sender $EIGENPOD_OWNER_PK
```

3. Invoke the `status` command to confirm restaked shares increased by the anticipated amount.

4. Your validator ETH balance is now Restaked.




### Convert Consensus Rewards to Restaked Shares

As of the PEPE release, users can now convert consensus rewards and validator execution fees to restaked shares.  Initiating and completing a checkpoint proof will automatically convert any consensus rewards to restaked shares for the EigenPod.

1. Check the status command via `./cli status` to determine how many additional shares the user would gain from completing a checkpoint at this time.
2. Generate [checkpoint proof ](https://github.com/Layr-Labs/eigenpod-proofs-generation/tree/master/cli#checkpoint-proofs)via eigenpod-proofs-generation CLI in order to initiate and complete a checkpoint. This command will both start the checkpoint and run verify proofs until the checkpoint is completed.


#### Checkpoint Frequency

To optimize gas costs, initiating a checkpoint no more than once every two weeks is generally recommended. Waiting longer 
before performing a checkpoint can lead to greater gas savings, as the gas cost remains the same regardless of the number of 
consensus rewards being proven. Users should choose a checkpoint interval that aligns with their gas cost considerations and restaking benefits.

Consensus rewards are transferred from the beacon chain to your EigenPod approximately every 9 days, according to the Ethereum protocol. 
Creating checkpoints more than once per sweep provides no additional benefit.

### Withdraw 

There are two options when withdrawing restaked validator ETH:
* Exit validator and withdraw restaked balance.
* Continue as a validator and withdraw yield only.

With the exception of stopping and exiting the validator, the two processes are the same. The process to withdraw restaked validator ETH is:

1. [If exiting the validator, stop the validator and wait for the validator to go through the exit queue.](#step-1-stopping-validator)
2. [Generate a checkpoint proof to bring the balance in your EigenPod up to date.](#step-2-generate-checkpoint-proof)
3. [Determine the number of shares available to withdraw.](#step-3-determine-the-number-of-withdrawable-shares)
4. [Queue a withdrawal, and wait for EigenLayer escrow period.](#step-4-queue-withdrawal)
5. [Complete withdrawal.](#step-5-complete-withdrawal)

#### Step 1 Stopping Validator

If exiting validator and withdrawing restaked balance, fully exit the validator:
1. Monitor the validator activity at [beaconcha.in/validator/\[yourvalidatorid](http://beaconcha.in/validator/\[yourvalidatorid)\].
2. Wait for the final beacon chain withdrawal to be deposited to your EigenPod.

After a validator's status changes to "exited", it can take between 24 hours and 10 days for its ETH to be transferred to
the EigenPod. See the "Withdrawals" tab and "Time" column for your validator via beaconcha.in/validator/[yourvalidatorid]#withdrawals .
The ETH will then be viewable in the EigenPod's address on the Execution Layer.

#### Step 2 Generate Checkpoint Proof

Generate checkpoint proof using [eigenpod-proofs-generation CLI](https://github.com/Layr-Labs/eigenpod-proofs-generation/tree/master/cli#checkpoint-proofs) to account for any ETH that has accumulated in the EigenPod. 
Once completed, the balance in your EigenPod is up to date.

#### Step 3 Determine the Number of Withdrawable Shares

To determine the number of withdrawable shares:
1. Invoke `[YourEigenPodContract].withdrawableRestakedExecutionLayerGwei()` to get the amount of withdrawable execution layer ETH in Gwei.
2. Convert the Gwei to Wei (multiply Gwei by 10^9 or 1,000,000,000).

#### Step 4 Queue Withdrawal

To queue withdrawal:

1. As the EigenPod Owner wallet, invoke the [`DelegationManager.queueWithdrawals()`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md#queuewithdrawals) function with:
   * [`QueuedWithdrawalParams`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/src/contracts/interfaces/IDelegationManager.sol#L116)
   * Beacon chain ETH strategy (`0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0`).
   * Amount of withdrawable shares in Wei.
2. Wait for the EigenLayer escrow period.

:::note
If you queue a withdrawal with an amount of shares higher than the withdrawable shares, you may have to exit validators and complete 
a checkpoint or restart the escrow process before the withdrawal can be completed.
:::

#### Step 5 Complete withdrawal

As the EigenPod Owner Wallet, invoke the [`DelegationManager.completeQueuedWithdrawal()`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md#completequeuedwithdrawal) function.

:::note
Withdrawals can only be cancelled after waiting the full escrow period. To cancel a withdrawal, invoke the [`DelegationManager.completeQueuedWithdrawal()`](https://github.com/Layr-Labs/eigenlayer-contracts/blob/dev/docs/core/DelegationManager.md#completequeuedwithdrawal)
function with the parameter `receiveAsTokens` set to `FALSE`.
:::

## FAQ

### Queue withdrawal takes an `amount` as input, what will that value be?

The input amount for `DelegationManager.queueWithdrawal()` can be any amount you like. However, it must be less than or 
equal to `withdrawableRestakedExecutionLayerGwei` when the withdrawal is completed.

The value of `withdrawableRestakedExecutionLayerGwei` is any withdrawable (that is, has not been slashed in EigenLayer) ETH
in the EigenPod contract address after a checkpoint, independent of its source. Sources of withdrawable ETH include consensus 
rewards, exited validators, direct transfers of ETH, and ETH from self-destructed contracts.

### How do you account for the exchange rates between Strategy token `amounts` and `shares`?

Invoke `[Strategy].underlyingToShares()` and `[Strategy].sharesToUnderlying()` as needed to convert their current balances between shares and underlying token amounts.


---

---
sidebar_position: 2
title: Claim Rewards using EigenLayer App
---

For information on Rewards concepts, refer to [Rewards Overview](../../eigenlayer/concepts/rewards/rewards-concept.md).

When claiming Rewards using the [EigenLayer app](https://app.eigenlayer.xyz/):
* The [rewards recipient](../../eigenlayer/concepts/rewards/earners-claimers-recipients.md) cannot be specified and is always the [Earner](../../eigenlayer/concepts/rewards/earners-claimers-recipients.md).
* Batch claiming cannot be used.

To specify the [rewards recipient](../../operators/howto/claimrewards/claim-rewards-cli.mdx) or [batch claim](../../operators/howto/claimrewards/batch-claim-rewards.md), claim using the EigenLayer CLI.

## Earner

To claim rewards using the EigenLayer app as an [Earner](../../eigenlayer/concepts/rewards/earners-claimers-recipients.md):

1. Navigate to the _Dashboard_ tab. Claimable rewards are displayed for AVS Rewards and Programmatic Incentives. 
2. Click the *Claim Rewards* button.
3. Select tokens individually you wish to claim rewards for or click *Select All* to claim all token rewards at once.
4. Click the *Claim Tokens* button. A transaction is initiated in your Web3 wallet to include claim proof.
5. Sign the transaction. The summary of rewards claimed is displayed. 

## Claimer

A Claimer address has permission for one or more Earner profiles. Each profile represents an Earner address for which the 
Claimer has claim privileges.

To claim rewards using the EigenLayer app as a Claimer:
1. Log in to the EigenLayer app with Claimer address. A list of Earner profiles associated with the Claimer address are displayed.
2. Select an Earner profile. The claimable rewards for the Earner are displayed.
3. Follow steps 2 to 5 as for claiming as an Earner.

When logged in as a Claimer, the only option visible is the Claim Rewards option.

:::note
If a Claimer address is associated with more than 100 Earner profiles, delays of up to 10 seconds may be experienced while loading. 
We are working to optimize this behavior. If you experience delays, allow sufficient time to load all profiles.
:::

---

---
sidebar_position: 4
title: Restaking Smart Contract Developer (Testnet)
---

The following instructions include an overview of the changes to Smart Contract Restaking per the Slashing and Operator Set release. All existing instructions on [Restaking Smart Contract Developer](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-developer-guide) remain unchanged for this update, except where noted below.

The following is not a complete description of the Slashing and Operator Sets upgrade and is qualified in its entirety by reference to the [Unique Stake Allocation & Deallocation ELIP-002](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md#unique-stake-allocation--deallocation).

Key EigenLayer Protocol references for this guide:

* [Source Code](https://github.com/Layr-Labs/eigenlayer-contracts/tree/slashing-magnitudes/src/contracts): for all the following references to EigenLayer core contracts and functions, please see the src/contracts folder for their source code.  
* [Developer Documentation (specifications)](https://github.com/Layr-Labs/eigenlayer-contracts/tree/slashing-magnitudes/docs): detailed protocol specifications for restaking smart contract integration developers.  
* [Deployed Contract Addresses](http://todo): deployed contract addresses for Mainnet and Testnet.  
* [Integration Tests](https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/src/test/integration): tests that serve as examples on how to interact with the EigenLayer core contracts.

### Withdraw (Unstake) Liquid Tokens[​](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-developer-guide#withdraw-unstake-liquid-tokens)

1. Invoke `DelegationManager.getWithdrawableShares()` to determine the Staker’s **withdrawable shares**, which represent deposited shares minus slashed shares.  withdrawable shares, which represent deposited shares minus slashed shares.  
2. Prepare the 'depositShares' parameter for the queueWithdrawals() function.  
   * Pass the number of **withdrawable shares** as input to the `convertToDepositShares()` function.  
   * The resulting value represents the amount to be used in the 'depositShares' parameter in the queueWithdrawals() function.  
3. Queue Withdrawal: invoke DelegationManager.[queueWithdrawals()](https://github.com/Layr-Labs/eigenlayer-contracts/blob/slashing-magnitudes/src/contracts/core/DelegationManager.sol#L195) to trigger the escrow period.   
   * Please see the `QueuedWithdrawalParams` struct documentation for more details on how to construct the input parameters.
   * Please see further detail [here](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-user-guide/#escrow-period-withdrawal-delay) on the escrow period.  
4. Complete Withdrawal as Tokens: invoke DelegationManager.completeQueuedWithdrawal() to complete the withdrawal and return assets to the withdrawer's wallet.

### Delegation

The [Delegation steps](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-developer-guide#smart-contract-delegation-user-guide) remain unchanged for the Slashing and Operator Set release. 

Note: For a given asset, if the Operator has been slashed 100% for that Strategy, then **no new Stakers** can delegate to the Operator if they hold this Strategy asset. This was designed to avoid smart contract division by zero (0) errors.

### Withdraw Native ETH Balance[​](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-developer-guide#withdraw-validator-restaked-balance)

This process is intended to allow users to withdraw their Native beacon chain balance from the EigenPod.

1. Validator Exit  
   * Fully exit the Validator. You may monitor its activity via beaconcha.in/validator/\[yourvalidatorid\] . 
   * Wait for the final beacon chain withdrawal to be deposited to your EigenPod. There can be a lag of up to 24 hours to 7 days between the validator appearing as "exited" and the withdrawal amount deposited to EigenPod. Please see the "Withdrawals" tab and "Time" column for your validator via beaconcha.in/validator/\[yourvalidatorid\]\#withdrawals . The ETH will then be recognized in the EigenPod.  
2. Generate [checkpoint proof](https://github.com/Layr-Labs/eigenpod-proofs-generation/tree/master/cli#checkpoint-proofs) via eigenpod-proofs-generation CLI in order to initiate and complete a checkpoint.  
3. Determine the number of **withdrawable shares**.  
   * Invoke `DelegationManager.getWithdrawableShares()` to determine the Staker’s withdrawable shares, which represent deposited shares minus slashed shares.  
   * Invoke `[YourEigenPod].withdrawableRestakedExecutionLayerGwei()` to get the amount of withdrawable execution layer ETH in gwei. Convert the gwei to wei (multiply by by 10^9 or 1,000,000,000).  
   * Confirm the number of withdrawable shares is less than withdrawableRestakedExecutionLayerGwei. Otherwise, the withdrawal will not be completable after it is queued.  
4. Prepare the `depositShares` parameter for the queueWithdrawals() function.  
   * Pass the number of **withdrawable shares** as input to the `convertToDepositShares()` function.  
   * The resulting value represents the amount to be used in the `depositShares` parameter in the queueWithdrawals() function.  
5. Invoke the DelegationManager.queueWithdrawals() function.  
   * This function can only be invoked by the EigenPod Owner wallet.  
   * Please see the `QueuedWithdrawalParams` struct documentation for more details on how to construct the input parameters.
   * strategies \- use the Beacon chain ETH strategy (0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0).  
6. Wait for the Escrow Period to complete.  
7. Invoke `DelegationManager.completeQueuedWithdrawal()`.

### Withdraw Yield Only[​](https://docs.eigenlayer.xyz/eigenlayer/restaking-guides/restaking-developer-guide#withdraw-yield-only)

This process is intended to allow users to withdraw yield (beacon chain consensus rewards, execution fees, and ETH) from the EigenPod.

1. Generate [checkpoint proof](https://github.com/Layr-Labs/eigenpod-proofs-generation/tree/master/cli#checkpoint-proofs) via eigenpod-proofs-generation CLI in order to initiate and complete a checkpoint.  
2. Determine the number of **withdrawable shares**.  
   * Invoke `DelegationManager.getWithdrawableShares()` to determine the Staker’s withdrawable shares, which represent deposited shares minus slashed shares.  
   * Invoke `[YourEigenPod].withdrawableRestakedExecutionLayerGwei()` to get the amount of withdrawable execution layer ETH in gwei. Convert the gwei to wei (multiply by by 10^9 or 1,000,000,000).  
   * Confirm the number of withdrawable shares is less than withdrawableRestakedExecutionLayerGwei. Otherwise, the withdrawal will not be completable after it is queued.  
3. Prepare the `depositShares` parameter for the queueWithdrawals() function.  
   * Pass the number of **withdrawable shares** as input to the `convertToDepositShares()` function.  
   * The resulting value represents the amount to be used in the `depositShares` parameter in the queueWithdrawals() function.  
4. Invoke the DelegationManager.queueWithdrawals() function.  
   * This function can only be invoked by the EigenPod Owner wallet.  
   * Please see the `QueuedWithdrawalParams` struct documentation for more details on how to construct the input parameters.
   * strategies \- use the Beacon chain ETH strategy (0xbeaC0eeEeeeeEEeEeEEEEeeEEeEeeeEeeEEBEaC0).  
5. Wait for the Escrow Period to complete.  
6. Invoke DelegationManager.completeQueuedWithdrawal().

---

---
sidebar_position: 4
title: Testnet Restaking
---

## Testing Restaking on the Holesky Testnet

Users are encouraged to first test their staking approach on the Holesky Testnet prior to restaking on ETH Mainnet.

* Follow the instructions in [Obtaining Testnet ETH & Liquid Staking Tokens (LSTs)](obtaining-testnet-eth-and-liquid-staking-tokens-lsts.md) to fund your Testnet wallet.
* Visit [holesky.eigenlayer.xyz](https://holesky.eigenlayer.xyz/) for the most recent EigenLayer Testnet web app.



## Testnet vs Mainnet Differences

- Withdraw (Escrow) Period:
    - All funds unstaked from _EigenLayer Testnet_ go through a delay (escrow period) of 25 blocks (roughly 5 minutes) before being able to be withdrawn.
    - Liquid tokens and Native Restaking funds unstaked from _EigenLayer Mainnet_ will go through a 14-day escrow period before being able to be withdrawn.
- Testnet includes the Slashing and Operator Sets upgrade. Please see [ELIP-002: Slashing via Unique Stake & Operator Sets](https://github.com/eigenfoundation/ELIPs/blob/main/ELIPs/ELIP-002.md) for more information.



---

---
sidebar_position: 2
---

# Obtaining Testnet ETH & Liquid Staking Tokens (LSTs)

In this guide, we will show you how to use a Holesky faucet to load your wallet with [testnet ETH](https://ethereum.org/en/developers/docs/networks/#ethereum-testnets) and how to obtain Holesky Liquid Staking Tokens so you can start testing liquid restaking.

### Prerequisites

Before you can use a faucet to load your wallet with testnet ETH, you will need:

- An Ethereum-compatible wallet (e.g. MetaMask). Take note of its public address.
- Add Holesky network to your Web3 wallet (example instructions [here](https://www.coingecko.com/learn/holesky-testnet-eth#add-the-holesky-testnet-to-metamask)) if it does not automatically appear.

## Obtain Holesky ETH (aka holETH) via a Faucet

Once you have a Holesky compatible wallet and a Holesky ETH address, you can use a faucet to load your wallet with testnet ETH. Here are options available to obtain holETH:
- [Holešky PoW Faucet](https://holesky-faucet.pk910.de)
- [Quicknode Faucet](https://faucet.quicknode.com/ethereum/holesky)
- [Automata Faucet](https://www.holeskyfaucet.io/)
- [Google Cloud Faucet](https://cloud.google.com/application/web3/faucet/ethereum/holesky)

## Swap holETH for wETH (Wrapped ETH)​
- Send holETH to address 0x94373a4919B3240D86eA41593D5eBa789FEF3848.
- Import the WETH token address (0x94373a4919B3240D86eA41593D5eBa789FEF3848) to your web3 wallet to view your token balance.

## Swap holETH for stETH (Lido)​
- Visit: https://stake-holesky.testnet.fi/
- Connect your web3 wallet, choose the amount and click **Stake**.
- Import the [Lido and stETH token (proxy)](https://docs.lido.fi/deployed-contracts/holesky/) address for Holesky stETH token to your web3 wallet to view your token balance.
- Note: Lido on Holesky staking is rate-limited to 1500 holETH per rolling 24hr window.

## Swap holETH for ETHx (Stader)​
- Visit the Stader Holesky proxy contract’s Write as Proxy contract in Etherscan here: [0x7F09ceb3874F5E35Cd2135F56fd4329b88c5d119](https://holesky.etherscan.io/address/0x7F09ceb3874F5E35Cd2135F56fd4329b88c5d119#writeProxyContract).
- Click *Connect to Web3* to connect your web3 wallet.
- Click either of the **1.deposit()** or **2.deposit()** functions to expand their section:
- payableAmount: Enter the ETH amount you wish to deposit.
- _receiver: the recipient of the ETHx. Most likely this will be your wallet address.
- _referralId (string): use the empty string (“”), if prompted.
- Click *Write* to initiate the transaction. Approve the transaction in your web3 wallet.
- Import the Holesky ETHx token address (0xB4F5fc289a778B80392b86fa70A7111E5bE0F859) to your web3 wallet to view your token balance.

## Stake holETH for ankrETH (Ankr)​
- Visit [testnet.ankr.com/staking/stake/ethereum](https://testnet.ankr.com/staking/stake/ethereum/).
- Follow the instructions on screen to stake (convert) your desired amount of Holesky ETH for Holesky ankrETH.
- Click “Add ankrETH to wallet” to add the ankrETH token to your web3 wallet and view your available balance.

## Mint osETH (Stakewise)
- Visit the [Stakewise Holesky Vault Marketplace](https://app.stakewise.io/vaults?networkId=holesky).
- Select a vault to mint osETH.
- Input the amount you wish to stake and click **Stake** and verify the transaction in your Web3 wallet.
- Click *Mint* to convert your staked holETH to osETH and verify the transaction in your Web3 wallet.
- Click “Add osETH to your Wallet” 
- Or import the osETH address (0xF603c5A3F774F05d4D848A9bB139809790890864) for Holesky stETH token to your web3 wallet to view your token balance.


## Mint and Stake to Swap holETH for sfrxETH
- Add Holesky to your Web3 wallet (example instructions [here](https://www.coingecko.com/learn/holesky-testnet-eth#add-the-holesky-testnet-to-metamask)).
- Manually switch your wallet to the Holesky network. The Frax Finance app does not allow the user to choose Holesky directly. 
- Open the Frax Finance Mint app: [app.frax.finance/frxeth/mint](https://app.frax.finance/frxeth/mint) .
- Enter the amount you wish to mint and click **Mint & Stake**.
- Import the Holesky sfrxETH token address (0xa63f56985F9C7F3bc9fFc5685535649e0C1a55f3) to your web3 wallet to view your token balance.


## Swap holETH for mETH (Mantle ETH)​


- Visit the MantleETH proxy contract’s Write as Proxy contract in Etherscan here: [0xbe16244EAe9837219147384c8A7560BA14946262](https://holesky.etherscan.io/address/0xbe16244EAe9837219147384c8A7560BA14946262#writeProxyContract).
- Click **Connect to Web3** to connect your web3 wallet.
- Click on the **19.stake()** function to expand its section:
	- payableAmount: Enter the ETH amount you wish to deposit.
	- minMETHAmount: set to 0.
- Click **Write** to initiate the transaction. Approve the transaction in your web3 wallet.
- Import the Holesky mETH token address (0xe3C063B1BEe9de02eb28352b55D49D85514C67FF) to your web3 wallet to view your token balance.
